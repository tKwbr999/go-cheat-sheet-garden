import fs from 'fs/promises';
import path from 'path';
// 型定義のパスを修正 (スクリプトからの相対パス)
import type { CheatSheetSection, CodeExample } from '../src/data/types';

// データセクションの順序とタイトルを定義
const cheatSheetSectionsMetadata: { id: string; title: string }[] = [
  { id: "basics", title: "Basics" },
  { id: "basic-types", title: "Basic Types" },
  { id: "flow-control", title: "Flow Control" },
  { id: "functions", title: "Functions" },
  { id: "data-structures", title: "Data Structures" },
  { id: "methods", title: "Methods" },
  { id: "interfaces", title: "Interfaces" },
  { id: "packages", title: "Packages" },
  { id: "error-handling", title: "Error Handling" },
  { id: "concurrency", title: "Concurrency" },
  { id: "context", title: "Context" },
  { id: "io-operations", title: "I/O Operations" },
  { id: "generics", title: "Generics" },
  { id: "references", title: "References" },
];

const sectionsDir = path.join(__dirname, '../src/data/go-cheatsheet/sections');
const outputFilePath = path.join(__dirname, '../src/data/bundled-cheatsheet-data.ts');

// コードがコメントのみか判定するヘルパー関数
function isCommentBlock(code: string): boolean {
  const trimmedCode = code.trim();
  if (trimmedCode === "") return true;
  return trimmedCode.split("\n").every((line) => {
    const trimmedLine = line.trim();
    return trimmedLine.startsWith("//") || trimmedLine === "";
  });
}

// コメント内容を整形するヘルパー関数
function formatCommentBlock(commentCode: string): string {
  return commentCode
    .split("\n")
    .map((line) => line.trim().replace(/^\/\/\s*/, ""))
    .filter((line) => line.trim() !== "")
    .join("\n");
}

// 元データから整形済みデータを生成する関数
function processRawSectionData(rawData: { title: string; codeExamples: { title: string; code: string }[] }): CheatSheetSection {
    const processedExamples: CodeExample[] = [];
    let previousExample: CodeExample | null = null;

    for (const currentExample of rawData.codeExamples) {
      if (isCommentBlock(currentExample.code)) {
        if (previousExample) {
          previousExample.description = formatCommentBlock(currentExample.code);
        }
      } else {
        // description プロパティを持つ新しいオブジェクトを作成
        const newExample: CodeExample = {
             title: currentExample.title,
             code: currentExample.code,
             description: undefined // description を初期化
        };
        processedExamples.push(newExample);
        previousExample = newExample; // 次の反復のために保持
      }
    }
    return {
      title: rawData.title, // JSONファイルからタイトルを取得
      codeExamples: processedExamples,
    };
}

async function bundleData() {
  console.log('Bundling cheatsheet data...');
  const allSectionsData: (CheatSheetSection & { id: string })[] = [];

  for (const meta of cheatSheetSectionsMetadata) {
    const filePath = path.join(sectionsDir, `${meta.id}.json`);
    try {
      const fileContent = await fs.readFile(filePath, 'utf-8');
      // JSON.parse の前にファイル内容が空でないか確認
      if (!fileContent.trim()) {
          console.warn(`Warning: File is empty, skipping: ${filePath}`);
          continue; // 空のファイルはスキップ
      }
      const rawData = JSON.parse(fileContent);
      // rawData と rawData.codeExamples が存在するか確認
      if (!rawData || !Array.isArray(rawData.codeExamples)) {
          console.warn(`Warning: Invalid data structure in ${filePath}, skipping.`);
          continue;
      }
      const processedData = processRawSectionData(rawData);
      allSectionsData.push({
        id: meta.id,
        // processRawSectionData が title を含めて返すように修正したので、
        // meta.title ではなく processedData.title を使う
        ...processedData,
      });
      console.log(`Processed: ${meta.id}.json`);
    } catch (error) {
      // JSON パースエラーなどもここでキャッチ
      console.error(`Error processing ${filePath}:`, error);
    }
  }

  // TypeScript ファイルとして出力
  const outputContent = `// This file is auto-generated by scripts/bundle-cheatsheet-data.ts
// Do not edit this file directly.

import type { CheatSheetSection } from './types';

// 型アサーションを追加して、型安全性を高める
export const bundledCheatSheetData: (CheatSheetSection & { id: string })[] = ${JSON.stringify(allSectionsData, null, 2)} as (CheatSheetSection & { id: string })[];

export default bundledCheatSheetData;
`;

  try {
    // 出力先ディレクトリが存在しない場合に作成
    await fs.mkdir(path.dirname(outputFilePath), { recursive: true });
    await fs.writeFile(outputFilePath, outputContent, 'utf-8');
    console.log(`Successfully bundled data to ${outputFilePath}`);
  } catch (error) {
    console.error(`Error writing bundled data file:`, error);
  }
}

bundleData();