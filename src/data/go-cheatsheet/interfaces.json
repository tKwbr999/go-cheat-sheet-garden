{
  "title": "Interfaces",
  "codeExamples": [
    {
      "title": "Defining Interfaces",
      "code": "// Interface definition - a set of method signatures\ntype Shape interface {\n  Area() float64\n  Perimeter() float64\n}\n\n// Types that implement the interface\ntype Rectangle struct {\n  Width, Height float64\n}\n\nfunc (r Rectangle) Area() float64 {\n  return r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n  return 2 * (r.Width + r.Height)\n}\n\ntype Circle struct {\n  Radius float64\n}\n\nfunc (c Circle) Area() float64 {\n  return math.Pi * c.Radius * c.Radius\n}\n\nfunc (c Circle) Perimeter() float64 {\n  return 2 * math.Pi * c.Radius\n}\n\n// Using interfaces\nfunc printShapeInfo(s Shape) {\n  fmt.Printf(\"Area: %f, Perimeter: %f\\n\", \n    s.Area(), s.Perimeter())\n}\n\nrect := Rectangle{5, 10}\nprintShapeInfo(rect)   // Implicitly satisfies Shape\n\ncirc := Circle{5}\nprintShapeInfo(circ)   // Also satisfies Shape"
    },
    {
      "title": "Interface Values",
      "code": "// Interface values are two-word structures:\n// 1. A pointer to type information (type descriptor)\n// 2. A pointer to the actual data (value)\n\n// nil interface\nvar s Shape  // Zero value is nil\nfmt.Println(s == nil)  // true\n\n// Interface with concrete value\ns = Rectangle{5, 10}  // s contains type info and value\nfmt.Printf(\"%T\\n\", s)  // \"main.Rectangle\"\n\n// Interface with nil value (but defined type)\nvar p *Rectangle = nil\ns = p  // s has type info but nil value\nfmt.Println(s == nil)  // false - interface value is not nil\nfmt.Printf(\"%T\\n\", s)  // \"*main.Rectangle\"\n\n// Type assertions\nrect, ok := s.(Rectangle)  // Extract concrete value if it's a Rectangle\nif ok {\n  fmt.Println(\"It's a rectangle:\", rect)\n}\n\n// Type switches\nswitch v := s.(type) {\ncase Rectangle:\n  fmt.Println(\"Rectangle with area:\", v.Area())\ncase Circle:\n  fmt.Println(\"Circle with radius:\", v.Radius)\ncase nil:\n  fmt.Println(\"nil shape\")\ndefault:\n  fmt.Println(\"Unknown shape\")\n}"
    },
    {
      "title": "Empty Interface",
      "code": "// Empty interface (interface{} or any in Go 1.18+) can hold any value\nvar i interface{}  // or: var i any (Go 1.18+)\n\ni = 42            // int\ni = \"hello\"       // string\ni = struct{}{}    // struct\ni = map[string]int{\"key\": 1}  // map\n\n// Type assertions\nstr, ok := i.(string)\nif ok {\n  fmt.Println(str) // \"hello\"\n}\n\n// Type assertion without check (panics if wrong type)\nn := i.(int)  // will panic if i is not an int\n\n// Type switch for safe type checking\nswitch v := i.(type) {\ncase int:\n  fmt.Println(\"int:\", v)\ncase string:\n  fmt.Println(\"string:\", v)\ncase map[string]int:\n  fmt.Println(\"map:\", v[\"key\"])\ndefault:\n  fmt.Println(\"unknown type\")\n}\n\n// Common uses of empty interface\n// 1. fmt.Println takes ...interface{}\nfmt.Println(\"value:\", 42, true)\n\n// 2. Containers holding mixed types\nmixed := []interface{}{42, \"hello\", true}\n\n// 3. JSON unmarshaling with dynamic structure\nvar data interface{}\njson.Unmarshal(jsonBytes, &data)"
    },
    {
      "title": "Interface Composition",
      "code": "// Interfaces can be composed of other interfaces\ntype Reader interface {\n  Read(p []byte) (n int, err error)\n}\n\ntype Writer interface {\n  Write(p []byte) (n int, err error)\n}\n\n// ReadWriter combines Reader and Writer\ntype ReadWriter interface {\n  Reader\n  Writer\n}\n\n// A type implements ReadWriter if it implements both Reader and Writer\ntype Buffer struct {\n  // ...\n}\n\nfunc (b *Buffer) Read(p []byte) (n int, err error) {\n  // Implementation\n  return len(p), nil\n}\n\nfunc (b *Buffer) Write(p []byte) (n int, err error) {\n  // Implementation\n  return len(p), nil\n}\n\n// Now Buffer can be used as a ReadWriter\nvar rw ReadWriter = &Buffer{}\n\n// Standard library examples\n// io.ReadCloser, io.WriteCloser, io.ReadWriteCloser"
    },
    {
      "title": "Interface Best Practices",
      "code": "// 1. Keep interfaces small (single responsibility)\n// Good:\ntype Reader interface {\n  Read(p []byte) (n int, err error)\n}\n\ntype Writer interface {\n  Write(p []byte) (n int, err error)\n}\n\n// 2. Accept interfaces, return concrete types\n// Good:\nfunc processData(r Reader) *Result {\n  // Process data from any Reader\n  return &Result{...}\n}\n\n// 3. Define interfaces at the point of use, not implementation\n// Good (in client code):\ntype UserStore interface {\n  GetUser(id string) (*User, error)\n  SaveUser(user *User) error\n}\n\n// 4. Use interface naming conventions\n// Single method interfaces often end in -er\ntype Reader interface { Read(...) }  // Good\ntype Writer interface { Write(...) } // Good\n\n// 5. Avoid overusing empty interface\n// Bad:\nfunc Process(data interface{}) interface{} {...}\n\n// Better:\nfunc Process(data UserData) Result {...}\n\n// 6. Return nil interface value correctly\n// Incorrect (returns non-nil interface):\nfunc getData() io.Reader {\n  var p *bytes.Buffer = nil\n  return p  // Returns non-nil interface with nil value\n}\n\n// Correct:\nfunc getData() io.Reader {\n  return nil  // Return nil interface"
    },
    {
      "title": "Generics and Interfaces (Go 1.18+)",
      "code": "// Type parameters (generics) and interfaces\n\n// Constraint interface (defines allowed types)\ntype Number interface {\n  int | int32 | int64 | float32 | float64\n}\n\n// Generic function with constraint\nfunc Sum[T Number](values []T) T {\n  var sum T\n  for _, v := range values {\n    sum += v\n  }\n  return sum\n}\n\n// Usage\nints := []int{1, 2, 3, 4}\nsum := Sum(ints)  // Type inference: sum is int\n\nfloats := []float64{1.1, 2.2, 3.3}\nfloatSum := Sum(floats)  // Type inference: floatSum is float64\n\n// Type parameters with method constraints\ntype Stringer interface {\n  String() string\n}\n\nfunc Join[T Stringer](values []T, sep string) string {\n  result := \"\"\n  for i, v := range values {\n    if i > 0 {\n      result += sep\n    }\n    result += v.String()\n  }\n  return result\n}\n\n// Generic data structures\ntype List[T any] struct {\n  data []T\n}\n\nfunc (l *List[T]) Add(item T) {\n  l.data = append(l.data, item)\n}\n\nfunc (l *List[T]) Get(index int) T {\n  return l.data[index]\n}"
    }
  ]
}