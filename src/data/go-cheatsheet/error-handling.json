{
  "title": "Error handling",
  "codeExamples": [
    {
      "title": "Errors",
      "code": "// Error interface\ntype error interface {\n  Error() string\n}\n\n// Creating errors\n// Simple error with text\nerr1 := errors.New(\"something went wrong\")\n\n// Formatted error (more common)\nerr2 := fmt.Errorf(\"process failed: %s\", detail)\n\n// Function returning an error\nfunc divide(a, b int) (int, error) {\n  if b == 0 {\n    return 0, errors.New(\"division by zero\")\n  }\n  return a / b, nil  // nil indicates no error\n}\n\n// Error handling\nresult, err := divide(10, 2)\nif err != nil {\n  // Error path\n  fmt.Println(\"Error:\", err)\n  return  // Early return on error is idiomatic\n}\n// Happy path\nfmt.Println(\"Result:\", result)\n\n// Wrapping errors (Go 1.13+) to add context\nif err := loadConfig(filename); err != nil {\n  return fmt.Errorf(\"config processing failed: %w\", err)\n}\n\n// Errors are values\n// We can store, return, and check them like any other value\nvar ErrNotFound = errors.New(\"not found\")\n\nfunc findItem(id string) (*Item, error) {\n  // ...\n  return nil, ErrNotFound\n}\n\nif errors.Is(err, ErrNotFound) {\n  // Handle not found case\n}"
    },
    {
      "title": "Custom errors",
      "code": "// Define a custom error type\ntype MyError struct {\n  Code    int\n  Message string\n}\n\n// Implement the Error interface\nfunc (e *MyError) Error() string {\n  return fmt.Sprintf(\"error %d: %s\", e.Code, e.Message)\n}\n\n// Return a custom error\nfunc doSomething() error {\n  return &MyError{\n    Code:    500,\n    Message: \"something went wrong\",\n  }\n}\n\n// Type assertion to access custom error fields\nif err := doSomething(); err != nil {\n  if myErr, ok := err.(*MyError); ok {\n    fmt.Println(\"Code:\", myErr.Code)\n  }\n}\n\n// Using errors.As (Go 1.13+) for type checking\nvar myErr *MyError\nif errors.As(err, &myErr) {\n  fmt.Println(\"Code:\", myErr.Code)\n}\n\n// Creating hierarchical errors with wrapping\nfunc request() error {\n  err := connect()\n  if err != nil {\n    return fmt.Errorf(\"request failed: %w\", err)\n  }\n  // ...\n}\n\n// Checking for wrapped errors\nif errors.Is(err, ErrConnRefused) {\n  // Handle connection refused error\n}"
    },
    {
      "title": "Error Patterns",
      "code": "// Sentinel errors (predefined errors)\nvar (\n  ErrNotFound     = errors.New(\"not found\")\n  ErrUnauthorized = errors.New(\"unauthorized\")\n  ErrTimeout      = errors.New(\"timeout\")\n)\n\n// Error checking\nif errors.Is(err, ErrNotFound) {\n  // Handle not found case\n}\n\n// Avoiding repetitive checks with early return\nfunc process() error {\n  err := step1()\n  if err != nil {\n    return fmt.Errorf(\"step1 failed: %w\", err)\n  }\n  \n  err = step2()\n  if err != nil {\n    return fmt.Errorf(\"step2 failed: %w\", err)\n  }\n  \n  return step3()\n}\n\n// Error handling middleware (for HTTP servers)\nfunc errorHandler(next http.Handler) http.Handler {\n  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n    defer func() {\n      if r := recover(); r != nil {\n        log.Printf(\"panic: %v\", r)\n        http.Error(w, \"internal server error\", http.StatusInternalServerError)\n      }\n    }()\n    next.ServeHTTP(w, r)\n  })\n}\n\n// Structured errors (with different fields)\ntype FieldError struct {\n  Field string\n  Value interface{}\n  Msg   string\n}\n\nfunc (f *FieldError) Error() string {\n  return fmt.Sprintf(\"invalid value %v for field %s: %s\", f.Value, f.Field, f.Msg)\n}"
    },
    {
      "title": "Error Handling in Go 1.20+",
      "code": "// Multiple error joining (Go 1.20+)\nimport \"errors\"\n\n// Join combines multiple errors into a single error\nfunc validateForm(data Form) error {\n  var errs []error\n  \n  if data.Name == \"\" {\n    errs = append(errs, errors.New(\"name is required\"))\n  }\n  \n  if data.Email == \"\" {\n    errs = append(errs, errors.New(\"email is required\"))\n  }\n  \n  if len(errs) > 0 {\n    return errors.Join(errs...)  // Returns a single error\n  }\n  return nil\n}\n\n// Unwrapping multiple errors\nerr := validateForm(form)\nvar nameErr *NameError\nif errors.As(err, &nameErr) {\n  // Handle name error\n}\n\n// Iterating through joined errors\nfmt.Println(\"Validation errors:\")\nerrs := make([]error, 0)\nerrors.Unwrap(err, func(e error) bool {\n  errs = append(errs, e)\n  return true  // Continue unwrapping\n})\n\nfor _, e := range errs {\n  fmt.Println(\"-\", e)\n}\n\n// defer with error handling\nfunc processFile(filename string) (err error) {\n  f, err := os.Open(filename)\n  if err != nil {\n    return fmt.Errorf(\"failed to open file: %w\", err)\n  }\n  \n  defer func() {\n    closeErr := f.Close()\n    if err == nil && closeErr != nil {\n      err = closeErr  // Pass close error to caller if no other error\n    }\n  }()\n  \n  // Process file\n  return nil\n}"
    }
  ]
}