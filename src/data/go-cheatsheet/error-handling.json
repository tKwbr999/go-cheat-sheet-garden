{
  "title": "Error handling",
  "codeExamples": [
    {
      "title": "Errors",
      "code": "// Error インターフェース\ntype error interface {\n  Error() string\n}\n\n// エラーの作成\n// テキスト付きの単純なエラー\nerr1 := errors.New(\"something went wrong\")\n\n// フォーマットされたエラー (より一般的)\nerr2 := fmt.Errorf(\"process failed: %s\", detail)\n\n// エラーを返す関数\nfunc divide(a, b int) (int, error) {\n  if b == 0 {\n    return 0, errors.New(\"division by zero\")\n  }\n  return a / b, nil  // nil はエラーがないことを示す\n}\n\n// エラー処理\nresult, err := divide(10, 2)\nif err != nil {\n  // エラーパス\n  fmt.Println(\"Error:\", err)\n  return  // エラー時の早期リターンは慣用的\n}\n// 正常系パス\nfmt.Println(\"Result:\", result)\n\n// エラーのラップ (Go 1.13+) でコンテキストを追加\nif err := loadConfig(filename); err != nil {\n  return fmt.Errorf(\"config processing failed: %w\", err)\n}\n\n// エラーは値である\n// 他の値と同様に、保存、返却、チェックが可能\nvar ErrNotFound = errors.New(\"not found\")\n\nfunc findItem(id string) (*Item, error) {\n  // ...\n  return nil, ErrNotFound\n}\n\nif errors.Is(err, ErrNotFound) {\n  // not found ケースを処理\n}"
    },
    {
      "title": "Custom errors",
      "code": "// カスタムエラー型を定義\ntype MyError struct {\n  Code    int\n  Message string\n}\n\n// Error インターフェースを実装\nfunc (e *MyError) Error() string {\n  return fmt.Sprintf(\"error %d: %s\", e.Code, e.Message)\n}\n\n// カスタムエラーを返す\nfunc doSomething() error {\n  return &MyError{\n    Code:    500,\n    Message: \"something went wrong\",\n  }\n}\n\n// 型アサーションでカスタムエラーフィールドにアクセス\nif err := doSomething(); err != nil {\n  if myErr, ok := err.(*MyError); ok {\n    fmt.Println(\"Code:\", myErr.Code)\n  }\n}\n\n// errors.As (Go 1.13+) を使用した型チェック\nvar myErr *MyError\nif errors.As(err, &myErr) {\n  fmt.Println(\"Code:\", myErr.Code)\n}\n\n// ラップによる階層的なエラーの作成\nfunc request() error {\n  err := connect()\n  if err != nil {\n    return fmt.Errorf(\"request failed: %w\", err)\n  }\n  // ...\n}\n\n// ラップされたエラーのチェック\nif errors.Is(err, ErrConnRefused) {\n  // connection refused エラーを処理\n}"
    },
    {
      "title": "Error Patterns",
      "code": "// センチネルエラー (事前定義されたエラー)\nvar (\n  ErrNotFound     = errors.New(\"not found\")\n  ErrUnauthorized = errors.New(\"unauthorized\")\n  ErrTimeout      = errors.New(\"timeout\")\n)\n\n// エラーチェック\nif errors.Is(err, ErrNotFound) {\n  // not found ケースを処理\n}\n\n// 早期リターンによる反復的なチェックの回避\nfunc process() error {\n  err := step1()\n  if err != nil {\n    return fmt.Errorf(\"step1 failed: %w\", err)\n  }\n  \n  err = step2()\n  if err != nil {\n    return fmt.Errorf(\"step2 failed: %w\", err)\n  }\n  \n  return step3()\n}\n\n// エラー処理ミドルウェア (HTTP サーバー用)\nfunc errorHandler(next http.Handler) http.Handler {\n  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n    defer func() {\n      if r := recover(); r != nil {\n        log.Printf(\"panic: %v\", r)\n        http.Error(w, \"internal server error\", http.StatusInternalServerError)\n      }\n    }()\n    next.ServeHTTP(w, r)\n  })\n}\n\n// 構造化エラー (異なるフィールドを持つ)\ntype FieldError struct {\n  Field string\n  Value interface{}\n  Msg   string\n}\n\nfunc (f *FieldError) Error() string {\n  return fmt.Sprintf(\"invalid value %v for field %s: %s\", f.Value, f.Field, f.Msg)\n}"
    },
    {
      "title": "Error Handling in Go 1.20+",
      "code": "// 複数のエラーの結合 (Go 1.20+)\nimport \"errors\"\n\n// Join は複数のエラーを単一のエラーに結合する\nfunc validateForm(data Form) error {\n  var errs []error\n  \n  if data.Name == \"\" {\n    errs = append(errs, errors.New(\"name is required\"))\n  }\n  \n  if data.Email == \"\" {\n    errs = append(errs, errors.New(\"email is required\"))\n  }\n  \n  if len(errs) > 0 {\n    return errors.Join(errs...)  // 単一のエラーを返す\n  }\n  return nil\n}\n\n// 複数のエラーのアンラップ\nerr := validateForm(form)\nvar nameErr *NameError\nif errors.As(err, &nameErr) {\n  // name エラーを処理\n}\n\n// 結合されたエラーの反復処理\nfmt.Println(\"Validation errors:\")\nerrs := make([]error, 0)\nerrors.Unwrap(err, func(e error) bool {\n  errs = append(errs, e)\n  return true  // アンラップを続行\n})\n\nfor _, e := range errs {\n  fmt.Println(\"-\", e)\n}\n\n// defer を使用したエラー処理\nfunc processFile(filename string) (err error) {\n  f, err := os.Open(filename)\n  if err != nil {\n    return fmt.Errorf(\"failed to open file: %w\", err)\n  }\n  \n  defer func() {\n    closeErr := f.Close()\n    if err == nil && closeErr != nil {\n      err = closeErr  // 他にエラーがない場合、close エラーを呼び出し元に渡す\n    }\n  }()\n  \n  // ファイルを処理\n  return nil\n}"
    }
  ]
}