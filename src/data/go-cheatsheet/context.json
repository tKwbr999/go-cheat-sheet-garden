{
  "title": "Context",
  "codeExamples": [
    {
      "title": "Context Overview",
      "code": "// Context はデッドライン、キャンセルシグナル、リクエストスコープの値を\n// API 境界を越えて、プロセス間で運ぶ\nimport \"context\""
    },
    {
      "title": "Creating Basic Contexts",
      "code": "// Context の作成\n// Background - ルート context、キャンセルされない、値なし、デッドラインなし\nctxBg := context.Background()\n\n// TODO - Background に似ているが、特定の context を\n// 使用すべきだがまだ利用できないことを示す\nctxTodo := context.TODO()"
    },
    {
      "title": "Passing Context (Convention)",
      "code": "// 最初のパラメータとして context を渡すのは慣例\nfunc DoSomething(ctx context.Context, arg Arg) error {\n  // ... context を使用 ...\n  return nil\n}\n\n// 常に context を渡す\nctx := context.Background()\nDoSomething(ctx, arg)"
    },
    {
      "title": "Chaining Context-Aware Functions",
      "code": "// context を取る関数を連鎖させる\nfunc DoSomethingMore(ctx context.Context, arg Arg) (Result, error) {\n  // context を取る別の関数を呼び出す\n  err := DoSomething(ctx, arg)\n  if err != nil {\n    return Result{}, err\n  }\n  // context でさらに処理を行う\n  return Result{}, nil\n}"
    },
    {
      "title": "Creating Cancellable Context",
      "code": "// context によるキャンセル\n\n// キャンセル可能な context を作成\nctx, cancel := context.WithCancel(context.Background())\n\n// リソースを解放するために常に cancel を呼び出す、通常は defer を使用\ndefer cancel()"
    },
    {
      "title": "Responding to Cancellation",
      "code": "// キャンセル可能な goroutine を開始\ngo func(innerCtx context.Context) {\n  for {\n    select {\n    case <-innerCtx.Done():\n      // Context がキャンセルされた、処理を停止\n      fmt.Println(\"Stopped due to cancellation\")\n      return\n    default:\n      // 何らかの処理を行う\n      fmt.Println(\"Working...\")\n      time.Sleep(100 * time.Millisecond)\n    }\n  }\n}(ctx)\n\n// 後でキャンセルをトリガー\ntime.Sleep(500 * time.Millisecond)\ncancel()\n\n// context がキャンセルされたか確認\nif ctx.Err() == context.Canceled {\n  fmt.Println(\"Context was canceled\")\n}"
    },
    {
      "title": "Cancellation in Worker Pattern",
      "code": "// ワーカーでの典型的な使用法\nfunc worker(ctx context.Context, tasks <-chan Task) {\n  for {\n    select {\n    case task, ok := <-tasks:\n      if !ok {\n// チャネルが閉じられた\n        return\n      }\n      process(ctx, task)\n    case <-ctx.Done():\n      fmt.Println(\"Worker stopping:\", ctx.Err())\n      return\n    }\n  }\n}"
    },
    {
      "title": "Context with Timeout",
      "code": "// タイムアウト付き Context - 指定時間後に自動的にキャンセルされる\nctxTimeout, cancelTimeout := context.WithTimeout(context.Background(), 2*time.Second)\n// タイムアウト前に完了した場合でも、リソースを早期に解放するために cancel を呼び出す\ndefer cancelTimeout()"
    },
    {
      "title": "Context with Deadline",
      "code": "// デッドライン付き Context - 特定の時間にキャンセルされる\ndeadline := time.Now().Add(30 * time.Second)\nctxDeadline, cancelDeadline := context.WithDeadline(context.Background(), deadline)\ndefer cancelDeadline()"
    },
    {
      "title": "Checking for Timeout/Deadline Exceeded",
      "code": "// タイムアウトまたはデッドライン超過の確認\nif ctxTimeout.Err() == context.DeadlineExceeded {\n  fmt.Println(\"Operation timed out or deadline exceeded\")\n}"
    },
    {
      "title": "Timeout/Deadline in HTTP Client",
      "code": "// HTTP クライアントでの使用\nctxHttp, cancelHttp := context.WithTimeout(context.Background(), 2*time.Second)\ndefer cancelHttp()\n\n//example.com\", nil)\nreq, err := http.NewRequestWithContext(ctxHttp, \"GET\", \"https:\nif err != nil {\n  // エラー処理\n}\n\nresp, err := http.DefaultClient.Do(req)\nif err != nil {\n  // リクエストに時間がかかりすぎた場合、context.DeadlineExceeded になる可能性がある\n  if errors.Is(err, context.DeadlineExceeded) {\n    fmt.Println(\"HTTP request timed out\")\n  }\n  // その他のエラー処理\n}\nif resp != nil {\n  defer resp.Body.Close()\n}"
    },
    {
      "title": "Timeout/Deadline in Database Operations",
      "code": "// データベース操作での使用\nctxDb, cancelDb := context.WithTimeout(context.Background(), 1*time.Second)\ndefer cancelDb()\n\n// db は *sql.DB\nrows, err := db.QueryContext(ctxDb, \"SELECT * FROM users WHERE id = ?\", 1)\nif err != nil {\n  if errors.Is(err, context.DeadlineExceeded) {\n    fmt.Println(\"Database query timed out\")\n  }\n  // その他のエラー処理\n}\nif rows != nil {\n  defer rows.Close()\n}"
    },
    {
      "title": "Adding Values to Context",
      "code": "// Context 値 - リクエストスコープのキーバリューペア\n\n// context に値を追加 (新しい context を作成)\nctx := context.Background()\nctx = context.WithValue(ctx, \"userID\", \"12345\")\nctx = context.WithValue(ctx, \"authToken\", \"token-123\")"
    },
    {
      "title": "Retrieving Values from Context",
      "code": "// 値の取得\nuserID, ok := ctx.Value(\"userID\").(string)\nif !ok {\n  fmt.Println(\"UserID not found or not a string\")\n} else {\n  fmt.Println(\"UserID:\", userID)\n}"
    },
    {
      "title": "Context Value Keys (Best Practice)",
      "code": "// ベストプラクティス: キーとしてカスタム型を使用する\n// パッケージ間でのキー衝突を避けるため\ntype contextKey string\n\nconst (\n  userIDKey   contextKey = \"userID\"\n  authTokenKey contextKey = \"authToken\"\n)\n\nctx := context.WithValue(context.Background(), userIDKey, \"12345\")\nuserID, ok := ctx.Value(userIDKey).(string)\n\n// より良い名前空間分離のためにキーとして構造体を使用する\ntype UserContextKey struct{}\ntype RequestContextKey struct{}\n\nctx = context.WithValue(ctx, UserContextKey{}, user)\nctx = context.WithValue(ctx, RequestContextKey{}, request)\n\nuserVal, ok := ctx.Value(UserContextKey{}).(User)"
    },
    {
      "title": "Context Value Warning",
      "code": "// 警告: オプションパラメータを渡すために context 値を使用しない\n// 主に API 境界を越えるリクエストスコープデータに使用する"
    },
    {
      "title": "Propagating Context Through Call Stack",
      "code": "// コールスタックを通じて context を伝播させる\nfunc HandleRequest(w http.ResponseWriter, r *http.Request) {\n  // リクエスト context を抽出\n  ctx := r.Context()\n  \n  // タイムアウトを追加\n  ctx, cancel := context.WithTimeout(ctx, 2*time.Second)\n  defer cancel()\n  \n  // リクエストを処理\n  result, err := processRequest(ctx, r.URL.Query())\n  if err != nil {\n    http.Error(w, err.Error(), http.StatusInternalServerError)\n    return\n  }\n  \n  w.Write(result)\n}\n\nfunc processRequest(ctx context.Context, params url.Values) ([]byte, error) {\n  // context がキャンセルされたか確認\n  select {\n  case <-ctx.Done():\n    return nil, ctx.Err()\n  default:\n    // 処理を続行\n  }\n  \n  // データベースからデータを取得\n  data, err := getFromDatabase(ctx, params.Get(\"id\"))\n  if err != nil {\n    return nil, err\n  }\n  \n  // データを処理\n  return processData(ctx, data)\n}"
    },
    {
      "title": "Context in Middleware",
      "code": "// ミドルウェアでの context\nfunc Middleware(next http.Handler) http.Handler {\n  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n    // リクエスト context を強化\n    ctx := r.Context()\n    ctx = context.WithValue(ctx, \"startTime\", time.Now())\n    \n    // 強化された context で次のハンドラを呼び出す\n    next.ServeHTTP(w, r.WithContext(ctx))\n  })\n}"
    },
    {
      "title": "Testing with Timeout Context",
      "code": "// context を使用したテスト\nfunc TestWithTimeoutContext(t *testing.T) {\n  // タイムアウト付きの context を作成\n  ctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)\n  defer cancel()\n  \n  // context を尊重すべき関数を呼び出す\n  result, err := functionThatUsesContext(ctx)\n  \n  // 結果を確認\n  if !errors.Is(err, context.DeadlineExceeded) {\n    t.Errorf(\"Expected DeadlineExceeded, got %v\", err)\n  }\n}"
    },
    {
      "title": "Testing with Cancellation Context",
      "code": "// キャンセルのテスト\nfunc TestWithCancelContext(t *testing.T) {\n  ctx, cancel := context.WithCancel(context.Background())\n  \n  // 短時間後にキャンセルする goroutine を開始\n  go func() {\n    time.Sleep(10 * time.Millisecond)\n    cancel()\n  }()\n  \n  err := functionThatShouldObserveCancel(ctx)\n  if !errors.Is(err, context.Canceled) {\n    t.Errorf(\"Expected Canceled, got %v\", err)\n  }\n}"
    },
    {
      "title": "Mocking Context for Testing",
      "code": "// テスト用の context モックを作成 (例)\ntype contextMock struct {\n  context.Context\n  doneChannel chan struct{}\n}\n\nfunc newContextMock() (*contextMock, func()) {\n  done := make(chan struct{})\n  mock := &contextMock{\n    Context:     context.Background(),\n    doneChannel: done,\n  }\n  cancel := func() { close(done) }\n  return mock, cancel\n}\n\nfunc (c *contextMock) Done() <-chan struct{} {\n  return c.doneChannel\n}\n\nfunc (c *contextMock) Err() error {\n  select {\n  case <-c.doneChannel:\n    return context.Canceled\n  default:\n    return nil\n  }\n}\n\n// テストでの使用\nfunc TestWithMockContext(t *testing.T) {\n  mockCtx, cancelMock := newContextMock()\n  defer cancelMock()\n\n  go func() {\n    time.Sleep(50 * time.Millisecond)\n    cancelMock()\n  }()\n\n  err := functionThatUsesContext(mockCtx)\n  if !errors.Is(err, context.Canceled) {\n    t.Errorf(\"Expected Canceled with mock, got %v\", err)\n  }\n}"
    }
  ]
}
