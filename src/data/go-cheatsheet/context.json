{
  "title": "Context",
  "codeExamples": [
    {
      "title": "Context Basics",
      "code": "// Context はデッドライン、キャンセルシグナル、リクエストスコープの値を\n// API 境界を越えて、プロセス間で運ぶ\nimport \"context\"\n\n// Context の作成\n// Background - ルート context、キャンセルされない、値なし、デッドラインなし\nctx := context.Background()\n\n// TODO - Background に似ているが、特定の context を\n// 使用すべきだがまだ利用できないことを示す\nctx := context.TODO()\n\n// 最初のパラメータとして context を渡すのは慣例\nfunc DoSomething(ctx context.Context, arg Arg) error {\n  // ... context を使用 ...\n}\n\n// 常に context を渡す\nctx := context.Background()\nDoSomething(ctx, arg)\n\n// context を取る関数を連鎖させる\nfunc DoSomethingMore(ctx context.Context, arg Arg) (Result, error) {\n  // context を取る別の関数を呼び出す\n  err := DoSomething(ctx, arg)\n  if err != nil {\n    return Result{}, err\n  }\n  // context でさらに処理を行う\n  return Result{}, nil\n}"
    },
    {
      "title": "Cancellation",
      "code": "// context によるキャンセル\n\n// キャンセル可能な context を作成\nctx, cancel := context.WithCancel(context.Background())\n\n// リソースを解放するために常に cancel を呼び出す、通常は defer を使用\ndefer cancel()\n\n// キャンセル可能な goroutine を開始\ngo func() {\n  for {\n    select {\n    case <-ctx.Done():\n      // Context がキャンセルされた、処理を停止\n      fmt.Println(\"Stopped due to cancellation\")\n      return\n    default:\n      // 何らかの処理を行う\n      time.Sleep(100 * time.Millisecond)\n    }\n  }\n}()\n\n// 後でキャンセルをトリガー\ncancel()\n\n// context がキャンセルされたか確認\nif ctx.Err() == context.Canceled {\n  fmt.Println(\"Context was canceled\")\n}\n\n// ワーカーでの典型的な使用法\nfunc worker(ctx context.Context, tasks <-chan Task) {\n  for {\n    select {\n    case task, ok := <-tasks:\n      if !ok {\n// チャネルが閉じられた\n        return\n      }\n      process(ctx, task)\n    case <-ctx.Done():\n      fmt.Println(\"Worker stopping:\", ctx.Err())\n      return\n    }\n  }\n}"
    },
    {
      "title": "Timeouts and Deadlines",
      "code": "// context によるタイムアウトとデッドライン\n\n// タイムアウト付き Context - 指定時間後に自動的にキャンセルされる\nctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)\n// タイムアウト前に完了した場合でも、リソースを早期に解放するために cancel を呼び出す\ndefer cancel()\n\n// デッドライン付き Context - 特定の時間にキャンセルされる\ndeadline := time.Now().Add(30 * time.Second)\nctx, cancel := context.WithDeadline(context.Background(), deadline)\ndefer cancel()\n\n// タイムアウトまたはデッドライン超過の確認\nif ctx.Err() == context.DeadlineExceeded {\n  fmt.Println(\"Operation timed out or deadline exceeded\")\n}\n\n// HTTP クライアントでの使用\nctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)\ndefer cancel()\n\n//example.com\", nil)\nreq, err := http.NewRequestWithContext(ctx, \"GET\", \"https:\nif err != nil {\n  return err\n}\n\nresp, err := http.DefaultClient.Do(req)\nif err != nil {\n  // リクエストに時間がかかりすぎた場合、context.DeadlineExceeded になる可能性がある\n  return err\n}\ndefer resp.Body.Close()\n\n// データベース操作での使用\nctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)\ndefer cancel()\n\nrows, err := db.QueryContext(ctx, \"SELECT * FROM users\")\nif err != nil {\n  return err\n}\ndefer rows.Close()"
    },
    {
      "title": "Context Values",
      "code": "// Context 値 - リクエストスコープのキーバリューペア\n\n// context に値を追加 (新しい context を作成)\nctx = context.WithValue(ctx, \"userID\", \"12345\")\nctx = context.WithValue(ctx, \"authToken\", \"token-123\")\n\n// 値の取得\nuserID, ok := ctx.Value(\"userID\").(string)\nif !ok {\n  fmt.Println(\"UserID not found or not a string\")\n}\n\n// ベストプラクティス: キーとしてカスタム型を使用する\n// パッケージ間でのキー衝突を避けるため\ntype contextKey string\n\nconst (\n  userIDKey   contextKey = \"userID\"\n  authTokenKey contextKey = \"authToken\"\n)\n\nctx = context.WithValue(ctx, userIDKey, \"12345\")\nuserID, ok := ctx.Value(userIDKey).(string)\n\n// より良い名前空間分離のためにキーとして構造体を使用する\ntype UserContextKey struct{}\ntype RequestContextKey struct{}\n\nctx = context.WithValue(ctx, UserContextKey{}, user)\nctx = context.WithValue(ctx, RequestContextKey{}, request)\n\nuser, ok := ctx.Value(UserContextKey{}).(User)\n\n// 警告: オプションパラメータを渡すために context 値を使用しない\n// 主に API 境界を越えるリクエストスコープデータに使用する"
    },
    {
      "title": "Context Patterns",
      "code": "// 一般的な context パターンとベストプラクティス\n\n// コールスタックを通じて context を伝播させる\nfunc HandleRequest(w http.ResponseWriter, r *http.Request) {\n  // リクエスト context を抽出\n  ctx := r.Context()\n  \n  // タイムアウトを追加\n  ctx, cancel := context.WithTimeout(ctx, 2*time.Second)\n  defer cancel()\n  \n  // リクエストを処理\n  result, err := processRequest(ctx, r.URL.Query())\n  if err != nil {\n    http.Error(w, err.Error(), http.StatusInternalServerError)\n    return\n  }\n  \n  w.Write(result)\n}\n\nfunc processRequest(ctx context.Context, params url.Values) ([]byte, error) {\n  // context がキャンセルされたか確認\n  select {\n  case <-ctx.Done():\n    return nil, ctx.Err()\n  default:\n    // 処理を続行\n  }\n  \n  // データベースからデータを取得\n  data, err := getFromDatabase(ctx, params.Get(\"id\"))\n  if err != nil {\n    return nil, err\n  }\n  \n  // データを処理\n  return processData(ctx, data)\n}\n\n// ミドルウェアでの context\nfunc Middleware(next http.Handler) http.Handler {\n  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n    // リクエスト context を強化\n    ctx := r.Context()\n    ctx = context.WithValue(ctx, \"startTime\", time.Now())\n    \n    // 強化された context で次のハンドラを呼び出す\n    next.ServeHTTP(w, r.WithContext(ctx))\n  })\n}"
    },
    {
      "title": "Testing with Context",
      "code": "// context を使用したテスト\nfunc TestWithContext(t *testing.T) {\n  // タイムアウト付きの context を作成\n  ctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)\n  defer cancel()\n  \n  // context を尊重すべき関数を呼び出す\n  result, err := functionThatUsesContext(ctx)\n  \n  // 結果を確認\n  if err != context.DeadlineExceeded {\n    t.Errorf(\"Expected DeadlineExceeded, got %v\", err)\n  }\n  \n  // キャンセルのテスト\n  ctx, cancel = context.WithCancel(context.Background())\n  \n  // 短時間後にキャンセルする goroutine を開始\n  go func() {\n    time.Sleep(10 * time.Millisecond)\n    cancel()\n  }()\n  \n  err = functionThatShouldObserveCancel(ctx)\n  if err != context.Canceled {\n    t.Errorf(\"Expected Canceled, got %v\", err)\n  }\n}\n\n// テスト用の context モックを作成\ntype contextMock struct {\n  context.Context\n  doneChannel chan struct{}\n}\n\nfunc (c *contextMock) Done() <-chan struct{} {\n  return c.doneChannel\n}\n\nfunc (c *contextMock) Err() error {\n  select {\n  case <-c.doneChannel:\n    return context.Canceled\n  default:\n    return nil\n  }\n}"
    }
  ]
}
