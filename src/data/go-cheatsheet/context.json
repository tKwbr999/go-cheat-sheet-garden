{
  "title": "Context",
  "codeExamples": [
    {
      "title": "Context Basics",
      "code": "// Context carries deadlines, cancellation signals, and request-scoped values\n// across API boundaries and between processes\nimport \"context\"\n\n// Creating a context\n// Background - root context, never canceled, no values, no deadline\nctx := context.Background()\n\n// TODO - like Background, but indicates that a specific context\n// should be used instead but is not available yet\nctx := context.TODO()\n\n// Passing context as the first parameter is a convention\nfunc DoSomething(ctx context.Context, arg Arg) error {\n  // ... use context ...\n}\n\n// Always pass context\nctx := context.Background()\nDoSomething(ctx, arg)\n\n// Chain functions that take context\nfunc DoSomethingMore(ctx context.Context, arg Arg) (Result, error) {\n  // Call another function that takes context\n  err := DoSomething(ctx, arg)\n  if err != nil {\n    return Result{}, err\n  }\n  // Do more work with context\n  return Result{}, nil\n}"
    },
    {
      "title": "Cancellation",
      "code": "// Cancellation with context\n\n// Create a cancellable context\nctx, cancel := context.WithCancel(context.Background())\n\n// Always call cancel to release resources, typically with defer\ndefer cancel()\n\n// Start a goroutine that can be canceled\ngo func() {\n  for {\n    select {\n    case <-ctx.Done():\n      // Context canceled, stop work\n      fmt.Println(\"Stopped due to cancellation\")\n      return\n    default:\n      // Do some work\n      time.Sleep(100 * time.Millisecond)\n    }\n  }\n}()\n\n// Later, trigger cancellation\ncancel()\n\n// Check if context was canceled\nif ctx.Err() == context.Canceled {\n  fmt.Println(\"Context was canceled\")\n}\n\n// Typical usage with a worker\nfunc worker(ctx context.Context, tasks <-chan Task) {\n  for {\n    select {\n    case task, ok := <-tasks:\n      if !ok {\n        return // Channel closed\n      }\n      process(ctx, task)\n    case <-ctx.Done():\n      fmt.Println(\"Worker stopping:\", ctx.Err())\n      return\n    }\n  }\n}"
    },
    {
      "title": "Timeouts and Deadlines",
      "code": "// Timeouts and deadlines with context\n\n// Context with timeout - canceled automatically after duration\nctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)\ndefer cancel() // Still call cancel to release resources early if done before timeout\n\n// Context with deadline - canceled at specific time\ndeadline := time.Now().Add(30 * time.Second)\nctx, cancel := context.WithDeadline(context.Background(), deadline)\ndefer cancel()\n\n// Checking for timeout or deadline exceeded\nif ctx.Err() == context.DeadlineExceeded {\n  fmt.Println(\"Operation timed out or deadline exceeded\")\n}\n\n// Using with HTTP client\nctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)\ndefer cancel()\n\nreq, err := http.NewRequestWithContext(ctx, \"GET\", \"https://example.com\", nil)\nif err != nil {\n  return err\n}\n\nresp, err := http.DefaultClient.Do(req)\nif err != nil {\n  // Could be context.DeadlineExceeded if request took too long\n  return err\n}\ndefer resp.Body.Close()\n\n// Using with database operations\nctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)\ndefer cancel()\n\nrows, err := db.QueryContext(ctx, \"SELECT * FROM users\")\nif err != nil {\n  return err\n}\ndefer rows.Close()"
    },
    {
      "title": "Context Values",
      "code": "// Context values - request-scoped key-value pairs\n\n// Adding a value to context (creates new context)\nctx = context.WithValue(ctx, \"userID\", \"12345\")\nctx = context.WithValue(ctx, \"authToken\", \"token-123\")\n\n// Retrieving a value\nuserID, ok := ctx.Value(\"userID\").(string)\nif !ok {\n  fmt.Println(\"UserID not found or not a string\")\n}\n\n// Best practice: use custom types as keys\n// to avoid key collisions across packages\ntype contextKey string\n\nconst (\n  userIDKey   contextKey = \"userID\"\n  authTokenKey contextKey = \"authToken\"\n)\n\nctx = context.WithValue(ctx, userIDKey, \"12345\")\nuserID, ok := ctx.Value(userIDKey).(string)\n\n// Using structs as keys for better namespace separation\ntype UserContextKey struct{}\ntype RequestContextKey struct{}\n\nctx = context.WithValue(ctx, UserContextKey{}, user)\nctx = context.WithValue(ctx, RequestContextKey{}, request)\n\nuser, ok := ctx.Value(UserContextKey{}).(User)\n\n// Warning: Don't use context values for passing optional parameters\n// Use them primarily for request-scoped data that crosses API boundaries"
    },
    {
      "title": "Context Patterns",
      "code": "// Common context patterns and best practices\n\n// Propagating contexts through the call stack\nfunc HandleRequest(w http.ResponseWriter, r *http.Request) {\n  // Extract request context\n  ctx := r.Context()\n  \n  // Add a timeout\n  ctx, cancel := context.WithTimeout(ctx, 2*time.Second)\n  defer cancel()\n  \n  // Process request\n  result, err := processRequest(ctx, r.URL.Query())\n  if err != nil {\n    http.Error(w, err.Error(), http.StatusInternalServerError)\n    return\n  }\n  \n  w.Write(result)\n}\n\nfunc processRequest(ctx context.Context, params url.Values) ([]byte, error) {\n  // Check if context has been canceled\n  select {\n  case <-ctx.Done():\n    return nil, ctx.Err()\n  default:\n    // Continue processing\n  }\n  \n  // Get data from database\n  data, err := getFromDatabase(ctx, params.Get(\"id\"))\n  if err != nil {\n    return nil, err\n  }\n  \n  // Process the data\n  return processData(ctx, data)\n}\n\n// Context in middleware\nfunc Middleware(next http.Handler) http.Handler {\n  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n    // Enrich request context\n    ctx := r.Context()\n    ctx = context.WithValue(ctx, \"startTime\", time.Now())\n    \n    // Call next handler with enhanced context\n    next.ServeHTTP(w, r.WithContext(ctx))\n  })\n}"
    },
    {
      "title": "Testing with Context",
      "code": "// Testing with context\nfunc TestWithContext(t *testing.T) {\n  // Create a context with a timeout\n  ctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)\n  defer cancel()\n  \n  // Call function that should respect the context\n  result, err := functionThatUsesContext(ctx)\n  \n  // Check results\n  if err != context.DeadlineExceeded {\n    t.Errorf(\"Expected DeadlineExceeded, got %v\", err)\n  }\n  \n  // Testing cancellation\n  ctx, cancel = context.WithCancel(context.Background())\n  \n  // Start a goroutine that cancels after a short time\n  go func() {\n    time.Sleep(10 * time.Millisecond)\n    cancel()\n  }()\n  \n  err = functionThatShouldObserveCancel(ctx)\n  if err != context.Canceled {\n    t.Errorf(\"Expected Canceled, got %v\", err)\n  }\n}\n\n// Creating context mocks for testing\ntype contextMock struct {\n  context.Context\n  doneChannel chan struct{}\n}\n\nfunc (c *contextMock) Done() <-chan struct{} {\n  return c.doneChannel\n}\n\nfunc (c *contextMock) Err() error {\n  select {\n  case <-c.doneChannel:\n    return context.Canceled\n  default:\n    return nil\n  }\n}"
    }
  ]
}