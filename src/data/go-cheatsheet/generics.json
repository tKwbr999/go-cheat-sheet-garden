{
  "title": "Generics (Go 1.18+)",
  "codeExamples": [
    {
      "title": "Type Parameters",
      "code": "// Generics syntax introduced in Go 1.18\n\n// Generic function with type parameter T\nfunc Print[T any](value T) {\n  fmt.Println(value)\n}\n\n// Usage\nPrint(42)         // T is int\nPrint(\"hello\")    // T is string\nPrint([]float64{1.1, 2.2})  // T is []float64\n\n// Multiple type parameters\nfunc Map[T, U any](s []T, f func(T) U) []U {\n  result := make([]U, len(s))\n  for i, v := range s {\n    result[i] = f(v)\n  }\n  return result\n}\n\n// Usage\nnums := []int{1, 2, 3}\nsquares := Map(nums, func(x int) int { return x * x })\nstrings := Map(nums, func(x int) string { return fmt.Sprintf(\"#%d\", x) })"
    },
    {
      "title": "Type Constraints",
      "code": "// Type constraints restrict the types that can be used\n\n// Constraint using interface with type elements\ntype Numeric interface {\n  int | int8 | int16 | int32 | int64 |\n  uint | uint8 | uint16 | uint32 | uint64 |\n  float32 | float64\n}\n\n// Generic function with constraint\nfunc Sum[T Numeric](values []T) T {\n  var sum T\n  for _, v := range values {\n    sum += v\n  }\n  return sum\n}\n\n// Usage\nSum([]int{1, 2, 3})          // Works: int satisfies Numeric\nSum([]float64{1.1, 2.2, 3.3}) // Works: float64 satisfies Numeric\n// Sum([]string{\"a\", \"b\"})    // Compile error: string doesn't satisfy Numeric\n\n// Using predefined constraints from golang.org/x/exp/constraints\nimport \"golang.org/x/exp/constraints\"\n\nfunc Max[T constraints.Ordered](a, b T) T {\n  if a > b {\n    return a\n  }\n  return b\n}\n\n// Usage\nMax(5, 10)      // Works with int\nMax(\"a\", \"b\")    // Works with string (strings are ordered)"
    },
    {
      "title": "Generic Data Structures",
      "code": "// Generic data structures\n\n// Generic stack\ntype Stack[T any] struct {\n  items []T\n}\n\nfunc (s *Stack[T]) Push(item T) {\n  s.items = append(s.items, item)\n}\n\nfunc (s *Stack[T]) Pop() (T, bool) {\n  var zero T\n  if len(s.items) == 0 {\n    return zero, false\n  }\n  \n  n := len(s.items) - 1\n  item := s.items[n]\n  s.items = s.items[:n]\n  return item, true\n}\n\n// Usage\nintStack := Stack[int]{}\nintStack.Push(10)\nintStack.Push(20)\nval, ok := intStack.Pop()  // val=20, ok=true\n\nstrStack := Stack[string]{}\nstrStack.Push(\"hello\")\nval2, ok := strStack.Pop()  // val2=\"hello\", ok=true\n\n// Generic map with type-safe keys and values\ntype SafeMap[K comparable, V any] struct {\n  data map[K]V\n  mu   sync.RWMutex\n}\n\nfunc NewSafeMap[K comparable, V any]() *SafeMap[K, V] {\n  return &SafeMap[K, V]{\n    data: make(map[K]V),\n  }\n}\n\nfunc (m *SafeMap[K, V]) Set(key K, value V) {\n  m.mu.Lock()\n  defer m.mu.Unlock()\n  m.data[key] = value\n}\n\nfunc (m *SafeMap[K, V]) Get(key K) (V, bool) {\n  m.mu.RLock()\n  defer m.mu.RUnlock()\n  val, ok := m.data[key]\n  return val, ok\n}"
    },
    {
      "title": "Type Parameter Methods",
      "code": "// Type parameter methods and type inference\n\n// Type constraints with methods\ntype Stringer interface {\n  String() string\n}\n\nfunc Join[T Stringer](values []T, sep string) string {\n  result := \"\"\n  for i, v := range values {\n    if i > 0 {\n      result += sep\n    }\n    result += v.String()\n  }\n  return result\n}\n\n// Implement Stringer\ntype Person struct {\n  Name string\n  Age  int\n}\n\nfunc (p Person) String() string {\n  return fmt.Sprintf(\"%s (%d)\", p.Name, p.Age)\n}\n\n// Usage\npeople := []Person{\n  {\"Alice\", 30},\n  {\"Bob\", 25},\n}\nfmt.Println(Join(people, \", \"))  // \"Alice (30), Bob (25)\"\n\n// Type constraints with methods and type sets\ntype Comparable[T any] interface {\n  CompareTo(T) int\n}\n\nfunc Sort[T Comparable[T]](items []T) {\n  for i := range items {\n    for j := i + 1; j < len(items); j++ {\n      if items[i].CompareTo(items[j]) > 0 {\n        items[i], items[j] = items[j], items[i]\n      }\n    }\n  }\n}\n\n// Implement Comparable\ntype Version struct {\n  Major, Minor, Patch int\n}\n\nfunc (v Version) CompareTo(other Version) int {\n  if v.Major != other.Major {\n    return v.Major - other.Major\n  }\n  if v.Minor != other.Minor {\n    return v.Minor - other.Minor\n  }\n  return v.Patch - other.Patch\n}"
    },
    {
      "title": "Generic Patterns",
      "code": "// Common generic patterns and idioms\n\n// 1. Generic Optional/Maybe type\ntype Optional[T any] struct {\n  value T\n  valid bool\n}\n\nfunc Some[T any](value T) Optional[T] {\n  return Optional[T]{value: value, valid: true}\n}\n\nfunc None[T any]() Optional[T] {\n  return Optional[T]{valid: false}\n}\n\nfunc (o Optional[T]) IsPresent() bool {\n  return o.valid\n}\n\nfunc (o Optional[T]) Get() (T, bool) {\n  return o.value, o.valid\n}\n\n// 2. Generic Result type for error handling\ntype Result[T any] struct {\n  value T\n  err   error\n}\n\nfunc Success[T any](value T) Result[T] {\n  return Result[T]{value: value}\n}\n\nfunc Failure[T any](err error) Result[T] {\n  return Result[T]{err: err}\n}\n\nfunc (r Result[T]) IsOk() bool {\n  return r.err == nil\n}\n\nfunc (r Result[T]) Value() T {\n  return r.value\n}\n\nfunc (r Result[T]) Error() error {\n  return r.err\n}\n\n// 3. Generic Min/Max functions\nfunc Min[T constraints.Ordered](a, b T) T {\n  if a < b {\n    return a\n  }\n  return b\n}\n\nfunc Max[T constraints.Ordered](a, b T) T {\n  if a > b {\n    return a\n  }\n  return b\n}"
    }
  ]
}