{
  "title": "I/O Operations",
  "codeExamples": [
    {
      "title": "File I/O",
      "code": "// 基本的なファイル操作\nimport (\n  \"io\"\n  \"os\"\n)\n\n// ファイル全体を読み込む\ndata, err := os.ReadFile(\"filename.txt\")\nif err != nil {\n  // エラー処理\n}\nfmt.Println(string(data))\n\n// ファイルへの書き込み\nerr = os.WriteFile(\"output.txt\", []byte(\"Hello, world!\"), 0644)\nif err != nil {\n  // エラー処理\n}\n\n// より詳細な制御でファイルを開く\nfile, err := os.Open(\"filename.txt\")  // 読み取り専用\nif err != nil {\n  // エラー処理\n}\ndefer file.Close()\n\n// 書き込み用に開く (作成または切り捨て)\nfile, err = os.Create(\"output.txt\")\nif err != nil {\n  // エラー処理\n}\ndefer file.Close()\n\n// 特定のフラグとパーミッションで開く\nfile, err = os.OpenFile(\"file.txt\", os.O_RDWR|os.O_CREATE, 0644)\nif err != nil {\n  // エラー処理\n}\ndefer file.Close()\n\n// バッファを使用した読み込み\nbuf := make([]byte, 1024)\nn, err := file.Read(buf)\nif err != nil && err != io.EOF {\n  // エラー処理\n}\nbuf = buf[:n]  // バッファを実際に読み取られたバイト数にリサイズ\n\n// ファイルへの書き込み\nn, err = file.Write([]byte(\"Hello, Go!\"))\nif err != nil {\n  // エラー処理\n}\n\n// ファイル内でのシーク\nnewPos, err := file.Seek(10, io.SeekStart)  // 開始位置からシーク\nif err != nil {\n  // エラー処理\n}"
    },
    {
      "title": "io/ioutil and io Packages",
      "code": "// io パッケージの操作\nimport (\n  \"io\"\n  \"io/ioutil\"  // Go 1.16+ で非推奨、関数は io/os に移動\n)\n\n// reader から writer へデータをコピー\nn, err := io.Copy(dst, src)\nif err != nil {\n  // エラー処理\n}\n\n// バッファサイズ制限付きでコピー\nn, err = io.CopyN(dst, src, 1024)\n\n// 一時ディレクトリを作成 (Go 1.15 以前)\ntempDir, err := ioutil.TempDir(\"\", \"prefix-\")\nif err != nil {\n  // エラー処理\n}\n\n// 一時ディレクトリを作成 (Go 1.16+)\ntempDir, err = os.MkdirTemp(\"\", \"prefix-\")\nif err != nil {\n  // エラー処理\n}\n\n// 一時ファイルを作成 (Go 1.15 以前)\ntempFile, err := ioutil.TempFile(\"\", \"prefix-*.txt\")\nif err != nil {\n  // エラー処理\n}\ndefer tempFile.Close()\n\n// 一時ファイルを作成 (Go 1.16+)\ntempFile, err = os.CreateTemp(\"\", \"prefix-*.txt\")\nif err != nil {\n  // エラー処理\n}\ndefer tempFile.Close()\n\n// reader からすべて読み込む\ndata, err := io.ReadAll(reader)\nif err != nil {\n  // エラー処理\n}\n\n// マルチリーダーを作成 (reader を連結)\nmultiReader := io.MultiReader(reader1, reader2, reader3)\n\n// マルチライターを作成 (複数の writer に同時に書き込む)\nmultiWriter := io.MultiWriter(writer1, writer2, writer3)"
    },
    {
      "title": "Buffered I/O",
      "code": "// パフォーマンスのためのバッファ付き I/O\nimport (\n  \"bufio\"\n  \"os\"\n)\n\n// バッファ付き読み込み\nfile, err := os.Open(\"file.txt\")\nif err != nil {\n  // エラー処理\n}\ndefer file.Close()\n\n// バッファ付きリーダーを作成\nreader := bufio.NewReader(file)\n\n// 1バイト読み込み\nb, err := reader.ReadByte()\nif err != nil {\n  // エラー処理\n}\n\n// 区切り文字まで読み込み\nline, err := reader.ReadString('\\n')  // 改行まで読み込む\nif err != nil {\n  // エラー処理\n}\n\n// 行ごとの読み込みのための Scanner\nscanner := bufio.NewScanner(file)\nfor scanner.Scan() {\n  line := scanner.Text()\n  // 行を処理\n}\nif err := scanner.Err(); err != nil {\n  // エラー処理\n}\n\n// カスタム分割関数\nscanner.Split(bufio.ScanWords)  // 行ではなく単語でスキャン\n\n// バッファ付き書き込み\nfile, err = os.Create(\"output.txt\")\nif err != nil {\n  // エラー処理\n}\ndefer file.Close()\n\nwriter := bufio.NewWriter(file)\n\n// 文字列を書き込む\nn, err := writer.WriteString(\"Hello, world!\\n\")\nif err != nil {\n  // エラー処理\n}\n\n// バイトを書き込む\nerr = writer.WriteByte('X')\nif err != nil {\n  // エラー処理\n}\n\n// バッファを基底の writer にフラッシュ\nerr = writer.Flush()\nif err != nil {\n  // エラー処理\n}"
    },
    {
      "title": "Streaming I/O",
      "code": "// reader と writer を使用した I/O ストリームの操作\nimport (\n  \"bytes\"\n  \"encoding/csv\"\n  \"encoding/json\"\n  \"io\"\n  \"strings\"\n)\n\n// Reader としての文字列\nstrReader := strings.NewReader(\"Hello, World!\")\n\n// Buffer としてのバイト (Reader および Writer)\nbuffer := bytes.NewBuffer([]byte(\"Hello\"))\nbuffer.WriteString(\", Go!\")  // バッファに追加\ndata := buffer.Bytes()        // バイトを取得\n\n// reader の制限\nlimitReader := io.LimitReader(reader, 1024)  // 最大 1024 バイト読み込む\n\n// reader の連鎖 (例: 解凍してデコード)\ndecompressed := gzip.NewReader(file)\ndefer decompressed.Close()\ndecoder := json.NewDecoder(decompressed)\n\nvar data struct {\n  Name string `json:\"name\"`\n  Age  int    `json:\"age\"`\n}\n\nerr = decoder.Decode(&data)\nif err != nil {\n  // エラー処理\n}\n\n// writer の連鎖 (例: エンコードして圧縮)\ncompressedFile, err := os.Create(\"data.gz\")\nif err != nil {\n  // エラー処理\n}\ndefer compressedFile.Close()\n\ncompressed := gzip.NewWriter(compressedFile)\ndefer compressed.Close()\n\nencoder := json.NewEncoder(compressed)\nerr = encoder.Encode(data)\nif err != nil {\n  // エラー処理\n}\n\n// CSV reader の例\ncsvReader := csv.NewReader(file)\nrecords, err := csvReader.ReadAll()\nif err != nil {\n  // エラー処理\n}\n\n// CSV writer の例\ncsvWriter := csv.NewWriter(file)\nerr = csvWriter.WriteAll(records)\nif err != nil {\n  // エラー処理\n}\ncsvWriter.Flush()"
    },
    {
      "title": "Directory Operations",
      "code": "// ディレクトリの操作\nimport (\n  \"os\"\n  \"path/filepath\"\n)\n\n// ディレクトリを作成\nerr := os.Mkdir(\"new-dir\", 0755)\nif err != nil {\n  // エラー処理\n}\n\n// ネストされたディレクトリを作成\nerr = os.MkdirAll(\"path/to/nested/dir\", 0755)\nif err != nil {\n  // エラー処理\n}\n\n// 現在のディレクトリを取得\ncurrentDir, err := os.Getwd()\nif err != nil {\n  // エラー処理\n}\n\n// ディレクトリを変更\nerr = os.Chdir(\"new-dir\")\nif err != nil {\n  // エラー処理\n}\n\n// ディレクトリエントリを読み込む (Go <1.16)\ndir, err := os.Open(\"dir\")\nif err != nil {\n  // エラー処理\n}\ndefer dir.Close()\n\nentries, err := dir.Readdir(-1)  // すべてのエントリを読み込む\nif err != nil {\n  // エラー処理\n}\n\nfor _, entry := range entries {\n  fmt.Println(entry.Name(), entry.IsDir())\n}\n\n// ディレクトリエントリを読み込む (Go 1.16+)\nentries, err = os.ReadDir(\"dir\")\nif err != nil {\n  // エラー処理\n}\n\nfor _, entry := range entries {\n  info, err := entry.Info()\n  if err != nil {\n    // エラー処理\n  }\n  fmt.Println(entry.Name(), entry.IsDir(), info.Size())\n}\n\n// ディレクトリツリーを走査\nerr = filepath.Walk(\"root-dir\", func(path string, info os.FileInfo, err error) error {\n  if err != nil {\n    return err  // パスへのアクセスエラー\n  }\n  fmt.Println(path, info.Size())\n  return nil\n})\nif err != nil {\n  // エラー処理\n}\n\n// WalkDir はより効率的 (Go 1.16+)\nerr = filepath.WalkDir(\"root-dir\", func(path string, d fs.DirEntry, err error) error {\n  if err != nil {\n    return err\n  }\n  fmt.Println(path, d.IsDir())\n  return nil\n})"
    }
  ]
}