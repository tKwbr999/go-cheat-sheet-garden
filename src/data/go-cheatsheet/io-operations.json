{
  "title": "I/O Operations",
  "codeExamples": [
    {
      "title": "File I/O",
      "code": "// Basic file operations\nimport (\n  \"io\"\n  \"os\"\n)\n\n// Reading an entire file\ndata, err := os.ReadFile(\"filename.txt\")\nif err != nil {\n  // Handle error\n}\nfmt.Println(string(data))\n\n// Writing to a file\nerr = os.WriteFile(\"output.txt\", []byte(\"Hello, world!\"), 0644)\nif err != nil {\n  // Handle error\n}\n\n// Opening a file with more control\nfile, err := os.Open(\"filename.txt\")  // Read-only\nif err != nil {\n  // Handle error\n}\ndefer file.Close()\n\n// Open for writing (creates or truncates)\nfile, err = os.Create(\"output.txt\")\nif err != nil {\n  // Handle error\n}\ndefer file.Close()\n\n// Open with specific flags and permissions\nfile, err = os.OpenFile(\"file.txt\", os.O_RDWR|os.O_CREATE, 0644)\nif err != nil {\n  // Handle error\n}\ndefer file.Close()\n\n// Reading with a buffer\nbuf := make([]byte, 1024)\nn, err := file.Read(buf)\nif err != nil && err != io.EOF {\n  // Handle error\n}\nbuf = buf[:n]  // Resize buffer to actual bytes read\n\n// Writing to file\nn, err = file.Write([]byte(\"Hello, Go!\"))\nif err != nil {\n  // Handle error\n}\n\n// Seeking in file\nnewPos, err := file.Seek(10, io.SeekStart)  // Seek from start\nif err != nil {\n  // Handle error\n}"
    },
    {
      "title": "io/ioutil and io Packages",
      "code": "// Working with io packages\nimport (\n  \"io\"\n  \"io/ioutil\"  // Deprecated in Go 1.16+, functions moved to io/os\n)\n\n// Copy data from reader to writer\nn, err := io.Copy(dst, src)\nif err != nil {\n  // Handle error\n}\n\n// Copy with buffer size limit\nn, err = io.CopyN(dst, src, 1024)\n\n// Create temporary dir (Go 1.15 and earlier)\ntempDir, err := ioutil.TempDir(\"\", \"prefix-\")\nif err != nil {\n  // Handle error\n}\n\n// Create temporary dir (Go 1.16+)\ntempDir, err = os.MkdirTemp(\"\", \"prefix-\")\nif err != nil {\n  // Handle error\n}\n\n// Create temporary file (Go 1.15 and earlier)\ntempFile, err := ioutil.TempFile(\"\", \"prefix-*.txt\")\nif err != nil {\n  // Handle error\n}\ndefer tempFile.Close()\n\n// Create temporary file (Go 1.16+)\ntempFile, err = os.CreateTemp(\"\", \"prefix-*.txt\")\nif err != nil {\n  // Handle error\n}\ndefer tempFile.Close()\n\n// Read all from a reader\ndata, err := io.ReadAll(reader)\nif err != nil {\n  // Handle error\n}\n\n// Create a multi-reader (concatenate readers)\nmultiReader := io.MultiReader(reader1, reader2, reader3)\n\n// Create a multi-writer (write to multiple writers at once)\nmultiWriter := io.MultiWriter(writer1, writer2, writer3)"
    },
    {
      "title": "Buffered I/O",
      "code": "// Buffered I/O for performance\nimport (\n  \"bufio\"\n  \"os\"\n)\n\n// Buffered reading\nfile, err := os.Open(\"file.txt\")\nif err != nil {\n  // Handle error\n}\ndefer file.Close()\n\n// Create a buffered reader\nreader := bufio.NewReader(file)\n\n// Reading a single byte\nb, err := reader.ReadByte()\nif err != nil {\n  // Handle error\n}\n\n// Reading until delimiter\nline, err := reader.ReadString('\\n')  // Read until newline\nif err != nil {\n  // Handle error\n}\n\n// Scanner for line-by-line reading\nscanner := bufio.NewScanner(file)\nfor scanner.Scan() {\n  line := scanner.Text()\n  // Process line\n}\nif err := scanner.Err(); err != nil {\n  // Handle error\n}\n\n// Custom split function\nscanner.Split(bufio.ScanWords)  // Scan by words instead of lines\n\n// Buffered writing\nfile, err = os.Create(\"output.txt\")\nif err != nil {\n  // Handle error\n}\ndefer file.Close()\n\nwriter := bufio.NewWriter(file)\n\n// Write string\nn, err := writer.WriteString(\"Hello, world!\\n\")\nif err != nil {\n  // Handle error\n}\n\n// Write byte\nerr = writer.WriteByte('X')\nif err != nil {\n  // Handle error\n}\n\n// Flush buffer to underlying writer\nerr = writer.Flush()\nif err != nil {\n  // Handle error\n}"
    },
    {
      "title": "Streaming I/O",
      "code": "// Working with I/O streams using readers and writers\nimport (\n  \"bytes\"\n  \"encoding/csv\"\n  \"encoding/json\"\n  \"io\"\n  \"strings\"\n)\n\n// String as Reader\nstrReader := strings.NewReader(\"Hello, World!\")\n\n// Bytes as Buffer (Reader and Writer)\nbuffer := bytes.NewBuffer([]byte(\"Hello\"))\nbuffer.WriteString(\", Go!\")  // Append to buffer\ndata := buffer.Bytes()        // Get bytes\n\n// Limiting a reader\nlimitReader := io.LimitReader(reader, 1024)  // Read at most 1024 bytes\n\n// Chain of readers (example: decompress and decode)\ndecompressed := gzip.NewReader(file)\ndefer decompressed.Close()\ndecoder := json.NewDecoder(decompressed)\n\nvar data struct {\n  Name string `json:\"name\"`\n  Age  int    `json:\"age\"`\n}\n\nerr = decoder.Decode(&data)\nif err != nil {\n  // Handle error\n}\n\n// Chain of writers (example: encode and compress)\ncompressedFile, err := os.Create(\"data.gz\")\nif err != nil {\n  // Handle error\n}\ndefer compressedFile.Close()\n\ncompressed := gzip.NewWriter(compressedFile)\ndefer compressed.Close()\n\nencoder := json.NewEncoder(compressed)\nerr = encoder.Encode(data)\nif err != nil {\n  // Handle error\n}\n\n// CSV reader example\ncsvReader := csv.NewReader(file)\nrecords, err := csvReader.ReadAll()\nif err != nil {\n  // Handle error\n}\n\n// CSV writer example\ncsvWriter := csv.NewWriter(file)\nerr = csvWriter.WriteAll(records)\nif err != nil {\n  // Handle error\n}\ncsvWriter.Flush()"
    },
    {
      "title": "Directory Operations",
      "code": "// Working with directories\nimport (\n  \"os\"\n  \"path/filepath\"\n)\n\n// Create directory\nerr := os.Mkdir(\"new-dir\", 0755)\nif err != nil {\n  // Handle error\n}\n\n// Create nested directories\nerr = os.MkdirAll(\"path/to/nested/dir\", 0755)\nif err != nil {\n  // Handle error\n}\n\n// Get current directory\ncurrentDir, err := os.Getwd()\nif err != nil {\n  // Handle error\n}\n\n// Change directory\nerr = os.Chdir(\"new-dir\")\nif err != nil {\n  // Handle error\n}\n\n// Read directory entries (Go <1.16)\ndir, err := os.Open(\"dir\")\nif err != nil {\n  // Handle error\n}\ndefer dir.Close()\n\nentries, err := dir.Readdir(-1)  // Read all entries\nif err != nil {\n  // Handle error\n}\n\nfor _, entry := range entries {\n  fmt.Println(entry.Name(), entry.IsDir())\n}\n\n// Read directory entries (Go 1.16+)\nentries, err = os.ReadDir(\"dir\")\nif err != nil {\n  // Handle error\n}\n\nfor _, entry := range entries {\n  info, err := entry.Info()\n  if err != nil {\n    // Handle error\n  }\n  fmt.Println(entry.Name(), entry.IsDir(), info.Size())\n}\n\n// Walk directory tree\nerr = filepath.Walk(\"root-dir\", func(path string, info os.FileInfo, err error) error {\n  if err != nil {\n    return err  // Error accessing path\n  }\n  fmt.Println(path, info.Size())\n  return nil\n})\nif err != nil {\n  // Handle error\n}\n\n// WalkDir is more efficient (Go 1.16+)\nerr = filepath.WalkDir(\"root-dir\", func(path string, d fs.DirEntry, err error) error {\n  if err != nil {\n    return err\n  }\n  fmt.Println(path, d.IsDir())\n  return nil\n})"
    }
  ]
}