{
  "title": "References",
  "codeExamples": [
    {
      "title": "Go Documentation",
      "code": "// Official Go Documentation\n// https://golang.org/doc/\n\n// Go Standard Library\n// https://golang.org/pkg/\n\n// Go Tour - interactive tutorial\n// https://tour.golang.org/\n\n// Effective Go - best practices\n// https://golang.org/doc/effective_go.html\n\n// Go by Example - practical examples\n// https://gobyexample.com/\n\n// Go Language Specification\n// https://golang.org/ref/spec\n\n// Go Blog\n// https://go.dev/blog/\n\n// Package Documentation\n// https://pkg.go.dev/\n\n// Go Playground - test code online\n// https://play.golang.org/"
    },
    {
      "title": "Tools",
      "code": "// Go command line tools\ngo build      // Compile packages\ngo run        // Compile and run\ngo test       // Test packages\ngo get        // Download and install packages\ngo install    // Compile and install packages\ngo fmt        // Format source code\ngo vet        // Report likely mistakes\ngo mod        // Module maintenance\ngo mod init   // Initialize a new module\ngo mod tidy   // Add missing and remove unused modules\ngo mod vendor // Create vendor directory\ngo list       // List packages or modules\ngo work       // Workspace maintenance (Go 1.18+)\ngo generate   // Generate Go files by processing source\ngo doc        // Show documentation for package or symbol\ngo version    // Print Go version\n\n// Environmental variables\nGO111MODULE    // Controls module support\nGOPATH         // Workspace directory (when not using modules)\nGOROOT         // Go installation directory\nGOBIN          // Go binary installation directory\nGOOS/GOARCH    // Target OS/architecture for cross-compilation\nGOFLAGS        // Default flags for 'go' command"
    },
    {
      "title": "Code Style",
      "code": "// Go Code Style Guide\n\n// Variables - use short, descriptive names\nvar (  // Group declarations for readability\n  userCount int\n  maxRetries = 3\n  errNotFound = errors.New(\"not found\") // Error vars: err + description\n)\n\n// Constants - use camelCase or ALL_CAPS for constants\nconst (\n  maxConnections = 100\n  DEFAULT_TIMEOUT = 30 * time.Second // ALL_CAPS for very important constants\n)\n\n// Functions - use MixedCaps, not underscores\nfunc ConnectToDatabase(config *DatabaseConfig) (*Connection, error) {\n  // ...\n}\n\n// Interfaces - single method interfaces end in -er\ntype Reader interface {\n  Read(p []byte) (n int, err error)\n}\n\n// Error handling - check errors immediately\nresult, err := DoSomething()\nif err != nil {\n  return nil, fmt.Errorf(\"failed to do something: %w\", err)\n}\n\n// Comments - start with the name of the thing being documented\n// User represents a user in the system.\ntype User struct {\n  // ...\n}\n\n// GetByID retrieves a user by their ID.\nfunc GetByID(id string) (*User, error) {\n  // ...\n}\n\n// Indentation - use tabs, not spaces\nfunc example() {\n\tif condition {\n\t\tfmt.Println(\"indented with tabs\")\n\t}\n}"
    },
    {
      "title": "Best Practices",
      "code": "// Go best practices\n\n// 1. Handle errors explicitly\nif err := doSomething(); err != nil {\n  // Handle error, don't ignore it\n  log.Printf(\"error: %v\", err)\n  return err\n}\n\n// 2. Prefer composition over inheritance\ntype Logger struct {\n  // ...\n}\n\ntype Server struct {\n  Logger  // Embed instead of extending\n  // ...\n}\n\n// 3. Use interfaces for dependency injection\ntype UserStore interface {\n  GetUser(id string) (*User, error)\n}\n\nfunc NewUserHandler(store UserStore) *UserHandler {\n  return &UserHandler{store: store}\n}\n\n// 4. Use context for cancellation and deadlines\nctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\ndefer cancel()\n\nresult, err := service.DoWork(ctx)\n\n// 5. Avoid package-level state when possible\n// Bad:\nvar db *sql.DB\n\n// Better:\ntype Service struct {\n  db *sql.DB\n}\n\n// 6. Use defer for cleanup\nf, err := os.Open(filename)\nif err != nil {\n  return err\n}\ndefer f.Close()  // Always closes, even on error paths\n\n// 7. Separate interface definition from implementation\n// Define interfaces at the user level, not at the implementation\n\n// 8. Use gofmt, goimports, golint, go vet\n// Format code consistently and catch common errors"
    },
    {
      "title": "Testing",
      "code": "// Go testing patterns\npackage mypackage_test  // Separate test package\n\nimport (\n  \"testing\"\n\n  \"example.com/mypackage\"\n)\n\n// Basic test function\nfunc TestAdd(t *testing.T) {\n  got := mypackage.Add(2, 3)\n  want := 5\n  if got != want {\n    t.Errorf(\"Add(2, 3) = %d; want %d\", got, want)\n  }\n}\n\n// Table-driven test\nfunc TestAdd_Table(t *testing.T) {\n  tests := []struct {\n    name string\n    a, b int\n    want int\n  }{\n    {\"positive\", 2, 3, 5},\n    {\"negative\", -1, -2, -3},\n    {\"mixed\", -1, 5, 4},\n  }\n\n  for _, tt := range tests {\n    t.Run(tt.name, func(t *testing.T) {\n      got := mypackage.Add(tt.a, tt.b)\n      if got != tt.want {\n        t.Errorf(\"Add(%d, %d) = %d; want %d\", tt.a, tt.b, got, tt.want)\n      }\n    })\n  }\n}\n\n// Benchmark\nfunc BenchmarkAdd(b *testing.B) {\n  for i := 0; i < b.N; i++ {\n    mypackage.Add(2, 3)\n  }\n}\n\n// Run tests with:\n// $ go test\n// $ go test -v\n// $ go test -run=TestAdd\n// $ go test -bench=.\n// $ go test -cover\n\n// Testable examples (documentation and tests)\nfunc ExampleAdd() {\n  sum := mypackage.Add(1, 2)\n  fmt.Println(sum)\n  // Output: 3\n}\n\n// Mocking\ntype mockUserStore struct {\n  users map[string]*User\n}\n\nfunc (m *mockUserStore) GetUser(id string) (*User, error) {\n  user, ok := m.users[id]\n  if !ok {\n    return nil, errors.New(\"user not found\")\n  }\n  return user, nil\n}\n\n// Test with mocks\nfunc TestHandler_GetUser(t *testing.T) {\n  // Setup mock\n  store := &mockUserStore{\n    users: map[string]*User{\n      \"123\": {ID: \"123\", Name: \"Test User\"},\n    },\n  }\n  \n  // Inject mock\n  handler := NewUserHandler(store)\n  \n  // Test\n  user, err := handler.GetUser(\"123\")\n  if err != nil {\n    t.Fatalf(\"expected no error, got %v\", err)\n  }\n  if user.Name != \"Test User\" {\n    t.Errorf(\"expected name 'Test User', got '%s'\", user.Name)\n  }\n}"
    },
    {
      "title": "Common Patterns",
      "code": "// Functional Options Pattern\ntype ServerOption func(*Server)\n\nfunc WithTimeout(timeout time.Duration) ServerOption {\n  return func(s *Server) {\n    s.timeout = timeout\n  }\n}\n\nfunc WithTLS(cert, key string) ServerOption {\n  return func(s *Server) {\n    s.useTLS = true\n    s.cert = cert\n    s.key = key\n  }\n}\n\nfunc NewServer(addr string, opts ...ServerOption) *Server {\n  // Default config\n  server := &Server{\n    addr:    addr,\n    timeout: 30 * time.Second,\n  }\n  \n  // Apply options\n  for _, opt := range opts {\n    opt(server)\n  }\n  \n  return server\n}\n\n// Usage\nserver := NewServer(\":8080\",\n  WithTimeout(10*time.Second),\n  WithTLS(\"cert.pem\", \"key.pem\"),\n)\n\n// Worker Pool Pattern\nfunc worker(id int, jobs <-chan Job, results chan<- Result) {\n  for job := range jobs {\n    results <- process(job)\n  }\n}\n\n// Create pools\njobs := make(chan Job, 100)\nresults := make(chan Result, 100)\n\n// Start workers\nfor w := 1; w <= 3; w++ {\n  go worker(w, jobs, results)\n}\n\n// Send jobs, collect results\nfor _, j := range allJobs {\n  jobs <- j\n}\nclose(jobs)\n\n// Collect results\nfor range allJobs {\n  result := <-results\n  // Use result\n}"
    }
  ]
}