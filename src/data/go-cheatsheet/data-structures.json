{
  "title": "Data structures",
  "codeExamples": [
    {
      "title": "Arrays",
      "code": "// 配列宣言 (固定サイズ)\n// [0 0 0 0 0]\nvar a [5]int\n\n// 配列の初期化\n// [1 2 3]\nb := [3]int{1, 2, 3}\n\n// 暗黙的なサイズの配列\n// [4]int - コンパイラが要素数を数える\nc := [...]int{4, 5, 6, 7}\n\n// 要素へのアクセス\n// 0\nfirst := a[0]\n// 最初の要素を 10 に設定\na[0] = 10\n\n// 多次元配列\nmatrix := [2][3]int{\n  {1, 2, 3},\n  {4, 5, 6},\n}\n// 6\nvalue := matrix[1][2]\n\n// 配列は値 (コピー)\noriginal := [3]int{1, 2, 3}\n// 完全なコピーを作成\ncopy := original\n// 元の配列には影響しない\ncopy[0] = 99\n\n// 配列のサイズは型の一部 - これらは異なる型\nvar a1 [5]int\nvar a2 [10]int\n// a1 = a2  // コンパイルエラー - 異なる型"
    },
    {
      "title": "Slices",
      "code": "// スライス宣言 (配列の動的サイズのビュー)\n// nil スライス (長さと容量は 0)\nvar s []int\n\n// スライスを作成\n// len=5, cap=5, ゼロ値で初期化\ns = make([]int, 5)\n// len=3, cap=10, ゼロ値で初期化\ns = make([]int, 3, 10)\n\n// スライスリテラル\n// len=3, cap=3\ns = []int{1, 2, 3}\n\n// 既存の配列またはスライスからのスライス\na := [5]int{1, 2, 3, 4, 5}\n// s == []int{2, 3, 4}, len=3, cap=4\ns := a[1:4]\n\n// スライスのインデックス\nfull := []int{1, 2, 3, 4, 5}\n// [2 3 4]   - インデックス 1 から 3 まで (4 は含まない)\ns1 := full[1:4]\n// [1 2 3]   - 開始からインデックス 2 まで\ns2 := full[:3]\n// [3 4 5]   - インデックス 2 から最後まで\ns3 := full[2:]\n// [1 2 3 4 5] - スライス全体\ns4 := full[:]\n\n// スライスに追加 (必要に応じて新しい基底配列を作成することがある)\n// 要素 4 と 5 を追加\ns = append(s, 4, 5)\nt := []int{6, 7, 8}\n// 別のスライスを追加\ns = append(s, t...)\n\n// スライスの長さと容量\n// 要素数\nlen := len(s)\n// 基底配列の容量\ncap := cap(s)\n\n// 一般的なスライス操作\n// コピー\ndst := make([]int, len(src))\n// src から dst へコピー、コピーされた要素数を返す\ncopy(dst, src)\n\n// インデックス i の要素を削除\ns = append(s[:i], s[i+1:]...)\n\n// インデックス i に要素を挿入\ns = append(s[:i], append([]int{x}, s[i:]...)...)\n// より効率的な挿入\n// 末尾にゼロ値を追加\ns = append(s, 0)\n// 要素を右にシフト\ncopy(s[i+1:], s[i:])\n// 新しい要素を配置\ns[i] = x"
    },
    {
      "title": "Maps",
      "code": "// マップ宣言 (キーバリューストア、順序なし)\n// nil マップ (読み取りは可能だが書き込みは不可)\nvar m map[string]int\n\n// マップを作成\nm = make(map[string]int)\n\n// マップリテラル\nm = map[string]int{\n  \"one\": 1,\n  \"two\": 2,\n}\n\n// マップ操作\n// キーバリューペアを追加/更新\nm[\"three\"] = 3\n// 値を取得 (キーが見つからない場合はゼロ値を返す)\nvalue := m[\"one\"]\n// キーバリューペアを削除\ndelete(m, \"two\")\n\n// 存在確認\n// キーが見つからない場合 value=0, exists=false\nvalue, exists := m[\"four\"]\nif exists {\n  // キーが存在する\n}\n\n// マップの反復処理 (ランダムな順序)\nfor key, value := range m {\n  fmt.Println(key, value)\n}\n\n// すべてのキーを取得\nkeys := make([]string, 0, len(m))\nfor k := range m {\n  keys = append(keys, k)\n}\n\n// 一貫した順序のためにキーをソート\nsort.Strings(keys)\nfor _, k := range keys {\n  fmt.Printf(\"%s: %d\\n\", k, m[k])\n}\n\n// マップは参照 (配列のような値ではない)\noriginal := map[string]int{\"one\": 1}\n// 両方が同じマップを参照\ncopy := original\n// 変更は両方の変数を通じて見える\ncopy[\"one\"] = 99"
    },
    {
      "title": "Structs",
      "code": "// 構造体型を定義\ntype Person struct {\n  Name    string\n  Age     int\n  Address *Address\n}\n\ntype Address struct {\n  Street string\n  City   string\n}\n\n// 構造体を作成\n// 名前付きフィールド (推奨)\np1 := Person{Name: \"Alice\", Age: 30}\n// 位置指定フィールド (壊れやすい)\np2 := Person{\"Bob\", 25, nil}\n// ゼロ化された Person を割り当て、*Person を返す\np3 := new(Person)\n\n// フィールドへのアクセス\nname := p1.Name\np1.Age = 31\n\n// ネストされた構造体\np4 := Person{\n  Name: \"Charlie\",\n  Age: 35,\n  Address: &Address{\n    Street: \"123 Main St\",\n    City: \"Anytown\",\n  },\n}\ncity := p4.Address.City\n\n// 無名構造体 (一度きりの使用)\npoint := struct {\n  X, Y int\n}{10, 20}\n\n// 無名フィールド (埋め込み)\ntype Employee struct {\n// すべての Person フィールドを埋め込む\n  Person\n  CompanyName string\n  Salary      float64\n}\n\ne := Employee{}\n// Person から昇格したフィールド\ne.Name = \"Dave\"\n// これでも動作する\ne.Person.Name = \"Dave\"\ne.CompanyName = \"Acme\""
    },
    {
      "title": "Sets",
      "code": "// Go には組み込みのセット型がない\n// 代わりに map[type]bool または map[type]struct{} を使用する\n\n// map[string]bool を使用したセット\nset := make(map[string]bool)\n\n// 要素を追加\nset[\"apple\"] = true\nset[\"banana\"] = true\n\n// メンバーシップを確認\nif set[\"apple\"] {\n  // \"apple\" はセット内にある\n}\n\n// 要素を削除\ndelete(set, \"apple\")\n\n// map[string]struct{} を使用したセット (メモリ効率が良い)\nset := make(map[string]struct{})\n\n// 要素を追加\nset[\"apple\"] = struct{}{}\n\n// メンバーシップを確認\nif _, ok := set[\"apple\"]; ok {\n  // \"apple\" はセット内にある\n}\n\n// セット要素を反復処理\nfor element := range set {\n  fmt.Println(element)\n}\n\n// セット操作\n// 和集合\nunion := make(map[string]struct{})\nfor element := range set1 {\n  union[element] = struct{}{}\n}\nfor element := range set2 {\n  union[element] = struct{}{}\n}\n\n// 積集合\nintersection := make(map[string]struct{})\nfor element := range set1 {\n  if _, ok := set2[element]; ok {\n    intersection[element] = struct{}{}\n  }\n}"
    },
    {
      "title": "Linked Lists",
      "code": "// Go の標準ライブラリには双方向連結リストの実装が含まれている\n// container/list パッケージ内\n\nimport \"container/list\"\n\n// 新しいリストを作成\nl := list.New()\n\n// 要素を追加\n// 末尾に追加\nl.PushBack(\"last\")\n// 先頭に追加\nl.PushFront(\"first\")\n\n// 要素を挿入\nelem := l.PushBack(\"middle\")\nl.InsertBefore(\"before middle\", elem)\nl.InsertAfter(\"after middle\", elem)\n\n// リストを走査\nfor e := l.Front(); e != nil; e = e.Next() {\n// 値にアクセス\n  fmt.Println(e.Value)\n}\n\n// 要素を削除\n// 特定の要素を削除\nl.Remove(elem)\n\n// カスタム連結リストの実装\ntype Node struct {\n  Value int\n  Next  *Node\n}\n\n// 連結リストを作成\nhead := &Node{Value: 1}\nhead.Next = &Node{Value: 2}\nhead.Next.Next = &Node{Value: 3}\n\n// 走査\nfor current := head; current != nil; current = current.Next {\n  fmt.Println(current.Value)\n}"
    }
  ]
}
