{
  "title": "Data structures",
  "codeExamples": [
    {
      "title": "Arrays",
      "code": "// Array declaration (fixed size)\nvar a [5]int // [0 0 0 0 0]\n\n// Array initialization\nb := [3]int{1, 2, 3}  // [1 2 3]\n\n// Array with implicit size\nc := [...]int{4, 5, 6, 7} // [4]int - compiler counts elements\n\n// Accessing elements\nfirst := a[0]  // 0\na[0] = 10      // Sets first element to 10\n\n// Multi-dimensional arrays\nmatrix := [2][3]int{\n  {1, 2, 3},\n  {4, 5, 6},\n}\nvalue := matrix[1][2]  // 6\n\n// Arrays are values (copying)\noriginal := [3]int{1, 2, 3}\ncopy := original       // Creates a complete copy\ncopy[0] = 99          // Doesn't affect original\n\n// Array size is part of type - these are different types\nvar a1 [5]int\nvar a2 [10]int\n// a1 = a2  // Compile error - different types"
    },
    {
      "title": "Slices",
      "code": "// Slice declaration (dynamic size view of an array)\nvar s []int // nil slice (length & capacity are 0)\n\n// Make a slice\ns = make([]int, 5)     // len=5, cap=5, initialized to zero values\ns = make([]int, 3, 10) // len=3, cap=10, initialized to zero values\n\n// Slice literal\ns = []int{1, 2, 3} // len=3, cap=3\n\n// Slicing existing arrays or slices\na := [5]int{1, 2, 3, 4, 5}\ns := a[1:4]  // s == []int{2, 3, 4}, len=3, cap=4\n\n// Slice indices\nfull := []int{1, 2, 3, 4, 5}\ns1 := full[1:4]    // [2 3 4]   - from index 1 to 3 (4 exclusive)\ns2 := full[:3]     // [1 2 3]   - from start to index 2\ns3 := full[2:]     // [3 4 5]   - from index 2 to end\ns4 := full[:]      // [1 2 3 4 5] - the whole slice\n\n// Append to slice (may create new underlying array if needed)\ns = append(s, 4, 5)  // Add elements 4 and 5\nt := []int{6, 7, 8}\ns = append(s, t...)  // Append another slice\n\n// Slice length and capacity\nlen := len(s)  // Number of elements\ncap := cap(s)  // Capacity of underlying array\n\n// Common slice operations\n// Copy\ndst := make([]int, len(src))\ncopy(dst, src)  // Copy from src to dst, returns number of elements copied\n\n// Remove element at index i\ns = append(s[:i], s[i+1:]...)\n\n// Insert element at index i\ns = append(s[:i], append([]int{x}, s[i:]...)...)\n// More efficient insert\ns = append(s, 0)       // Add zero value at end\ncopy(s[i+1:], s[i:])  // Shift elements right\ns[i] = x              // Place new element"
    },
    {
      "title": "Maps",
      "code": "// Map declaration (key-value store, unordered)\nvar m map[string]int // nil map (read but not write)\n\n// Make a map\nm = make(map[string]int)\n\n// Map literal\nm = map[string]int{\n  \"one\": 1,\n  \"two\": 2,\n}\n\n// Map operations\nm[\"three\"] = 3     // Add/update key-value pair\nvalue := m[\"one\"]   // Get value (returns zero value if key not found)\ndelete(m, \"two\")    // Remove key-value pair\n\n// Check existence\nvalue, exists := m[\"four\"] // value=0, exists=false if key not found\nif exists {\n  // Key exists\n}\n\n// Iterating over maps (random order)\nfor key, value := range m {\n  fmt.Println(key, value)\n}\n\n// Get all keys\nkeys := make([]string, 0, len(m))\nfor k := range m {\n  keys = append(keys, k)\n}\n\n// Sort keys for consistent order\nsort.Strings(keys)\nfor _, k := range keys {\n  fmt.Printf(\"%s: %d\\n\", k, m[k])\n}\n\n// Maps are references (not values like arrays)\noriginal := map[string]int{\"one\": 1}\ncopy := original          // Both reference same map\ncopy[\"one\"] = 99         // Changes visible through both variables"
    },
    {
      "title": "Structs",
      "code": "// Define a struct type\ntype Person struct {\n  Name    string\n  Age     int\n  Address *Address\n}\n\ntype Address struct {\n  Street string\n  City   string\n}\n\n// Create a struct\np1 := Person{Name: \"Alice\", Age: 30}  // Named fields (recommended)\np2 := Person{\"Bob\", 25, nil}        // Positional fields (fragile)\np3 := new(Person)                   // Allocates a zeroed Person, returns *Person\n\n// Access fields\nname := p1.Name\np1.Age = 31\n\n// Nested structs\np4 := Person{\n  Name: \"Charlie\",\n  Age: 35,\n  Address: &Address{\n    Street: \"123 Main St\",\n    City: \"Anytown\",\n  },\n}\ncity := p4.Address.City\n\n// Anonymous structs (one-time use)\npoint := struct {\n  X, Y int\n}{10, 20}\n\n// Anonymous fields (embedding)\ntype Employee struct {\n  Person       // Embeds all Person fields\n  CompanyName string\n  Salary      float64\n}\n\ne := Employee{}\ne.Name = \"Dave\"       // Promoted field from Person\ne.Person.Name = \"Dave\" // Also works\ne.CompanyName = \"Acme\""
    },
    {
      "title": "Sets",
      "code": "// Go has no built-in set type\n// Use map[type]bool or map[type]struct{} instead\n\n// Set using map[string]bool\nset := make(map[string]bool)\n\n// Add elements\nset[\"apple\"] = true\nset[\"banana\"] = true\n\n// Check membership\nif set[\"apple\"] {\n  // \"apple\" is in the set\n}\n\n// Remove element\ndelete(set, \"apple\")\n\n// Set using map[string]struct{} (memory efficient)\nset := make(map[string]struct{})\n\n// Add element\nset[\"apple\"] = struct{}{}\n\n// Check membership\nif _, ok := set[\"apple\"]; ok {\n  // \"apple\" is in the set\n}\n\n// Iterate over set elements\nfor element := range set {\n  fmt.Println(element)\n}\n\n// Set operations\n// Union\nunion := make(map[string]struct{})\nfor element := range set1 {\n  union[element] = struct{}{}\n}\nfor element := range set2 {\n  union[element] = struct{}{}\n}\n\n// Intersection\nintersection := make(map[string]struct{})\nfor element := range set1 {\n  if _, ok := set2[element]; ok {\n    intersection[element] = struct{}{}\n  }\n}"
    },
    {
      "title": "Linked Lists",
      "code": "// Go's standard library contains a doubly-linked list implementation\n// in the container/list package\n\nimport \"container/list\"\n\n// Create a new list\nl := list.New()\n\n// Add elements\nl.PushBack(\"last\")    // Add to back\nl.PushFront(\"first\")  // Add to front\n\n// Insert element\nelem := l.PushBack(\"middle\")\nl.InsertBefore(\"before middle\", elem)\nl.InsertAfter(\"after middle\", elem)\n\n// Traverse list\nfor e := l.Front(); e != nil; e = e.Next() {\n  fmt.Println(e.Value)  // Access the value\n}\n\n// Remove elements\nl.Remove(elem)  // Remove specific element\n\n// Custom linked list implementation\ntype Node struct {\n  Value int\n  Next  *Node\n}\n\n// Create a linked list\nhead := &Node{Value: 1}\nhead.Next = &Node{Value: 2}\nhead.Next.Next = &Node{Value: 3}\n\n// Traverse\nfor current := head; current != nil; current = current.Next {\n  fmt.Println(current.Value)\n}"
    }
  ]
}