{
  "title": "Data structures",
  "codeExamples": [
    {
      "title": "Arrays",
      "code": "// 配列宣言 (固定サイズ)\nvar a [5]int // [0 0 0 0 0]\n\n// 配列の初期化\nb := [3]int{1, 2, 3}  // [1 2 3]\n\n// 暗黙的なサイズの配列\nc := [...]int{4, 5, 6, 7} // [4]int - コンパイラが要素数を数える\n\n// 要素へのアクセス\nfirst := a[0]  // 0\na[0] = 10      // 最初の要素を 10 に設定\n\n// 多次元配列\nmatrix := [2][3]int{\n  {1, 2, 3},\n  {4, 5, 6},\n}\nvalue := matrix[1][2]  // 6\n\n// 配列は値 (コピー)\noriginal := [3]int{1, 2, 3}\ncopy := original       // 完全なコピーを作成\ncopy[0] = 99          // 元の配列には影響しない\n\n// 配列のサイズは型の一部 - これらは異なる型\nvar a1 [5]int\nvar a2 [10]int\n// a1 = a2  // コンパイルエラー - 異なる型"
    },
    {
      "title": "Slices",
      "code": "// スライス宣言 (配列の動的サイズのビュー)\nvar s []int // nil スライス (長さと容量は 0)\n\n// スライスを作成\ns = make([]int, 5)     // len=5, cap=5, ゼロ値で初期化\ns = make([]int, 3, 10) // len=3, cap=10, ゼロ値で初期化\n\n// スライスリテラル\ns = []int{1, 2, 3} // len=3, cap=3\n\n// 既存の配列またはスライスからのスライス\na := [5]int{1, 2, 3, 4, 5}\ns := a[1:4]  // s == []int{2, 3, 4}, len=3, cap=4\n\n// スライスのインデックス\nfull := []int{1, 2, 3, 4, 5}\ns1 := full[1:4]    // [2 3 4]   - インデックス 1 から 3 まで (4 は含まない)\ns2 := full[:3]     // [1 2 3]   - 開始からインデックス 2 まで\ns3 := full[2:]     // [3 4 5]   - インデックス 2 から最後まで\ns4 := full[:]      // [1 2 3 4 5] - スライス全体\n\n// スライスに追加 (必要に応じて新しい基底配列を作成することがある)\ns = append(s, 4, 5)  // 要素 4 と 5 を追加\nt := []int{6, 7, 8}\ns = append(s, t...)  // 別のスライスを追加\n\n// スライスの長さと容量\nlen := len(s)  // 要素数\ncap := cap(s)  // 基底配列の容量\n\n// 一般的なスライス操作\n// コピー\ndst := make([]int, len(src))\ncopy(dst, src)  // src から dst へコピー、コピーされた要素数を返す\n\n// インデックス i の要素を削除\ns = append(s[:i], s[i+1:]...)\n\n// インデックス i に要素を挿入\ns = append(s[:i], append([]int{x}, s[i:]...)...)\n// より効率的な挿入\ns = append(s, 0)       // 末尾にゼロ値を追加\ncopy(s[i+1:], s[i:])  // 要素を右にシフト\ns[i] = x              // 新しい要素を配置"
    },
    {
      "title": "Maps",
      "code": "// マップ宣言 (キーバリューストア、順序なし)\nvar m map[string]int // nil マップ (読み取りは可能だが書き込みは不可)\n\n// マップを作成\nm = make(map[string]int)\n\n// マップリテラル\nm = map[string]int{\n  \"one\": 1,\n  \"two\": 2,\n}\n\n// マップ操作\nm[\"three\"] = 3     // キーバリューペアを追加/更新\nvalue := m[\"one\"]   // 値を取得 (キーが見つからない場合はゼロ値を返す)\ndelete(m, \"two\")    // キーバリューペアを削除\n\n// 存在確認\nvalue, exists := m[\"four\"] // キーが見つからない場合 value=0, exists=false\nif exists {\n  // キーが存在する\n}\n\n// マップの反復処理 (ランダムな順序)\nfor key, value := range m {\n  fmt.Println(key, value)\n}\n\n// すべてのキーを取得\nkeys := make([]string, 0, len(m))\nfor k := range m {\n  keys = append(keys, k)\n}\n\n// 一貫した順序のためにキーをソート\nsort.Strings(keys)\nfor _, k := range keys {\n  fmt.Printf(\"%s: %d\\n\", k, m[k])\n}\n\n// マップは参照 (配列のような値ではない)\noriginal := map[string]int{\"one\": 1}\ncopy := original          // 両方が同じマップを参照\ncopy[\"one\"] = 99         // 変更は両方の変数を通じて見える"
    },
    {
      "title": "Structs",
      "code": "// 構造体型を定義\ntype Person struct {\n  Name    string\n  Age     int\n  Address *Address\n}\n\ntype Address struct {\n  Street string\n  City   string\n}\n\n// 構造体を作成\np1 := Person{Name: \"Alice\", Age: 30}  // 名前付きフィールド (推奨)\np2 := Person{\"Bob\", 25, nil}        // 位置指定フィールド (壊れやすい)\np3 := new(Person)                   // ゼロ化された Person を割り当て、*Person を返す\n\n// フィールドへのアクセス\nname := p1.Name\np1.Age = 31\n\n// ネストされた構造体\np4 := Person{\n  Name: \"Charlie\",\n  Age: 35,\n  Address: &Address{\n    Street: \"123 Main St\",\n    City: \"Anytown\",\n  },\n}\ncity := p4.Address.City\n\n// 無名構造体 (一度きりの使用)\npoint := struct {\n  X, Y int\n}{10, 20}\n\n// 無名フィールド (埋め込み)\ntype Employee struct {\n  Person       // すべての Person フィールドを埋め込む\n  CompanyName string\n  Salary      float64\n}\n\ne := Employee{}\ne.Name = \"Dave\"       // Person から昇格したフィールド\ne.Person.Name = \"Dave\" // これでも動作する\ne.CompanyName = \"Acme\""
    },
    {
      "title": "Sets",
      "code": "// Go には組み込みのセット型がない\n// 代わりに map[type]bool または map[type]struct{} を使用する\n\n// map[string]bool を使用したセット\nset := make(map[string]bool)\n\n// 要素を追加\nset[\"apple\"] = true\nset[\"banana\"] = true\n\n// メンバーシップを確認\nif set[\"apple\"] {\n  // \"apple\" はセット内にある\n}\n\n// 要素を削除\ndelete(set, \"apple\")\n\n// map[string]struct{} を使用したセット (メモリ効率が良い)\nset := make(map[string]struct{})\n\n// 要素を追加\nset[\"apple\"] = struct{}{}\n\n// メンバーシップを確認\nif _, ok := set[\"apple\"]; ok {\n  // \"apple\" はセット内にある\n}\n\n// セット要素を反復処理\nfor element := range set {\n  fmt.Println(element)\n}\n\n// セット操作\n// 和集合\nunion := make(map[string]struct{})\nfor element := range set1 {\n  union[element] = struct{}{}\n}\nfor element := range set2 {\n  union[element] = struct{}{}\n}\n\n// 積集合\nintersection := make(map[string]struct{})\nfor element := range set1 {\n  if _, ok := set2[element]; ok {\n    intersection[element] = struct{}{}\n  }\n}"
    },
    {
      "title": "Linked Lists",
      "code": "// Go の標準ライブラリには双方向連結リストの実装が含まれている\n// container/list パッケージ内\n\nimport \"container/list\"\n\n// 新しいリストを作成\nl := list.New()\n\n// 要素を追加\nl.PushBack(\"last\")    // 末尾に追加\nl.PushFront(\"first\")  // 先頭に追加\n\n// 要素を挿入\nelem := l.PushBack(\"middle\")\nl.InsertBefore(\"before middle\", elem)\nl.InsertAfter(\"after middle\", elem)\n\n// リストを走査\nfor e := l.Front(); e != nil; e = e.Next() {\n  fmt.Println(e.Value)  // 値にアクセス\n}\n\n// 要素を削除\nl.Remove(elem)  // 特定の要素を削除\n\n// カスタム連結リストの実装\ntype Node struct {\n  Value int\n  Next  *Node\n}\n\n// 連結リストを作成\nhead := &Node{Value: 1}\nhead.Next = &Node{Value: 2}\nhead.Next.Next = &Node{Value: 3}\n\n// 走査\nfor current := head; current != nil; current = current.Next {\n  fmt.Println(current.Value)\n}"
    }
  ]
}