{
  "title": "Methods",
  "codeExamples": [
    {
      "title": "Methods",
      "code": "// Define a type\ntype Rectangle struct {\n  Width, Height float64\n}\n\n// Method with a value receiver\nfunc (r Rectangle) Area() float64 {\n  return r.Width * r.Height\n}\n\n// Pointer receiver for modification\nfunc (r *Rectangle) Scale(factor float64) {\n  r.Width *= factor\n  r.Height *= factor\n}\n\n// Using methods\nrect := Rectangle{10, 5}\narea := rect.Area()       // 50\nrect.Scale(2)             // Width=20, Height=10\n\n// Methods on non-struct types\ntype MyInt int\n\nfunc (m MyInt) IsEven() bool {\n  return m%2 == 0\n}\n\nfunc (m *MyInt) Add(n MyInt) {\n  *m += n\n}\n\nvar num MyInt = 10\nfmt.Println(num.IsEven())  // true\nnum.Add(5)\nfmt.Println(num)           // 15"
    },
    {
      "title": "Value vs Pointer Receivers",
      "code": "// Value receiver (copy, immutable operation)\nfunc (r Rectangle) Double() Rectangle {\n  return Rectangle{\n    Width:  r.Width * 2,\n    Height: r.Height * 2,\n  }\n}\n\n// Pointer receiver (modify original)\nfunc (r *Rectangle) Resize(w, h float64) {\n  r.Width = w\n  r.Height = h\n}\n\n// Usage\nrect := Rectangle{5, 10}\nrect2 := rect.Double()    // New rectangle\nrect.Resize(20, 30)       // Modified original\n\n// When to use value receivers:\n// - The method doesn't modify the receiver\n// - The receiver is a small value (like int, float64)\n// - The receiver is immutable by convention\n// - No "nil" receiver handling is needed\n\n// When to use pointer receivers:\n// - The method modifies the receiver\n// - The receiver is large (to avoid copying)\n// - Consistency with other methods of the type\n// - The receiver may be nil\n\n// Go automatically handles conversions:\nrect := Rectangle{5, 10}\narea := rect.Area()       // Calls method on value\n\nprect := &Rectangle{5, 10}\narea = prect.Area()       // Go auto-dereferences pointer to call value method\n\n// But methods that require a pointer receiver only work on addressable values\nrect.Resize(20, 30)       // Go gets a pointer to rect automatically\nRectangle{5, 10}.Resize(20, 30)  // Error: cannot take address of temporary value"
    },
    {
      "title": "Method Expression",
      "code": "// Method expressions convert a method to a regular function\ntype Point struct{ X, Y float64 }\n\nfunc (p Point) Distance(q Point) float64 {\n  return math.Hypot(q.X-p.X, q.Y-p.Y)\n}\n\n// Method expression - explicit receiver as first parameter\ndistance := Point.Distance  // func(Point, Point) float64\np := Point{1, 2}\nq := Point{4, 6}\nfmt.Println(distance(p, q))  // Same as p.Distance(q)\n\n// Pointer receiver method expression\ntype Counter int\n\nfunc (c *Counter) Increment() { *c++ }\n\nincrement := (*Counter).Increment  // func(*Counter)\nc := Counter(0)\nincrement(&c)  // Same as (&c).Increment()\n\n// Method values (receiver is bound)\np := Point{1, 2}\ndistanceFromP := p.Distance  // func(Point) float64\nfmt.Println(distanceFromP(Point{4, 6}))  // Same as p.Distance(Point{4, 6})"
    },
    {
      "title": "Method Chaining",
      "code": "// Method chaining for fluent interfaces\ntype Builder struct {\n  str string\n}\n\n// Each method returns the receiver for chaining\nfunc (b *Builder) Add(s string) *Builder {\n  b.str += s\n  return b\n}\n\nfunc (b *Builder) AddSpace() *Builder {\n  b.str += \" \"\n  return b\n}\n\nfunc (b *Builder) ToString() string {\n  return b.str\n}\n\n// Usage\nb := &Builder{}\nresult := b.Add(\"Hello\").AddSpace().Add(\"World\").ToString()\nfmt.Println(result)  // \"Hello World\"\n\n// Builder pattern with methods\ntype RequestBuilder struct {\n  method  string\n  url     string\n  headers map[string]string\n}\n\nfunc NewRequestBuilder() *RequestBuilder {\n  return &RequestBuilder{\n    headers: make(map[string]string),\n  }\n}\n\nfunc (rb *RequestBuilder) Method(method string) *RequestBuilder {\n  rb.method = method\n  return rb\n}\n\nfunc (rb *RequestBuilder) URL(url string) *RequestBuilder {\n  rb.url = url\n  return rb\n}\n\nfunc (rb *RequestBuilder) Header(key, value string) *RequestBuilder {\n  rb.headers[key] = value\n  return rb\n}\n\nfunc (rb *RequestBuilder) Build() (*http.Request, error) {\n  req, err := http.NewRequest(rb.method, rb.url, nil)\n  if err != nil {\n    return nil, err\n  }\n  \n  for k, v := range rb.headers {\n    req.Header.Add(k, v)\n  }\n  \n  return req, nil\n}\n\n// Usage\nreq, err := NewRequestBuilder().\n  Method(\"GET\").\n  URL(\"https://example.com\").\n  Header(\"User-Agent\", \"MyClient/1.0\").\n  Build()"
    },
    {
      "title": "Methods vs Functions",
      "code": "// Methods are functions bound to a specific type\n\n// Function approach\nfunc AreaOf(r Rectangle) float64 {\n  return r.Width * r.Height\n}\n\n// Method approach\nfunc (r Rectangle) Area() float64 {\n  return r.Width * r.Height\n}\n\n// Usage comparison\nr := Rectangle{5, 10}\na1 := AreaOf(r)  // Function call with parameter\na2 := r.Area()   // Method call on instance\n\n// Advantages of methods:\n// 1. Namespace management - r.Area() vs AreaOf(r)\n// 2. Can define methods on any type in your package (not just structs)\n// 3. Can implement interfaces\n\n// Method table - methods are grouped by type\n// type Rectangle\n//   - Area\n//   - Perimeter\n//   - Scale\n\n// Method types\n// Methods on values  - func (v  Type) Method()\n// Methods on pointers - func (p *Type) Method()\n\n// Method sets\n// Values of type T have methods declared with receiver type T\n// Pointers to T have methods declared with *T AND methods of T"
    }
  ]
}