{
  "title": "Functions",
  "codeExamples": [
    {
      "title": "Basic Function",
      "code": "// 関数宣言\nfunc add(a int, b int) int {\n  return a + b\n}\n\n// 同じ型のパラメータはグループ化できる\nfunc add(a, b int) int {\n  return a + b\n}\n\n// 複数の戻り値\nfunc divAndRemainder(a, b int) (int, int) {\n  return a / b, a % b\n}\n\n// 名前付き戻り値\nfunc split(sum int) (x, y int) {\n  x = sum * 4 / 9\n  y = sum - x\n  return // naked return は名前付き戻り値を使用する\n}\n\n// エラーを返す (一般的なパターン)\nfunc readConfig(path string) ([]byte, error) {\n  file, err := os.Open(path)\n  if err != nil {\n    return nil, err  // ゼロ値とエラーを返す\n  }\n  defer file.Close()\n  \n  return io.ReadAll(file)  // データと nil エラーを返す\n}"
    },
    {
      "title": "Variadic Functions",
      "code": "// 可変長引数関数 (可変数の引数を受け入れる)\nfunc sum(nums ...int) int {\n  total := 0\n  for _, num := range nums {\n    total += num\n  }\n  return total\n}\n\n// 可変長引数関数の呼び出し\ntotal := sum(1, 2, 3, 4) // 10\n\n// スライスの展開\nnumbers := []int{1, 2, 3, 4}\ntotal = sum(numbers...) // 10\n\n// 他のパラメータを持つ可変長引数\nfunc appendValues(slice []int, values ...int) []int {\n  return append(slice, values...)\n}\n\nslice := []int{1, 2}\nslice = appendValues(slice, 3, 4, 5) // [1 2 3 4 5]\n\n// 便利な標準ライブラリの例:\n// fmt.Printf(format string, a ...interface{})\n// log.Printf(format string, a ...interface{})\n// errors.Join(errs ...error) error"
    },
    {
      "title": "Closures",
      "code": "// 関数を返す関数 (クロージャ)\nfunc adder() func(int) int {\n  sum := 0  // この変数は「キャプチャされる」\n  return func(x int) int {\n    sum += x  // キャプチャされた変数を変更する\n    return sum\n  }\n}\n\n// クロージャの使用\npos := adder()\nresult := pos(10) // 10\nresult = pos(20)  // 30\nresult = pos(30)  // 60\n\n// 異なるインスタンスは異なる状態を持つ\npos1 := adder()\npos2 := adder()\nfmt.Println(pos1(10))  // 10\nfmt.Println(pos2(20))  // 20\nfmt.Println(pos1(40))  // 50\n\n// for ループでのクロージャの使用 (よくある落とし穴)\nfuncs := make([]func(), 3)\nfor i := 0; i < 3; i++ {\n  funcs[i] = func() { fmt.Println(i) }  // 間違い: すべて最後の i の値 (3) を出力する\n}\n\n// 正しいアプローチ: 各反復で新しい変数を作成する\nfuncs := make([]func(), 3)\nfor i := 0; i < 3; i++ {\n  i := i  // このスコープで新しい i を作成\n  funcs[i] = func() { fmt.Println(i) }  // 正しい: それぞれが自身の i を出力する\n}"
    },
    {
      "title": "Function Types",
      "code": "// 関数は第一級の値\n// 変数に代入したり、引数として渡したり、関数から返したりできる\n\n// 関数型の宣言\ntype Handler func(string) error\n\n// 変数としての関数\nvar compute func(int, int) int\ncompute = func(a, b int) int {\n  return a + b\n}\nresult := compute(5, 3)  // 8\n\n// 引数としての関数\nfunc process(apply func(int, int) int, a, b int) int {\n  return apply(a, b)\n}\nresult := process(func(x, y int) int { return x * y }, 5, 3)  // 15\n\n// 戻り値としての関数\nfunc multiplier(factor int) func(int) int {\n  return func(n int) int {\n    return n * factor\n  }\n}\ndouble := multiplier(2)\ntriple := multiplier(3)\nfmt.Println(double(5))  // 10\nfmt.Println(triple(5))  // 15"
    },
    {
      "title": "Method vs Function",
      "code": "// 関数は独立している\nfunc distance(p1, p2 Point) float64 {\n  return math.Sqrt(square(p2.X-p1.X) + square(p2.Y-p1.Y))\n}\n\n// メソッドは型にアタッチされる\ntype Point struct { X, Y float64 }\n\nfunc (p Point) Distance(q Point) float64 {\n  return math.Sqrt(square(q.X-p.X) + square(q.Y-p.Y))\n}\n\n// 使用法\np1 := Point{1, 2}\np2 := Point{4, 6}\n\n// 関数呼び出し\ndist1 := distance(p1, p2)\n\n// メソッド呼び出し\ndist2 := p1.Distance(p2)"
    }
  ]
}