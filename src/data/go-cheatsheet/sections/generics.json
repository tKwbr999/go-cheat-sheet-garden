{
  "title": "Generics",
  "codeExamples": [
    {
      "title": "ジェネリクス: 型パラメータを持つジェネリック関数",
      "description": "",
      "code": "package main\n\nimport \"fmt\"\n\n// ジェネリック関数 Print の定義\n// [T any] で型パラメータ T (任意の型) を宣言\nfunc Print[T any](value T) {\n\tfmt.Printf(\"Type: %T, Value: %v\\n\", value, value)\n}\n\nfunc main() {\n\t// 型推論による呼び出し\n\tPrint(42)      // T は int と推論される\n\tPrint(\"hello\") // T は string と推論される\n\n\t// 型の明示的な指定 (通常は不要)\n\t// Print[bool](true)\n}"
    },
    {
      "title": "ジェネリクス: 複数の型パラメータを持つジェネリック関数",
      "description": "",
      "code": "package main\n\nimport \"fmt\"\n\n// ジェネリック関数 Map: スライス s ([]T) の各要素に f (func(T) U) を適用し、\n// 結果のスライス ([]U) を返す。\n// [T, U any] で2つの型パラメータ T と U (どちらも任意の型) を定義。\nfunc Map[T, U any](s []T, f func(T) U) []U {\n\tresult := make([]U, len(s))\n\tfor i, v := range s {\n\t\tresult[i] = f(v)\n\t}\n\treturn result\n}\n\nfunc main() {\n\tintSlice := []int{1, 2, 3}\n\tfmt.Printf(\"Input: %v\\n\", intSlice)\n\n\t// 例1: int -> int (2乗)\n\t// T=int, U=int と推論される\n\tsquares := Map(intSlice, func(x int) int { return x * x })\n\tfmt.Printf(\"Squares: %v (%T)\\n\", squares, squares)\n\n\t// 例2: int -> string (フォーマット)\n\t// T=int, U=string と推論される\n\tidStrings := Map(intSlice, func(x int) string { return fmt.Sprintf(\"ID-%d\", x) })\n\tfmt.Printf(\"Strings: %v (%T)\\n\", idStrings, idStrings)\n\n\t// 例3: string -> int (文字数) も可能 (省略)\n\t// stringSlice := []string{\"a\", \"bb\"}\n\t// lengths := Map(stringSlice, func(s string) int { return len(s) })\n}"
    },
    {
      "title": "ジェネリクス: インターフェースによる型制約",
      "description": "型パラメータに `any` を使うと任意の型を受け入れられますが、\n関数内でその型の値に対して行える操作が限られます。\n特定のメソッドや演算を可能にするには**型制約**を課します。\nGoでは型制約は**インターフェース型**で定義します。\n\n**型制約としてのインターフェース:**\n1.  **メソッドセットによる制約:**\n    従来通りインターフェースに必要なメソッドを定義。\n    型パラメータに指定すると、そのメソッドを持つ型のみ受け入れ可能。\n    関数内ではそのメソッドを呼び出せる。",
      "code": "package main\n\nimport \"fmt\"\n\n// 型制約: 組み込みの数値型を許可するインターフェース\ntype Numeric interface {\n\tint | int8 | int16 | int32 | int64 |\n\t\tuint | uint8 | uint16 | uint32 | uint64 | uintptr |\n\t\tfloat32 | float64\n\t// (Go 1.18+ constraints パッケージに同様の定義あり)\n}\n\n// ジェネリック関数 Sum: T は Numeric 制約を満たす必要がある\nfunc Sum[T Numeric](values []T) T {\n\tvar sum T\n\tfor _, v := range values {\n\t\tsum += v // + 演算子が使える (Numeric 内の型は全てサポート)\n\t}\n\treturn sum\n}\n\nfunc main() {\n\tintSlice := []int{1, 2, 3}\n\tintSum := Sum(intSlice) // T=int\n\tfmt.Printf(\"Sum(%v): %v (%T)\\n\", intSlice, intSum, intSum)\n\n\tfloatSlice := []float64{1.1, 2.2}\n\tfloatSum := Sum(floatSlice) // T=float64\n\tfmt.Printf(\"Sum(%v): %v (%T)\\n\", floatSlice, floatSum, floatSum)\n\n\t// stringSlice := []string{\"a\"}\n\t// Sum(stringSlice) // コンパイルエラー (string は Numeric ではない)\n}"
    },
    {
      "title": "ジェネリクス: 定義済みの型制約 (`comparable`, `cmp.Ordered`)",
      "description": "",
      "code": "package main\n\nimport (\n\t\"cmp\" // Go 1.21+\n\t\"fmt\"\n)\n\n// ジェネリック関数 Max: T は順序付け可能 (Ordered) である必要がある\nfunc Max[T cmp.Ordered](a, b T) T {\n\tif a > b { // > 演算子が使える\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc main() {\n\tfmt.Println(\"Max(10, 5):\", Max(10, 5))         // int\n\tfmt.Println(\"Max(3.14, 2.7):\", Max(3.14, 2.7)) // float64\n\tfmt.Println(\"Max(\\\"A\\\", \\\"B\\\"):\", Max(\"A\", \"B\")) // string\n\n\t// --- comparable の例 (参考) ---\n\t// func MapKeys[K comparable, V any](m map[K]V) []K { ... }\n\t// m := map[string]int{\"a\": 1}\n\t// keys := MapKeys(m) // OK: string は comparable\n\n\t// --- エラー例 ---\n\t// Max([]int{1}, []int{2}) // コンパイルエラー (スライスは Ordered ではない)\n}"
    },
    {
      "title": "\"ジェネリクス: ジェネリックなスタック (データ構造)\"",
      "description": "",
      "code": "package main\n\nimport \"fmt\"\n\n// --- ジェネリック型の定義 ---\n// Stack[T any]: 任意の型 T の値を格納できるスタック\ntype Stack[T any] struct {\n\titems []T // 内部的に T 型のスライスでデータを保持\n}\n\n// --- ジェネリック型に対するメソッド定義 ---\n\n// Push: スタックに要素を追加する\nfunc (s *Stack[T]) Push(item T) {\n\tif s == nil { return }\n\ts.items = append(s.items, item)\n}\n\n// Pop: スタックから要素を取り出して返す\nfunc (s *Stack[T]) Pop() (T, bool) {\n\tif s == nil || len(s.items) == 0 {\n\t\tvar zero T // T 型のゼロ値を返す準備\n\t\treturn zero, false\n\t}\n\tlastIndex := len(s.items) - 1\n\titem := s.items[lastIndex]\n\ts.items = s.items[:lastIndex]\n\treturn item, true\n}\n\n// IsEmpty: スタックが空かどうかを返す\nfunc (s *Stack[T]) IsEmpty() bool {\n\treturn s == nil || len(s.items) == 0\n}\n\nfunc main() {\n\t// --- int 型のスタック ---\n\tintStack := Stack[int]{}\n\tintStack.Push(1)\n\tintStack.Push(2)\n\tv1, ok1 := intStack.Pop() // v1=2, ok1=true\n\tfmt.Printf(\"Pop int: %v, %t\\n\", v1, ok1)\n\tv2, ok2 := intStack.Pop() // v2=1, ok2=true\n\tfmt.Printf(\"Pop int: %v, %t\\n\", v2, ok2)\n\tv3, ok3 := intStack.Pop() // v3=0, ok3=false (空)\n\tfmt.Printf(\"Pop int: %v, %t\\n\", v3, ok3)\n\n\t// --- string 型のスタック ---\n\tstrStack := Stack[string]{}\n\tstrStack.Push(\"A\")\n\tstrStack.Push(\"B\")\n\tsv1, sok1 := strStack.Pop() // sv1=\"B\", sok1=true\n\tfmt.Printf(\"Pop string: %v, %t\\n\", sv1, sok1)\n}\n\n/* 実行結果:\nPop int: 2, true\nPop int: 1, true\nPop int: 0, false\nPop string: B, true\n*/"
    },
    {
      "title": "ジェネリクス: スレッドセーフなジェネリックマップ",
      "description": "",
      "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\n// スレッドセーフなジェネリックマップ\n// K は比較可能 (comparable), V は任意 (any)\ntype SafeMap[K comparable, V any] struct {\n\tdata map[K]V\n\tmu   sync.RWMutex // 読み書きロックで保護\n}\n\n// コンストラクタ\nfunc NewSafeMap[K comparable, V any]() *SafeMap[K, V] {\n\treturn &SafeMap[K, V]{data: make(map[K]V)}\n}\n\n// Set: 書き込み操作 (Lock/Unlock)\nfunc (m *SafeMap[K, V]) Set(key K, value V) {\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\tm.data[key] = value\n}\n\n// Get: 読み取り操作 (RLock/RUnlock)\nfunc (m *SafeMap[K, V]) Get(key K) (V, bool) {\n\tm.mu.RLock()\n\tdefer m.mu.RUnlock()\n\tval, ok := m.data[key]\n\treturn val, ok\n}\n\n// (Delete, Len などのメソッドも同様に実装可能)\n\nfunc main() {\n\t// string -> int のマップを作成\n\tsafeMap := NewSafeMap[string, int]()\n\n\t// 複数の Goroutine から安全にアクセスできる\n\t// (ここでは main Goroutine からのみアクセス)\n\tsafeMap.Set(\"apple\", 100)\n\tsafeMap.Set(\"banana\", 200)\n\n\tval, ok := safeMap.Get(\"apple\")\n\tif ok { fmt.Println(\"apple:\", val) } // apple: 100\n\n\tval, ok = safeMap.Get(\"grape\")\n\tif !ok { fmt.Println(\"grape: not found\") } // grape: not found\n}"
    },
    {
      "title": "ジェネリクス: メソッドによる型制約 (`fmt.Stringer` など)",
      "description": "型パラメータに制約を課すもう一つの方法は、\n**メソッドセット**を持つインターフェースを使うことです。\nこれにより、型パラメータが特定のメソッドを持つことを保証できます。\n\n**メソッドセットによる制約:**\n*   型制約として、メソッドシグネチャを持つインターフェースを指定。\n    `type MyInterface interface { MethodA() }`\n*   ジェネリック関数/型で `[T MyInterface]` のように指定。\n*   `T` は `MyInterface` が要求する全メソッドを持つ必要がある。\n*   関数内では `T` 型の値に対し、制約インターフェースのメソッド\n    (`v.MethodA()`) を安全に呼び出せる。\n\n**標準インターフェースの利用: `fmt.Stringer`**\nよく使われるのが `fmt.Stringer` です。",
      "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\n// ジェネリック関数 Join: T は fmt.Stringer を満たす必要がある\nfunc Join[T fmt.Stringer](values []T, sep string) string {\n\tvar sb strings.Builder\n\tfor i, v := range values {\n\t\tif i > 0 { sb.WriteString(sep) }\n\t\t// ★ v.String() メソッドを呼び出せる (制約で保証) ★\n\t\tsb.WriteString(v.String())\n\t}\n\treturn sb.String()\n}\n\n// fmt.Stringer を実装する型\ntype Person struct { Name string; Age int }\nfunc (p Person) String() string { // Stringer を満たす\n\treturn fmt.Sprintf(\"%s(%d)\", p.Name, p.Age)\n}\n\n// type IPAddr [4]byte\n// func (ip IPAddr) String() string { ... } // これも Stringer\n\nfunc main() {\n\tpeople := []Person{{\"Alice\", 30}, {\"Bob\", 25}}\n\t// T=Person (Stringer を満たす)\n\tpeopleStr := Join(people, \", \")\n\tfmt.Println(\"People:\", peopleStr) // People: Alice(30), Bob(25)\n\n\t// addrs := []IPAddr{{127,0,0,1}, {192,168,1,1}}\n\t// addrsStr := Join(addrs, \"; \") // これも OK\n\n\t// nums := []int{1, 2}\n\t// Join(nums, \"-\") // コンパイルエラー (int は Stringer ではない)\n}"
    },
    {
      "title": "ジェネリクス: メソッドによる比較制約 (Comparable)",
      "description": "組み込みの `comparable` や `cmp.Ordered` 制約は、\n`==`, `<`, `>` などの演算子が使える型に限定されます。\n独自の比較ロジックを持つ構造体など、これらの演算子が\n定義されていない型で比較を行いたい場合は、\n**メソッドセットを持つインターフェース**を型制約として使います。\n\n**メソッドによる比較制約:**\n1. 比較メソッド (例: `CompareTo(other T) int`) を持つ\n   インターフェースを定義する。",
      "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\n// 比較メソッドを持つインターフェース制約\ntype Comparer[T any] interface {\n\t// other より小さい場合に負、等しい場合に 0、大きい場合に正を返す\n\tCompareTo(other T) int\n}\n\n// ジェネリックソート関数 (T は Comparer[T] を満たす必要あり)\nfunc SortSlice[T Comparer[T]](items []T) {\n\tsort.Slice(items, func(i, j int) bool {\n\t\t// ★ CompareTo メソッドを使って比較 ★\n\t\treturn items[i].CompareTo(items[j]) < 0\n\t})\n}\n\n// Comparer[Version] を実装する Version 型\ntype Version struct { Major, Minor, Patch int }\nfunc (v Version) String() string { /* ... */ return fmt.Sprintf(\"v%d.%d.%d\", v.Major, v.Minor, v.Patch) }\nfunc (v Version) CompareTo(other Version) int {\n\tif v.Major != other.Major { return v.Major - other.Major }\n\tif v.Minor != other.Minor { return v.Minor - other.Minor }\n\treturn v.Patch - other.Patch\n}\n\nfunc main() {\n\tversions := []Version{{1, 10, 0}, {1, 9, 5}, {2, 0, 0}}\n\tfmt.Println(\"Before:\", versions)\n\tSortSlice(versions) // T=Version (Comparer[Version] を満たす)\n\tfmt.Println(\"After:\", versions) // [v1.9.5 v1.10.0 v2.0.0]\n}"
    },
    {
      "title": "ジェネリクス: Optional/Maybe 型パターン",
      "description": "関数が値を返す際、その値が**存在する場合**と**存在しない場合**を\n明確に示したいことがあります (例: マップ検索)。\n\nGoでは複数戻り値 (`value, ok := ...`) が一般的ですが、\n他の言語で見られる **Optional** / **Maybe** パターンを\nジェネリクスで実装することも可能です。\n値の有無と値自体を一つの型でカプセル化します。\n\n**実装:**\n*   ジェネリック構造体 `Optional[T any]` を定義。\n*   内部に値 `value T` と有効フラグ `valid bool` を持つ。\n*   `Some(value T)`: 値を持つ Optional (`valid=true`) を作成。\n*   `None[T any]()`: 値を持たない Optional (`valid=false`) を作成。\n    (型パラメータ `T` の指定が必要)\n*   `IsPresent()`, `Get()` 等のメソッドで値の有無確認や取得を行う。\n\nコード例は `Optional[T]` 型とその基本的なコンストラクタ、\nメソッドを示しています。\n\n**使用例:**",
      "code": "package optional // (パッケージ名は例)\n\n// Optional[T any]: T 型の値が存在するかもしれないことを示す型\ntype Optional[T any] struct {\n\tvalue T    // 値 (存在しない場合はゼロ値)\n\tvalid bool // 値が有効か (存在するか)\n}\n\n// Some: 値が存在する Optional を作成\nfunc Some[T any](value T) Optional[T] {\n\treturn Optional[T]{value: value, valid: true}\n}\n\n// None: 値が存在しない Optional を作成\nfunc None[T any]() Optional[T] {\n\treturn Optional[T]{valid: false} // value は T のゼロ値\n}\n\n// IsPresent: 値が存在するかどうか\nfunc (o Optional[T]) IsPresent() bool {\n\treturn o.valid\n}\n\n// Get: 値と存在有無 (bool) を返す (マップのカンマOK風)\nfunc (o Optional[T]) Get() (T, bool) {\n\treturn o.value, o.valid\n}\n\n// (IsEmpty, OrElse などのヘルパーメソッドも追加可能)"
    },
    {
      "title": "ジェネリクス: Result 型パターン",
      "description": "Go標準のエラー処理は複数戻り値 (`value, err`) ですが、\n他の言語で見られる **Result 型** パターンもジェネリクスで実装可能です。\nResult 型は、操作の**成功値 (`Ok`)** または **失敗エラー (`Err`)** の\n**どちらか一方**を保持し、関数の戻り値を単一の型にまとめます。\n\n**実装:**\n*   ジェネリック構造体 `Result[T any]` を定義。\n*   内部に成功時の値 `value T` と失敗時のエラー `err error` を持つ。\n*   `Success(value T)`: 成功 Result (`err=nil`) を作成。\n*   `Failure[T any](err error)`: 失敗 Result (`value=ゼロ値`) を作成。\n    (型パラメータ `T` の指定が必要)\n*   `IsOk()`, `IsErr()`, `Value()`, `Error()` 等のメソッドで\n    状態確認や値/エラー取得を行う。\n\n**使用例:**",
      "code": "package result // (パッケージ名は例)\n\nimport \"fmt\"\n\n// Result[T any]: 成功時の T 型の値、またはエラーのどちらかを保持\ntype Result[T any] struct {\n\tvalue T\n\terr   error\n}\n\n// Success: 成功 Result を作成\nfunc Success[T any](value T) Result[T] {\n\treturn Result[T]{value: value, err: nil}\n}\n\n// Failure: 失敗 Result を作成\nfunc Failure[T any](err error) Result[T] {\n\treturn Result[T]{err: err} // value はゼロ値\n}\n\n// Failuref: フォーマット文字列から失敗 Result を作成\nfunc Failuref[T any](format string, args ...any) Result[T] {\n\treturn Result[T]{err: fmt.Errorf(format, args...)}\n}\n\n// IsOk: 成功かどうか\nfunc (r Result[T]) IsOk() bool { return r.err == nil }\n\n// IsErr: 失敗かどうか\nfunc (r Result[T]) IsErr() bool { return r.err != nil }\n\n// Value: 成功時の値 (失敗時はゼロ値)\nfunc (r Result[T]) Value() T { return r.value }\n\n// Error: 失敗時のエラー (成功時は nil)\nfunc (r Result[T]) Error() error { return r.err }\n\n// (Unwrap, UnwrapOr などのヘルパーも追加可能)\n// func (r Result[T]) Unwrap() T { if r.IsErr() { panic(...) }; return r.value }\n// func (r Result[T]) UnwrapOr(defaultVal T) T { if r.IsErr() { return defaultVal }; return r.value }"
    },
    {
      "title": "\"ジェネリクス: ジェネリックな Min/Max 関数\"",
      "description": "",
      "code": "package main\n\nimport (\n\t\"cmp\" // Go 1.21+ で Ordered を使うためにインポート\n\t\"fmt\"\n)\n\n// Min は 2 つの順序付け可能な値のうち小さい方を返す\nfunc Min[T cmp.Ordered](a, b T) T {\n\t// cmp.Ordered 制約により < 演算子が使える\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\n// Max は 2 つの順序付け可能な値のうち大きい方を返す (030 で説明済み)\nfunc Max[T cmp.Ordered](a, b T) T {\n\t// cmp.Ordered 制約により > 演算子が使える\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc main() {\n\t// int で使用\n\tfmt.Printf(\"Min(10, 5) = %v\\n\", Min(10, 5)) // 5\n\tfmt.Printf(\"Max(10, 5) = %v\\n\", Max(10, 5)) // 10\n\n\t// float64 で使用\n\tfmt.Printf(\"Min(3.14, 2.71) = %v\\n\", Min(3.14, 2.71)) // 2.71\n\tfmt.Printf(\"Max(3.14, 2.71) = %v\\n\", Max(3.14, 2.71)) // 3.14\n\n\t// string で使用\n\tfmt.Printf(\"Min(\\\"apple\\\", \\\"banana\\\") = %v\\n\", Min(\"apple\", \"banana\")) // \"apple\"\n\tfmt.Printf(\"Max(\\\"apple\\\", \\\"banana\\\") = %v\\n\", Max(\"apple\", \"banana\")) // \"banana\"\n\n\t// Go 1.21 以降では、標準ライブラリに min, max 関数が追加された\n\t// import \"cmp\" // または import \"math\" (Go 1.23+)\n\t// fmt.Println(min(10, 5)) // 5\n\t// fmt.Println(max(3.14, 2.71)) // 3.14\n}\n\n/* 実行結果:\nMin(10, 5) = 5\nMax(10, 5) = 10\nMin(3.14, 2.71) = 2.71\nMax(3.14, 2.71) = 3.14\nMin(\"apple\", \"banana\") = apple\nMax(\"apple\", \"banana\") = banana\n*/"
    }
  ]
}