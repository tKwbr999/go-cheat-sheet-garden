{
  "title": "Context",
  "codeExamples": [
    {
      "title": "概要",
      "description": "",
      "code": "package context // (実際には組み込み)\n\nimport \"time\"\n\n// Context インターフェース定義\ntype Context interface {\n\tDeadline() (deadline time.Time, ok bool)\n\tDone() <-chan struct{}\n\tErr() error\n\tValue(key any) any\n}"
    },
    {
      "title": "\"基本的な Context の生成\"",
      "description": "すべての `context.Context` は、2つの基本的な Context のいずれかから派生します。これらの基本的な Context は `context` パッケージによって提供されます。\n\nこれらの基本的な Context と、そこから派生 Context を生成する方法については、**「並行処理」**セクションの**「Context の生成 (`context` パッケージ)」** (`090_concurrency/190_creating-contexts.md`) で既に説明しました。\n\nここでは、その要点を再確認します。\n\n## `context.Background()`\n\n*   **役割:** 通常、Context ツリーの**ルート**として使用されます。`main` 関数や、リクエスト処理の起点となる場所で最初に生成します。\n*   **特性:**\n    *   キャンセルされることはありません (`Done()` は `nil` チャネルを返します)。\n    *   値を持っていません (`Value()` は常に `nil` を返します)。\n    *   デッドラインを持っていません (`Deadline()` は `ok == false` を返します)。\n\n## `context.TODO()`\n\n*   **役割:** `Background()` と機能的には同じですが、どの Context を使うべきか**まだ明確でない**場合や、既存のコードが Context を受け取るように**まだ更新されていない**場合に、**一時的なプレースホルダー**として使用します。\n*   **意図:** 静的解析ツールなどで `context.TODO()` の使用箇所を検出し、将来的に適切な Context を渡すようにリファクタリングを促すことを意図しています。\n*   **特性:** `Background()` と同じく、キャンセルされず、値もデッドラインも持ちません。\n\n**原則として、Context ツリーの起点には `context.Background()` を使い、`context.TODO()` は一時的な代替としてのみ使用し、最終的には適切な Context に置き換えるべきです。**\n\n**参考コード (context.TODO):**",
      "code": "import \"context\"\n\n// main 関数や初期化処理でルート Context を生成\nctx := context.Background()\n\n// この ctx を基にして、WithCancel, WithTimeout などで子 Context を作成していく"
    },
    {
      "title": "Context の受け渡し規約",
      "description": "",
      "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\n// 下位関数: Context を受け取りキャンセルをチェック\nfunc queryDatabase(ctx context.Context, query string) (string, error) {\n\tfmt.Printf(\" DB Query: '%s'\\n\", query)\n\tselect {\n\tcase <-time.After(100 * time.Millisecond): // 処理模倣\n\t\tfmt.Printf(\" Query OK: '%s'\\n\", query)\n\t\treturn \"data\", nil\n\tcase <-ctx.Done(): // ★ キャンセルチェック\n\t\tfmt.Printf(\" Query Cancelled: '%s' (%v)\\n\", query, ctx.Err())\n\t\treturn \"\", ctx.Err()\n\t}\n}\n\n// 上位関数: Context を受け取り下位関数に渡す\nfunc handleRequest(ctx context.Context, requestData string) error {\n\tfmt.Println(\"Request Handling Start\")\n\t// ★ 下位関数に ctx をそのまま渡す\n\tresult, err := queryDatabase(ctx, \"find:\"+requestData)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"request failed: %w\", err)\n\t}\n\tfmt.Printf(\"Result: %s\\n\", result)\n\treturn nil\n}\n\n// main (呼び出し元)\n// func main() {\n// \tctx := context.Background()\n// \tctxTimeout, cancel := context.WithTimeout(ctx, 50*time.Millisecond)\n// \tdefer cancel()\n// \thandleRequest(ctxTimeout, \"some-data\") // Context を渡す\n// }"
    },
    {
      "title": "\"Context の伝播\"",
      "description": "",
      "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\n// 下位の関数: Context を受け取る\nfunc queryDatabase(ctx context.Context, query string) (string, error) {\n\tfmt.Printf(\"データベースクエリ '%s' を実行中...\\n\", query)\n\tselect {\n\tcase <-time.After(100 * time.Millisecond):\n\t\tfmt.Printf(\"クエリ '%s' 成功\\n\", query)\n\t\treturn \"結果データ\", nil\n\tcase <-ctx.Done(): // ★ 上位から渡された Context のキャンセルをチェック\n\t\tfmt.Printf(\"クエリ '%s' はキャンセルされました: %v\\n\", query, ctx.Err())\n\t\treturn \"\", ctx.Err()\n\t}\n}\n\n// 上位の関数: Context を受け取り、下位の関数にそのまま渡す\nfunc handleRequest(ctx context.Context, requestData string) error {\n\tfmt.Println(\"リクエスト処理開始\")\n\t// ★ 受け取った ctx をそのまま queryDatabase に渡す ★\n\tresult, err := queryDatabase(ctx, fmt.Sprintf(\"SELECT data WHERE id='%s'\", requestData))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"リクエスト処理失敗: %w\", err)\n\t}\n\tfmt.Printf(\"取得結果: %s\\n\", result)\n\tfmt.Println(\"リクエスト処理完了\")\n\treturn nil\n}\n\nfunc main() {\n\t// タイムアウト付き Context を作成\n\tctxWithTimeout, cancel := context.WithTimeout(context.Background(), 50*time.Millisecond)\n\tdefer cancel()\n\n\t// handleRequest にタイムアウト付き Context を渡す\n\t// handleRequest はそれを queryDatabase に渡す\n\t// タイムアウト (50ms) がクエリの実行時間 (100ms) より短いため、キャンセルされる\n\terr := handleRequest(ctxWithTimeout, \"data1\")\n\tif err != nil {\n\t\tfmt.Println(\"エラー:\", err)\n\t}\n}\n\n/* 実行結果:\nリクエスト処理開始\nデータベースクエリ 'SELECT data WHERE id='data1'' を実行中...\nクエリ 'SELECT data WHERE id='data1'' はキャンセルされました: context deadline exceeded\nエラー: リクエスト処理失敗: クエリ 'SELECT data WHERE id='data1'' はキャンセルされました: context deadline exceeded\n*/"
    },
    {
      "title": "キャンセル可能な Context の生成 (`WithCancel`)",
      "description": "",
      "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\n// キャンセルされるまで待機するワーカー\nfunc watch(ctx context.Context, name string, wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\tfmt.Printf(\"%s: 開始\\n\", name)\n\tselect {\n\tcase <-ctx.Done(): // キャンセルを待つ\n\t\tfmt.Printf(\"%s: キャンセル (%v)\\n\", name, ctx.Err())\n\t}\n}\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\trootCtx := context.Background()\n\n\t// キャンセル可能な Context を作成\n\tctx1, cancel1 := context.WithCancel(rootCtx)\n\tdefer cancel1() // ★ 必ず cancel を呼ぶ\n\n\twg.Add(1)\n\tgo watch(ctx1, \"Watcher 1\", &wg) // ctx1 を渡す\n\n\t// (ctx1 から派生した ctx2 を作成し、別の Goroutine に渡すことも可能)\n\t// ctx2, cancel2 := context.WithCancel(ctx1)\n\t// defer cancel2()\n\t// go watch(ctx2, \"Watcher 2\", &wg)\n\n\ttime.Sleep(100 * time.Millisecond)\n\n\tfmt.Println(\"main: cancel1() 呼び出し...\")\n\tcancel1() // ★ ctx1 をキャンセル (派生した ctx2 もキャンセルされる)\n\n\twg.Wait() // Goroutine の終了を待つ\n\tfmt.Println(\"main: 終了\")\n}"
    },
    {
      "title": "\"キャンセルへの応答 (`ctx.Done()`)\"",
      "description": "",
      "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\n// 時間のかかる処理をシミュレートする関数 (再掲)\nfunc longRunningTask(ctx context.Context, taskID int) error {\n\tfmt.Printf(\"タスク %d: 開始\\n\", taskID)\n\tticker := time.NewTicker(100 * time.Millisecond) // 定期的な処理を模倣\n\tdefer ticker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done(): // ★ Context のキャンセルをチェック\n\t\t\tfmt.Printf(\"タスク %d: キャンセル検知 (%v)\\n\", taskID, ctx.Err())\n\t\t\treturn ctx.Err() // キャンセル理由を返す\n\t\tcase t := <-ticker.C: // ★ 通常の処理 (例: 100ms ごと)\n\t\t\tfmt.Printf(\"タスク %d: 実行中 at %v\\n\", taskID, t.Format(\"15:04:05.000\"))\n\t\t\t// ここで実際の処理を行う\n\t\t\t// もしこの処理が非常に長い場合は、さらに内部で ctx.Done() をチェックすることも検討\n\t\t}\n\t}\n}\n\nfunc main() {\n\t// キャンセル可能な Context を作成\n\tctx, cancel := context.WithCancel(context.Background())\n\n\t// Goroutine でタスクを開始\n\tgo longRunningTask(ctx, 1)\n\n\t// 500ms 後にキャンセル\n\ttime.Sleep(500 * time.Millisecond)\n\tfmt.Println(\"main: キャンセル実行！\")\n\tcancel()\n\n\t// Goroutine が終了するのを少し待つ\n\ttime.Sleep(100 * time.Millisecond)\n\tfmt.Println(\"main: 終了\")\n}\n\n/* 実行結果の例 (時刻は実行時に依存):\nタスク 1: 開始\nタスク 1: 実行中 at 01:50:00.100\nタスク 1: 実行中 at 01:50:00.200\nタスク 1: 実行中 at 01:50:00.300\nタスク 1: 実行中 at 01:50:00.400\nタスク 1: 実行中 at 01:50:00.500\nmain: キャンセル実行！\nタスク 1: キャンセル検知 (context canceled)\nmain: 終了\n*/"
    },
    {
      "title": "ワーカーパターンにおけるキャンセル",
      "description": "",
      "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Task int\ntype Result int\n\n// ワーカー: Context を受け取り、キャンセルを監視\nfunc worker(ctx context.Context, id int, tasks <-chan Task, results chan<- Result, wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\tfmt.Printf(\"Worker %d: Start\\n\", id)\n\tfor {\n\t\tselect {\n\t\tcase task, ok := <-tasks:\n\t\t\tif !ok { return } // タスクチャネル close\n\t\t\tfmt.Printf(\"Worker %d: Task %d Process...\\n\", id, task)\n\t\t\ttime.Sleep(100 * time.Millisecond) // 処理模倣\n\t\t\tresults <- Result(task * 10)\n\t\tcase <-ctx.Done(): // ★ キャンセル検知\n\t\t\tfmt.Printf(\"Worker %d: Cancelled (%v)\\n\", id, ctx.Err())\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc main() {\n\ttasks := make(chan Task, 5)\n\tresults := make(chan Result, 5)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel() // main 終了時にキャンセル\n\tvar wg sync.WaitGroup\n\n\t// ワーカー起動\n\tfor w := 1; w <= 3; w++ {\n\t\twg.Add(1)\n\t\tgo worker(ctx, w, tasks, results, &wg) // ctx を渡す\n\t}\n\n\t// タスク送信\n\tfor j := 1; j <= 5; j++ { tasks <- Task(j) }\n\tclose(tasks) // タスク送信完了 -> ワーカーはタスクを終えたら終了できる\n\n\t// 途中でキャンセルする場合 (例)\n\t// time.Sleep(150 * time.Millisecond)\n\t// fmt.Println(\">>> Cancelling...\")\n\t// cancel() // これで全ワーカーにキャンセルが伝播\n\n\twg.Wait() // 全ワーカー終了待機\n\tclose(results) // 結果チャネルをクローズ\n\tfmt.Println(\"All workers done.\")\n\t// 結果収集 (省略)\n\t// for res := range results { fmt.Println(\"Result:\", res) }\n}"
    },
    {
      "title": "タイムアウト付き Context (`WithTimeout`)",
      "description": "",
      "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\n// Context のキャンセルをチェックする関数\nfunc simulateWork(ctx context.Context, duration time.Duration) error {\n\tfmt.Printf(\"作業開始 (最大 %v)\\n\", duration)\n\tselect {\n\tcase <-time.After(duration): // 処理模倣\n\t\tfmt.Println(\"作業完了\")\n\t\treturn nil\n\tcase <-ctx.Done(): // ★ タイムアウト/キャンセル検知\n\t\tfmt.Printf(\"作業キャンセル: %v\\n\", ctx.Err())\n\t\treturn ctx.Err()\n\t}\n}\n\nfunc main() {\n\t// 500ms でタイムアウトする Context を作成\n\tctx, cancel := context.WithTimeout(context.Background(), 500*time.Millisecond)\n\tdefer cancel() // ★ 必ず cancel を呼ぶ\n\n\t// 1秒かかる処理を実行 -> タイムアウトするはず\n\terr := simulateWork(ctx, 1*time.Second)\n\tif err != nil {\n\t\tfmt.Printf(\"エラー: %v\\n\", err) // context deadline exceeded\n\t}\n}"
    },
    {
      "title": "デッドライン付き Context (`WithDeadline`)",
      "description": "",
      "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\n// Context のキャンセルをチェックする関数\nfunc simulateWork(ctx context.Context, duration time.Duration) error {\n\tfmt.Printf(\"作業開始 (最大 %v)\\n\", duration)\n\tselect {\n\tcase <-time.After(duration): // 処理模倣\n\t\tfmt.Println(\"作業完了\")\n\t\treturn nil\n\tcase <-ctx.Done(): // ★ デッドライン超過/キャンセル検知\n\t\tfmt.Printf(\"作業キャンセル: %v\\n\", ctx.Err())\n\t\treturn ctx.Err()\n\t}\n}\n\nfunc main() {\n\t// 500ms 後をデッドラインとして設定\n\tdeadline := time.Now().Add(500 * time.Millisecond)\n\tctx, cancel := context.WithDeadline(context.Background(), deadline)\n\tdefer cancel() // ★ 必ず cancel を呼ぶ\n\n\t// 1秒かかる処理を実行 -> デッドラインを超えるはず\n\terr := simulateWork(ctx, 1*time.Second)\n\tif err != nil {\n\t\tfmt.Printf(\"エラー: %v\\n\", err) // context deadline exceeded\n\t}\n}"
    },
    {
      "title": "タイムアウト/デッドライン超過の確認",
      "description": "",
      "code": "package main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n)\n\n// Context のキャンセル理由を確認する関数\nfunc checkContextStatus(ctx context.Context, name string) {\n\tselect {\n\tcase <-ctx.Done(): // キャンセル待ち\n\t\terr := ctx.Err() // 理由を取得\n\t\tfmt.Printf(\"%s: Cancelled. Reason: %v\\n\", name, err)\n\t\t// 理由を判定\n\t\tif err == context.DeadlineExceeded { // または errors.Is\n\t\t\tfmt.Printf(\"   -> %s: Timeout/Deadline\\n\", name)\n\t\t} else if err == context.Canceled { // または errors.Is\n\t\t\tfmt.Printf(\"   -> %s: Explicit Cancel\\n\", name)\n\t\t}\n\tcase <-time.After(1 * time.Second): // タイムアウト待ち (デモ用)\n\t\tfmt.Printf(\"%s: Not cancelled within 1s\\n\", name)\n\t}\n}\n\nfunc main() {\n\t// タイムアウトケース\n\tctxTimeout, cancelT := context.WithTimeout(context.Background(), 50*time.Millisecond)\n\tdefer cancelT()\n\tcheckContextStatus(ctxTimeout, \"TimeoutCtx\")\n\n\t// 明示的キャンセルケース\n\tctxCancel, cancelC := context.WithCancel(context.Background())\n\tgo func() { time.Sleep(100 * time.Millisecond); cancelC() }()\n\tcheckContextStatus(ctxCancel, \"CancelCtx\")\n\n\t// ラップされたエラーの場合 (解説参照)\n\t// wrappedErr := fmt.Errorf(\"... %w\", ctx.Err())\n\t// if errors.Is(wrappedErr, context.DeadlineExceeded) { ... }\n}"
    },
    {
      "title": "HTTP クライアントでのタイムアウト/キャンセル",
      "description": "",
      "code": "package main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n)\n\nfunc main() {\n\t// タイムアウト付き Context (例: 50ms)\n\trequestTimeout := 50 * time.Millisecond\n\tctx, cancel := context.WithTimeout(context.Background(), requestTimeout)\n\tdefer cancel() // ★ 必ず cancel を呼ぶ\n\n\t// Context 付きリクエスト作成\n\turl := \"https://example.com\"\n\treq, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)\n\tif err != nil { /* エラー処理 */ return }\n\n\tfmt.Printf(\"GET %s (Timeout: %v)...\\n\", url, requestTimeout)\n\n\t// リクエスト実行\n\tresp, err := http.DefaultClient.Do(req)\n\t// ★ エラーがあってもなくても resp.Body を閉じる必要あり\n\tif resp != nil {\n\t\tdefer resp.Body.Close()\n\t}\n\n\t// エラーチェック\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Request Error: %v\\n\", err)\n\t\t// タイムアウトかチェック\n\t\tif errors.Is(err, context.DeadlineExceeded) {\n\t\t\tfmt.Fprintln(os.Stderr, \"-> Timeout!\")\n\t\t}\n\t\treturn\n\t}\n\n\t// 成功時の処理 (例)\n\tfmt.Printf(\"Status: %s\\n\", resp.Status)\n\t// body, _ := io.ReadAll(resp.Body) // ボディ読み取りなど\n}"
    },
    {
      "title": "データベース操作でのタイムアウト/キャンセル",
      "description": "",
      "code": "package main\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\t// _ \"github.com/mattn/go-sqlite3\" // 実際のドライバ\n)\n\n// ダミーのDBクエリ関数 (Context をチェック)\nfunc dummyQueryContext(ctx context.Context, db *sql.DB, query string) error {\n\tfmt.Printf(\"Query: %s\\n\", query)\n\tselect {\n\tcase <-time.After(200 * time.Millisecond): // 200ms かかると仮定\n\t\tfmt.Println(\" -> Query Success (Dummy)\")\n\t\t// _, err := db.QueryContext(ctx, query) // 実際の呼び出し\n\t\t// return err\n\t\treturn nil\n\tcase <-ctx.Done(): // Context キャンセルをチェック\n\t\tfmt.Printf(\" -> Query Cancelled: %v\\n\", ctx.Err())\n\t\treturn ctx.Err()\n\t}\n}\n\nfunc main() {\n\t// db, err := sql.Open(\"sqlite3\", \":memory:\") // 実際の接続例\n\tdb := &sql.DB{} // ダミー\n\t// if err != nil { log.Fatal(err) }\n\t// defer db.Close()\n\n\t// 100ms でタイムアウトする Context\n\tctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)\n\tdefer cancel()\n\n\t// QueryContext (を模倣した関数) を呼び出す\n\terr := dummyQueryContext(ctx, db, \"SELECT ...\")\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t\tif errors.Is(err, context.DeadlineExceeded) {\n\t\t\tfmt.Println(\"-> Timeout!\")\n\t\t}\n\t}\n}"
    },
    {
      "title": "\"Context への値の追加 (`WithValue`)\"",
      "description": "",
      "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n)\n\n// キーとして使うための独自型\ntype contextKey string\n\nconst (\n\tuserIDKey    contextKey = \"userID\"\n\ttraceIDKey   contextKey = \"traceID\"\n\tsessionIDKey contextKey = \"sessionID\"\n)\n\nfunc main() {\n\t// 1. ベースとなる Context\n\tctx := context.Background()\n\tfmt.Printf(\"ベース Context: %v\\n\", ctx)\n\n\t// 2. userID を追加\n\tctx = context.WithValue(ctx, userIDKey, \"user-987\")\n\tfmt.Printf(\"userID 追加後: %v\\n\", ctx)\n\n\t// 3. traceID を追加 (前の Context を親にする)\n\tctx = context.WithValue(ctx, traceIDKey, \"trace-abc-123\")\n\tfmt.Printf(\"traceID 追加後: %v\\n\", ctx)\n\n\t// 4. sessionID を追加 (さらに親にする)\n\tctx = context.WithValue(ctx, sessionIDKey, \"sess-xyz-789\")\n\tfmt.Printf(\"sessionID 追加後: %v\\n\", ctx)\n\n\t// --- 値の取得 (後続のファイルで説明) ---\n\t// 値を取得するには ctx.Value(key) を使う\n\t// 例: userID := ctx.Value(userIDKey).(string)\n\t// 例: traceID := ctx.Value(traceIDKey).(string)\n\t// 例: sessionID := ctx.Value(sessionIDKey).(string)\n\t// 例: 존재하지 않는 키 -> nil\n\t// nonExistent := ctx.Value(contextKey(\"otherKey\"))\n\t// fmt.Printf(\"存在しないキーの値: %v (nil: %t)\\n\", nonExistent, nonExistent == nil)\n}\n\n/* 実行結果の例 (Context の文字列表現は内部詳細であり、変わりうる):\nベース Context: context.Background\nuserID 追加後: context.Background.WithValue(type main.contextKey, val user-987)\ntraceID 追加後: context.Background.WithValue(type main.contextKey, val user-987).WithValue(type main.contextKey, val trace-abc-123)\nsessionID 追加後: context.Background.WithValue(type main.contextKey, val user-987).WithValue(type main.contextKey, val trace-abc-123).WithValue(type main.contextKey, val sess-xyz-789)\n*/"
    },
    {
      "title": "\"Context からの値の取得 (`Value`)\"",
      "description": "",
      "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n)\n\n// キーとして使うための独自型 (再掲)\ntype contextKey string\n\nconst (\n\tuserIDKey    contextKey = \"userID\"\n\ttraceIDKey   contextKey = \"traceID\"\n\tsessionIDKey contextKey = \"sessionID\"\n)\n\n// Context を受け取り、値を表示する関数\nfunc processRequest(ctx context.Context) {\n\tfmt.Println(\"\\n--- processRequest ---\")\n\n\t// userID を取得\n\tuserIDValue := ctx.Value(userIDKey)\n\t// 型アサーション (カンマOKイディオム)\n\tuserID, ok := userIDValue.(string)\n\tif !ok {\n\t\tfmt.Println(\"userID が見つからないか、型が異なります。\")\n\t} else {\n\t\tfmt.Printf(\"取得した userID: %s\\n\", userID)\n\t}\n\n\t// traceID を取得\n\ttraceID, ok := ctx.Value(traceIDKey).(string)\n\tif !ok {\n\t\tfmt.Println(\"traceID が見つからないか、型が異なります。\")\n\t} else {\n\t\tfmt.Printf(\"取得した traceID: %s\\n\", traceID)\n\t}\n\n\t// 存在しないキーを試す\n\totherValue := ctx.Value(contextKey(\"otherKey\"))\n\tif otherValue == nil {\n\t\tfmt.Println(\"存在しないキー 'otherKey' の値は nil です。\")\n\t}\n}\n\nfunc main() {\n\t// 値を持つ Context を作成 (前のセクションの例)\n\tctx := context.Background()\n\tctx = context.WithValue(ctx, userIDKey, \"user-987\")\n\tctx = context.WithValue(ctx, traceIDKey, \"trace-abc-123\")\n\t// sessionIDKey は設定しない\n\n\t// 関数に Context を渡す\n\tprocessRequest(ctx)\n\n\t// sessionIDKey を持つ子 Context を作成\n\tctxWithSession := context.WithValue(ctx, sessionIDKey, \"sess-xyz-789\")\n\tprocessRequest(ctxWithSession) // この呼び出しでは sessionID も取得できるはず\n}\n\n/* 実行結果:\n--- processRequest ---\n取得した userID: user-987\n取得した traceID: trace-abc-123\n存在しないキー 'otherKey' の値は nil です。\n\n--- processRequest ---\n取得した userID: user-987\n取得した traceID: trace-abc-123\n存在しないキー 'otherKey' の値は nil です。\n*/"
    },
    {
      "title": "\"値のキーに関するベストプラクティス\"",
      "description": "",
      "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n)\n\n// --- キーの定義 ---\n// キーとして使うための非公開の独自型 (string のエイリアスでも良い)\ntype contextKey string\n// または type contextKey struct{} でも良い\n\n// このパッケージ内でのみ使うキー変数を定義\nconst (\n\tuserIDKey    contextKey = \"user_id\" // 値は何でも良いが、区別できる文字列が一般的\n\ttraceIDKey   contextKey = \"trace_id\"\n)\n\n// --- 値の設定と取得 ---\nfunc main() {\n\t// 値を設定\n\tctx := context.Background()\n\tctx = context.WithValue(ctx, userIDKey, 12345) // キーには userIDKey (contextKey 型) を使う\n\tctx = context.WithValue(ctx, traceIDKey, \"xyz-trace-987\")\n\n\t// 値を取得\n\tuserIDValue := ctx.Value(userIDKey) // キーには userIDKey を使う\n\tuserID, ok := userIDValue.(int)     // 型アサーション\n\tif ok {\n\t\tfmt.Printf(\"UserID: %d\\n\", userID)\n\t} else {\n\t\tfmt.Println(\"UserID が見つからないか、型が異なります。\")\n\t}\n\n\ttraceIDValue := ctx.Value(traceIDKey)\n\ttraceID, ok := traceIDValue.(string)\n\tif ok {\n\t\tfmt.Printf(\"TraceID: %s\\n\", traceID)\n\t} else {\n\t\tfmt.Println(\"TraceID が見つからないか、型が異なります。\")\n\t}\n\n\t// --- 文字列リテラルをキーとして使う場合 (非推奨) ---\n\t// ctx = context.WithValue(ctx, \"userID\", 12345) // 非推奨\n\t// userIDValue = ctx.Value(\"userID\")             // 非推奨\n}\n\n/* 実行結果:\nUserID: 12345\nTraceID: xyz-trace-987\n*/"
    },
    {
      "title": "\"呼び出しスタックを通じた Context の伝播\"",
      "description": "`context.Context` の重要な役割の一つは、キャンセルシグナル、デッドライン、リクエストスコープの値を、一連の関数呼び出し（呼び出しスタック）を通じて伝達することです。\n\nContext を関数間でどのように渡すべきか（第一引数としてそのまま渡す）という規約については、**「Context の受け渡し規約」** (`100_context/020_passing-context-convention.md`) や **「Context の伝播」** (`100_context/030_chaining-context-aware-functions.md`) で説明しました。\n\nここでは、HTTPリクエスト処理を例に、Context がどのように伝播していくかを再確認します。\n\n## HTTPリクエスト処理における Context 伝播\n\n1.  **リクエストの開始:** HTTPサーバーがリクエストを受け取ると、通常、そのリクエストに対応するベースとなる Context が生成されます（`net/http` サーバーでは `r.Context()` で取得できます）。\n2.  **ミドルウェア:** 認証、ロギング、リクエストID付与などのミドルウェアは、受け取った Context を基に `context.WithValue` などで新しい Context を生成し、次のハンドラに渡します。\n3.  **メインハンドラ:** リクエストを処理するメインのハンドラ関数は、ミドルウェアから渡された Context を受け取ります。必要であれば、`context.WithTimeout` などでさらに派生させた Context を生成します。\n4.  **下位の関数呼び出し:** ハンドラが内部で呼び出すビジネスロジック関数、データベースアクセス関数、外部API呼び出し関数などには、**受け取った Context (またはそこから派生させた Context) をそのまま第一引数として渡します**。\n5.  **最下層の処理:** データベースドライバや HTTP クライアントなど、ブロッキングする可能性のある I/O 操作を行う関数は、渡された Context の `Done()` チャネルを監視し、キャンセルされれば処理を中断します。\n\nこのように Context をリクエスト処理の開始から終了まで一貫して引き回すことで、タイムアウトやクライアントからのキャンセル要求が、処理のどの段階にいても適切に伝播し、関連するすべての Goroutine が効率的に停止できるようになります。\n\n**コード解説:**\n\n*   `handleRequest` は `r.Context()` でリクエストの Context を取得し、`context.WithTimeout` でタイムアウトを設定した `ctxWithTimeout` を作成します。\n*   `processLogic` は `ctxWithTimeout` を受け取り、それをそのまま `callExternalAPI` に渡します。\n*   `callExternalAPI` は渡された Context (`ctx`) の `Done()` チャネルを `select` で監視します。\n*   `main` 関数で設定されたタイムアウト (200ms) は、`handleRequest` -> `processLogic` -> `callExternalAPI` へと伝播します。`callExternalAPI` 内の `time.After(150 * time.Millisecond)` はタイムアウト内に完了しますが、もしこれが 200ms より長ければ、`<-ctx.Done()` が先に発生し、`context.DeadlineExceeded` エラーが返され、呼び出し元に伝播していきます。\n\nこのように、Context を呼び出しスタックを通じて適切に伝播させることで、リクエスト全体のライフサイクル（タイムアウトやキャンセル）を一貫して管理することができます。\n\n**実行方法と結果:**\n\nサーバー起動後、 `http://localhost:8080/` にアクセスすると、\nコンソールに以下のようなログが出力され、ブラウザにはエラーが表示されます。",
      "code": "package main\n\nimport (\n\t\"context\"\n\t\"errors\" // errors パッケージをインポート\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// 下位の処理 (例: 外部 API 呼び出し)\nfunc callExternalAPI(ctx context.Context, param string) (string, error) {\n\tfmt.Printf(\"  (外部API呼び出し '%s' 開始...)\\n\", param)\n\tselect {\n\tcase <-time.After(150 * time.Millisecond): // API 応答に時間がかかると仮定\n\t\tfmt.Printf(\"  (外部API呼び出し '%s' 成功)\\n\", param)\n\t\treturn fmt.Sprintf(\"API結果(%s)\", param), nil\n\tcase <-ctx.Done(): // ★ Context のキャンセルをチェック\n\t\tfmt.Printf(\"  (外部API呼び出し '%s' キャンセル: %v)\\n\", param, ctx.Err())\n\t\treturn \"\", ctx.Err()\n\t}\n}\n\n// 中間の処理 (Context を受け取り、下位に渡す)\nfunc processLogic(ctx context.Context, data string) (string, error) {\n\tfmt.Printf(\" 中間処理 '%s' 開始...\\n\", data)\n\t// ★ 受け取った ctx をそのまま callExternalAPI に渡す ★\n\tresult, err := callExternalAPI(ctx, data)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"中間処理失敗: %w\", err)\n\t}\n\tprocessedResult := fmt.Sprintf(\"処理済み: %s\", result)\n\tfmt.Printf(\" 中間処理 '%s' 完了\\n\", data)\n\treturn processedResult, nil\n}\n\n// HTTP ハンドラ (リクエストの起点)\nfunc handleRequest(w http.ResponseWriter, r *http.Request) {\n\tfmt.Println(\"\\n--- リクエスト受信 ---\")\n\t// リクエストから Context を取得 (ミドルウェアで値が追加されている可能性もある)\n\tctx := r.Context()\n\n\t// このリクエスト処理全体のタイムアウトを設定 (例: 200ms)\n\tctxWithTimeout, cancel := context.WithTimeout(ctx, 200*time.Millisecond)\n\tdefer cancel() // ハンドラ終了時に cancel を呼ぶ\n\n\t// ★ タイムアウト付き Context を下位の処理に渡す ★\n\tresult, err := processLogic(ctxWithTimeout, \"input-data\")\n\tif err != nil {\n\t\t// エラーの種類に応じて適切なステータスコードを返す\n\t\tstatusCode := http.StatusInternalServerError\n\t\tif errors.Is(err, context.DeadlineExceeded) {\n\t\t\tstatusCode = http.StatusGatewayTimeout // タイムアウトの場合\n\t\t}\n\t\thttp.Error(w, err.Error(), statusCode)\n\t\tfmt.Printf(\"--- リクエスト処理エラー: %v ---\\n\", err)\n\t\treturn\n\t}\n\n\t// 成功レスポンス\n\tfmt.Fprintf(w, \"成功: %s\", result)\n\tfmt.Println(\"--- リクエスト処理成功 ---\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handleRequest)\n\tfmt.Println(\"サーバーをポート :8080 で起動します...\")\n\t// エラーハンドリングを追加\n\terr := http.ListenAndServe(\":8080\", nil)\n\tif err != nil {\n\t\tfmt.Printf(\"サーバー起動エラー: %v\\n\", err)\n\t}\n}"
    },
    {
      "title": "\"ミドルウェアでの Context 利用\"",
      "description": "",
      "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// キーの型とキー\ntype contextKey string\nconst requestTimeKey contextKey = \"requestTime\"\nconst requestIDKey contextKey = \"requestID\" // 200_context-with-values.md の例から\n\n// リクエスト時刻とIDを追加するミドルウェア\nfunc loggingMiddleware(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tstartTime := time.Now()\n\t\treqID := fmt.Sprintf(\"req-%d\", startTime.UnixNano()) // 簡単なID生成\n\n\t\t// 元の Context を取得\n\t\tctx := r.Context()\n\t\t// 値を追加して新しい Context を生成\n\t\tctx = context.WithValue(ctx, requestTimeKey, startTime)\n\t\tctx = context.WithValue(ctx, requestIDKey, reqID)\n\n\t\tfmt.Printf(\"[%s] ミドルウェア: リクエスト受信 (%s)\\n\", reqID, r.URL.Path)\n\n\t\t// 新しい Context を持つリクエストで次のハンドラを呼び出す\n\t\tnext.ServeHTTP(w, r.WithContext(ctx))\n\n\t\t// レスポンスが返された後の処理 (例: 処理時間ログ)\n\t\tduration := time.Since(startTime)\n\t\tfmt.Printf(\"[%s] ミドルウェア: 処理完了 (%s, duration: %v)\\n\", reqID, r.URL.Path, duration)\n\t})\n}\n\n// Context から値を取得するハンドラ\nfunc myHandler(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\treqID, _ := ctx.Value(requestIDKey).(string)\n\tstartTime, _ := ctx.Value(requestTimeKey).(time.Time)\n\n\tfmt.Printf(\"[%s] ハンドラ: 処理開始 (リクエスト時刻: %s)\\n\", reqID, startTime.Format(time.RFC3339Nano))\n\ttime.Sleep(50 * time.Millisecond) // 処理をシミュレート\n\tfmt.Fprintf(w, \"[%s] Hello!\", reqID)\n}\n\nfunc main() {\n\tfinalHandler := http.HandlerFunc(myHandler)\n\t// ミドルウェアでハンドラをラップ\n\thttp.Handle(\"/\", loggingMiddleware(finalHandler))\n\n\tfmt.Println(\"サーバーをポート :8080 で起動します...\")\n\t// エラーハンドリングを追加\n\terr := http.ListenAndServe(\":8080\", nil)\n\tif err != nil {\n\t\tfmt.Printf(\"サーバー起動エラー: %v\\n\", err)\n\t}\n}\n\n/*\nサーバー起動後、 http://localhost:8080/ にアクセスすると、\nコンソールに以下のようなログが出力される (IDと時刻は実行ごとに変わる):\n\n[req-1711644000123456789] ミドルウェア: リクエスト受信 (/)\n[req-1711644000123456789] ハンドラ: 処理開始 (リクエスト時刻: 2025-03-29T01:56:00.123456789+09:00)\n[req-1711644000123456789] ミドルウェア: 処理完了 (/, duration: 50.XXXms)\n*/"
    },
    {
      "title": "タイムアウト Context を使ったテスト",
      "description": "",
      "code": "package processor_test // テスト対象とは別パッケージ\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"testing\" // testing パッケージ\n\t\"time\"\n\n\t\"myproject/processor\" // テスト対象パッケージ (パスは例)\n)\n\n// 正常系: タイムアウトしない\nfunc TestProcessDataWithContext_Success(t *testing.T) {\n\t// 処理時間(150ms想定)より長いタイムアウト(500ms)\n\tctx, cancel := context.WithTimeout(context.Background(), 500*time.Millisecond)\n\tdefer cancel()\n\n\t_, err := processor.ProcessDataWithContext(ctx, \"test-success\")\n\tif err != nil { // エラーが発生しないことを期待\n\t\tt.Errorf(\"予期せぬエラー: %v\", err)\n\t}\n}\n\n// 異常系: タイムアウトする\nfunc TestProcessDataWithContext_Timeout(t *testing.T) {\n\t// 処理時間(150ms想定)より短いタイムアウト(50ms)\n\tctx, cancel := context.WithTimeout(context.Background(), 50*time.Millisecond)\n\tdefer cancel()\n\n\t_, err := processor.ProcessDataWithContext(ctx, \"test-timeout\")\n\n\t// エラーが発生することを期待\n\tif err == nil {\n\t\tt.Fatal(\"タイムアウトエラーが発生しませんでした\")\n\t}\n\t// ★ エラーが DeadlineExceeded であることを確認 ★\n\tif !errors.Is(err, context.DeadlineExceeded) {\n\t\tt.Errorf(\"期待したエラーは DeadlineExceeded ですが、実際は %v\", err)\n\t}\n}\n\n// --- テスト対象の関数 (例: processor/processor.go) ---\n/*\npackage processor\nimport (\"context\"; \"time\"; \"fmt\")\nfunc ProcessDataWithContext(ctx context.Context, data string) (string, error) {\n\tselect {\n\tcase <-time.After(150 * time.Millisecond): // 150ms かかる処理\n\t\treturn \"processed: \" + data, nil\n\tcase <-ctx.Done(): // キャンセルチェック\n\t\treturn \"\", ctx.Err()\n\t}\n}\n*/"
    },
    {
      "title": "キャンセル Context を使ったテスト",
      "description": "",
      "code": "package processor_test\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n\n\t\"myproject/processor\" // テスト対象パッケージ (パスは例)\n)\n\n// テスト: 明示的にキャンセルする場合\nfunc TestProcessDataWithContext_Cancel(t *testing.T) {\n\t// キャンセル可能な Context を作成\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel() // テスト終了時に確実に解放\n\n\terrChan := make(chan error, 1) // 結果受け取り用チャネル\n\n\t// テスト対象関数を Goroutine で実行\n\tgo func() {\n\t\t_, err := processor.ProcessDataWithContext(ctx, \"test-cancel\")\n\t\terrChan <- err\n\t}()\n\n\t// 少し待ってからキャンセルを実行 (処理時間より短く)\n\ttime.Sleep(50 * time.Millisecond)\n\tfmt.Println(\"Test: cancel() 呼び出し...\")\n\tcancel() // ★ Context をキャンセル\n\n\t// 結果を検証 (タイムアウト付きで待つのがより安全)\n\tselect {\n\tcase err := <-errChan:\n\t\tif err == nil { // エラーが発生することを期待\n\t\t\tt.Fatal(\"キャンセルエラーが発生しませんでした\")\n\t\t}\n\t\t// ★ エラーが Canceled であることを確認 ★\n\t\tif !errors.Is(err, context.Canceled) {\n\t\t\tt.Errorf(\"期待エラーは Canceled ですが、実際は %v\", err)\n\t\t} else {\n\t\t\tfmt.Println(\"Test: 期待通りキャンセルされました\")\n\t\t}\n\tcase <-time.After(1 * time.Second): // テスト自体のタイムアウト\n\t\tt.Fatal(\"テストがタイムアウトしました\")\n\t}\n}\n\n// --- テスト対象の関数 (例: processor/processor.go) ---\n/*\npackage processor\nimport (\"context\"; \"time\"; \"fmt\")\nfunc ProcessDataWithContext(ctx context.Context, data string) (string, error) {\n\tselect {\n\tcase <-time.After(150 * time.Millisecond): // 150ms かかる処理\n\t\treturn \"processed: \" + data, nil\n\tcase <-ctx.Done(): // キャンセルチェック\n\t\treturn \"\", ctx.Err()\n\t}\n}\n*/"
    },
    {
      "title": "Context のテスト (モックは通常不要)",
      "description": "",
      "code": "// Context のテストでは通常モックは不要。\n// 標準の context.WithCancel や context.WithTimeout を使う。\n\n// 例 (タイムアウトテスト):\n// ctx, cancel := context.WithTimeout(context.Background(), 50*time.Millisecond)\n// defer cancel()\n// err := functionUnderTest(ctx)\n// if !errors.Is(err, context.DeadlineExceeded) { /* エラー処理 */ }\n\n// 例 (キャンセルテスト):\n// ctx, cancel := context.WithCancel(context.Background())\n// defer cancel()\n// go func() { time.Sleep(50*time.Millisecond); cancel() }()\n// err := functionUnderTest(ctx)\n// if !errors.Is(err, context.Canceled) { /* エラー処理 */ }\n\n// 例 (値テスト):\n// ctx := context.WithValue(context.Background(), myKey, testValue)\n// functionUnderTest(ctx)\n// // (必要なら functionUnderTest 内での値利用を検証)"
    }
  ]
}