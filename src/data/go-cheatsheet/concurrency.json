{
  "title": "Concurrency",
  "codeExamples": [
    {
      "title": "Goroutines",
      "code": "// Goroutines are lightweight threads managed by the Go runtime\n\n// Start a goroutine\ngo func() {\n  // code runs concurrently\n  fmt.Println(\"Running in goroutine\")\n}()\n\n// Run a function in a goroutine\ngo myFunction(arg1, arg2)\n\n// Main continues execution\nfmt.Println(\"Main function continues\")\n\n// Wait for goroutines to finish (simplest way)\ntime.Sleep(time.Second)  // Not reliable for production\n\n// Best practice: use synchronization primitives\nvar wg sync.WaitGroup\n\nwg.Add(1)  // Add a counter for one goroutine\ngo func() {\n  defer wg.Done()  // Decrement counter when goroutine finishes\n  // Do work...\n}()\n\nwg.Wait()  // Wait until counter becomes zero\n\n// Creating multiple goroutines\nfor i := 0; i < 5; i++ {\n  i := i  // Create a new variable to avoid closure issues\n  wg.Add(1)\n  go func() {\n    defer wg.Done()\n    fmt.Println(\"Goroutine\", i)\n  }()\n}\nwg.Wait()"
    },
    {
      "title": "Channels",
      "code": "// Channels are typed conduits for communication between goroutines\n\n// Create a channel\nch := make(chan int)       // unbuffered\nbuffCh := make(chan int, 10)  // buffered (capacity 10)\n\n// Send to channel (arrow points to channel)\nch <- 42  // blocks if unbuffered channel or if buffered channel is full\n\n// Receive from channel (arrow points from channel)\nvalue := <-ch  // blocks if channel is empty\n\n// Close a channel (sender should close)\nclose(ch)\n\n// Check if channel is closed\nvalue, ok := <-ch  // ok is false if channel closed and empty\n\n// Range over channel (terminates when channel is closed)\nfor value := range ch {\n  // process value\n}\n\n// Directional channels (type restrictions)\nfunc producer(ch chan<- int) {  // can only send to channel\n  ch <- 42\n}\n\nfunc consumer(ch <-chan int) {  // can only receive from channel\n  value := <-ch\n}\n\n// Channel patterns\n// Worker pool\nfunc worker(id int, jobs <-chan int, results chan<- int) {\n  for j := range jobs {\n    results <- j * 2  // do work\n  }\n}\n\njobs := make(chan int, 100)\nresults := make(chan int, 100)\n\n// Start 3 workers\nfor w := 1; w <= 3; w++ {\n  go worker(w, jobs, results)\n}\n\n// Send jobs and collect results\nfor j := 1; j <= 9; j++ {\n  jobs <- j\n}\nclose(jobs)"
    },
    {
      "title": "Select",
      "code": "// Select statement lets you wait on multiple channel operations\n\nselect {\ncase value := <-ch1:\n  // handle value from ch1\ncase ch2 <- value:\n  // sent value to ch2\ncase <-time.After(1 * time.Second):\n  // timeout after 1 second\ncase <-done:\n  // done channel closed, exit\n  return\ndefault:\n  // run if no channel is ready (non-blocking)\n}\n\n// Common patterns\n\n// Non-blocking channel operations\nselect {\ncase x := <-ch:\n  // use x\ndefault:\n  // channel not ready\n}\n\n// Timeout\nselect {\ncase res := <-ch:\n  // use res\ncase <-time.After(time.Second):\n  // timed out after 1 second\n}\n\n// Quit channel\nfunc worker(ch <-chan int, quit <-chan bool) {\n  for {\n    select {\n    case value := <-ch:\n      // process value\n    case <-quit:\n      fmt.Println(\"Quitting\")\n      return\n    }\n  }\n}\n\n// Multi-way select loop\nfor {\n  select {\n  case <-ch1:\n    // handle event 1\n  case <-ch2:\n    // handle event 2\n  case <-done:\n    return\n  }\n}"
    },
    {
      "title": "Mutex and Sync",
      "code": "// Mutual exclusion for safe concurrent access to shared data\nimport \"sync\"\n\n// Basic mutex usage\nvar (\n  mu    sync.Mutex\n  count int\n)\n\nfunc increment() {\n  mu.Lock()      // Lock before accessing shared data\n  defer mu.Unlock()  // Ensure unlock happens\n  count++\n}\n\n// Read-write mutex (multiple readers or one writer)\nvar rwmu sync.RWMutex\n\nfunc readData() {\n  rwmu.RLock()    // Multiple goroutines can hold read lock\n  defer rwmu.RUnlock()\n  // Read shared data...\n}\n\nfunc writeData() {\n  rwmu.Lock()     // Exclusive lock for writing\n  defer rwmu.Unlock()\n  // Modify shared data...\n}\n\n// Once - execute exactly once\nvar once sync.Once\n\nfunc initialize() {\n  once.Do(func() {\n    // Initialization code, runs exactly once\n  })\n}\n\n// WaitGroup - wait for a collection of goroutines\nvar wg sync.WaitGroup\n\nwg.Add(3)  // Set counter to 3\ngo func() {\n  defer wg.Done()  // Decrement counter\n  // Work 1\n}()\n// ... launch more goroutines\nwg.Wait()  // Block until counter is zero\n\n// Cond - condition variable for waiting on events\ncond := sync.NewCond(&sync.Mutex{})\n\n// Broadcasting\ncond.L.Lock()\n// Change state\ncond.Broadcast()  // Wake all waiters\ncond.L.Unlock()\n\n// Waiting\ncond.L.Lock()\nfor !condition() {\n  cond.Wait()  // Unlocks, waits, then locks again\n}\n// Use the condition\ncond.L.Unlock()"
    },
    {
      "title": "Atomic Operations",
      "code": "// Atomic operations for low-level synchronization\nimport \"sync/atomic\"\n\nvar counter atomic.Int64  // Go 1.19+\n\n// Add and get value\ncounter.Add(10)\nvalue := counter.Load()\n\n// Compare and swap\nswapped := counter.CompareAndSwap(10, 20)  // Set to 20 if value is 10\n\n// Store value\ncounter.Store(100)\n\n// In Go <1.19\nvar counter int64\n\n// Add and get\natomic.AddInt64(&counter, 10)\nvalue := atomic.LoadInt64(&counter)\n\n// Compare and swap\nswapped := atomic.CompareAndSwapInt64(&counter, 10, 20)\n\n// Store value\natomic.StoreInt64(&counter, 100)\n\n// Atomic pointer operations\nvar ptr atomic.Pointer[T]  // Go 1.19+\nptr.Store(&myStruct)\nvalue := ptr.Load()\nswapped := ptr.CompareAndSwap(oldPtr, newPtr)"
    },
    {
      "title": "Context",
      "code": "// Context carries deadlines, cancellation signals, and request-scoped values\nimport \"context\"\n\n// Creating contexts\n// Background context (root of all contexts)\nctx := context.Background()\n\n// WithCancel - cancellable context\nctx, cancel := context.WithCancel(context.Background())\ndefer cancel()  // Cancel when done\n\n// Timed contexts\nctx, cancel := context.WithTimeout(context.Background(), time.Second)\ndefer cancel()\n\nctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(time.Minute))\ndefer cancel()\n\n// Context values (for request-scoped data)\nctx = context.WithValue(ctx, \"key\", \"value\")\nvalue := ctx.Value(\"key\").(string)\n\n// Using context in functions\nfunc doWork(ctx context.Context) error {\n  select {\n  case <-time.After(100 * time.Millisecond):\n    return nil\n  case <-ctx.Done():\n    return ctx.Err()  // context.Canceled or context.DeadlineExceeded\n  }\n}\n\n// Cancellation\nctx, cancel := context.WithCancel(context.Background())\ngo func() {\n  time.Sleep(time.Second)\n  cancel()  // Signal cancellation\n}()\ndoWork(ctx)"
    }
  ]
}