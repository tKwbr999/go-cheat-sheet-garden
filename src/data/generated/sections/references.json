{
  "title": "References",
  "codeExamples": [
    {
      "title": "\"リファレンス: Go コマンドラインツール\"",
      "description": "",
      "code": "// このセクションにはGoのコード例はありません。\n// Goコマンドはターミナルで実行します。"
    },
    {
      "title": "\"リファレンス: Go 環境変数\"",
      "description": "Go のツールチェーン (`go` コマンドなど) の動作は、いくつかの**環境変数**によって制御・カスタマイズできます。これらの環境変数は、OS の設定や `go env -w` コマンドで設定できます。\n\n現在の設定値は **`go env`** コマンドで一覧表示できます。特定の変数の値だけを表示するには `go env <変数名>` を使います（例: `go env GOPATH`）。\n\nここでは、特に重要な環境変数をいくつか紹介します。\n\n## 主要な Go 環境変数\n\n*   **`GOOS` と `GOARCH`**:\n    *   `go build` で生成する実行可能ファイルの**ターゲットオペレーティングシステム (`GOOS`)** と**アーキテクチャ (`GOARCH`)** を指定します。\n    *   これにより、例えば macOS 上で Windows 用や Linux 用の実行可能ファイルを簡単に作成（クロスコンパイル）できます。\n    *   設定可能な値の組み合わせは `go tool dist list` で確認できます。\n    *   例:\n        *   Windows 64bit 向け: `GOOS=windows GOARCH=amd64 go build`\n        *   Linux ARM 64bit 向け: `GOOS=linux GOARCH=arm64 go build`\n    *   設定しない場合は、現在の OS とアーキテクチャがデフォルト値となります。\n\n*   **`GOPATH`**:\n    *   Go Modules 導入以前（Go 1.11 より前）に、Go のワークスペース（ソースコードやビルドされたパッケージが置かれる場所）を指定するために使われていました。\n    *   Go Modules が主流の現在では、その重要性は低下しています。通常は設定する必要はなく、デフォルトの場所（通常はホームディレクトリ以下の `go` ディレクトリ、例: `$HOME/go`）が使われます。\n    *   `go install` でインストールされたバイナリは `$GOPATH/bin` (または `$GOBIN`) に置かれます。\n\n*   **`GOROOT`**:\n    *   Go の**インストールディレクトリ**を示します。標準ライブラリのソースコードなどがここにあります。\n    *   通常、Go をインストールする際に自動的に設定され、ユーザーが手動で変更する必要はほとんどありません。\n\n*   **`GOBIN`**:\n    *   `go install` コマンドでビルドされた実行可能ファイルがインストールされるディレクトリを指定します。\n    *   設定されていない場合は、`$GOPATH/bin` がデフォルトで使われます。\n    *   このディレクトリに PATH を通しておくと、インストールした Go 製ツールをコマンド名だけで実行できるようになります。\n\n*   **`GO111MODULE`**:\n    *   Go Modules の有効/無効を制御します。\n        *   `on`: Go Modules を常に有効にします。\n        *   `off`: Go Modules を無効にし、古い `GOPATH` モードで動作します。\n        *   `auto` (デフォルト): カレントディレクトリまたは親ディレクトリに `go.mod` ファイルが存在する場合に Go Modules を有効にします。\n    *   Go 1.16 以降ではデフォルトで `on` (または `auto` で `go.mod` があれば `on`) になるため、通常は明示的に設定する必要はありません。\n\n*   **`GOPROXY`**:\n    *   Go Modules をダウンロードする際に使用する**モジュールプロキシ**の URL を指定します。デフォルトは `https://proxy.golang.org,direct` で、まず Google が運営するプロキシにアクセスし、見つからなければ直接リポジトリ（GitHubなど）にアクセスします。\n    *   企業内などで独自のプロキシサーバーを使いたい場合に設定します。`direct` を指定するとプロキシを使わず直接アクセスします。`off` を指定すると `GOPATH` 内のみを探します。\n\n*   **`GOPRIVATE`, `GONOPROXY`, `GONOSUMDB`**:\n    *   プライベートなリポジトリ（例: GitHub Enterprise や社内 Git サーバー）にあるモジュールを扱う際に、プロキシやチェックサムデータベース (`sum.golang.org`) の対象外とするモジュールパスのパターンを指定します。\n\n*   **`GOFLAGS`**:\n    *   `go` コマンド（`build`, `test`, `run` など）を実行する際に、**常に適用されるフラグ**を指定します。例えば、常に `-tags=mytag` を付けたい場合などに設定します。\n\n*   **`CGO_ENABLED`**:\n    *   C言語のコードを利用する Cgo 機能を有効にするか (`1`) 無効にするか (`0`) を指定します。\n    *   クロスコンパイル時に Cgo を無効にしたい場合（例: `CGO_ENABLED=0 GOOS=linux go build`）などによく使われます。\n\n## 設定方法の例 (macOS/Linux)",
      "code": "// このセクションにはGoのコード例はありません。\n// 環境変数はOSのシェルや `go env -w` コマンドで設定します。"
    },
    {
      "title": "\"コードスタイル: 変数 (Variables)\"",
      "description": "Goのコードスタイルは、読みやすさと簡潔さを重視します。変数に関する一般的な慣習とスタイルガイドラインは以下の通りです。\n\n## 変数名\n\n*   **キャメルケース (Camel Case):** 複数の単語からなる変数名は、`userCount`, `maxRetries`, `requestBody` のようにキャメルケースを使います。アンダースコア (`_`) は通常使いません。\n*   **短く、しかし明確に:** 変数名は、その役割が明確にわかる範囲で、できるだけ短くするのが好まれます。\n    *   スコープが狭い（数行程度でしか使われない）場合は、`i`, `j` (ループカウンタ), `r` (Reader), `w` (Writer), `b` (byte スライス), `err` (エラー) のような短い名前が慣習的に使われます。\n    *   スコープが広い場合や、より複雑な意味を持つ場合は、`userCount`, `httpClient`, `requestURL` のように、より説明的な名前を使います。\n*   **エクスポートされる変数:** パッケージ外に公開される変数（パッケージレベルで宣言され、大文字で始まる）は、その意味が明確にわかる名前を付け、必要であればドキュメンテーションコメントを追加します。\n*   **頭字語 (Acronyms):** `userID`, `htmlContent`, `jsonEncoder` のように、頭字語は一貫して大文字または小文字にします（例: `UserID` や `HTMLContent` は良いが、`UserId` や `HtmlContent` は避ける）。ただし、`Id` を `ID` とするかどうかは議論があり、プロジェクトやチームの規約に従うのが一般的です。\n\n## 宣言と初期化\n\n*   **`:=` (短縮変数宣言):** 関数内で変数を宣言し、同時に初期値を代入する場合に最もよく使われます。型は初期値から推論されます。（上記「コード」セクション参照）\n*   **`var` 宣言:**\n    *   初期値を指定せずに変数を宣言する場合（ゼロ値で初期化される）。\n    *   変数の型を明示したい場合。\n    *   パッケージレベルで変数を宣言する場合（`:=` は関数内でしか使えない）。\n    *   複数の変数をまとめて宣言する場合（グループ化）。",
      "code": "import \"os\" // os.Open を使うため\n\ncount := 0\nmessage := \"Hello\"\nfile, err := os.Open(\"file.txt\") // os パッケージのインポートが必要な例\n// エラーチェックは省略 (例示のため)\nif err == nil {\n\tdefer file.Close() // ファイルを閉じるのを忘れない\n}"
    },
    {
      "title": "\"コードスタイル: 定数 (Constants)\"",
      "description": "**定数 (Constant)** は、プログラム実行中に値が変わらない識別子です。Goでは `const` キーワードを使って宣言します。\n\n## 定数名\n\n*   **キャメルケース (Camel Case):** Goの定数名は、**変数と同様にキャメルケース** (`maxConnections`, `defaultTimeout`) を使うのが**一般的**です。\n*   **エクスポート:** パッケージ外に公開する定数は、変数と同様に名前の最初の文字を大文字にします (`MaxConnections`)。非公開なら小文字で始めます (`maxRetries`)。\n*   **すべて大文字は非推奨:** 他の言語で定数によく使われる `ALL_CAPS_WITH_UNDERSCORES` (例: `MAX_CONNECTIONS`) は、**Goの慣習ではありません**。Goではキャメルケースを使用してください。\n\n## 宣言\n\n*   **`const` キーワード:** `const` キーワードを使って宣言します。\n*   **型指定:** 定数は型を持つことができますが、多くの場合、型は初期値から推論されるため省略可能です（型付けなし定数）。型付けなし定数は、より柔軟に扱える利点があります。\n*   **初期値:** 定数は宣言時に必ず値を設定する必要があります。値はコンパイル時に決定できる必要があります（例: 数値リテラル、文字列リテラル、`true`/`false`、他の定数を使った式など）。\n*   **グループ化:** `var` と同様に `const (...)` で複数の定数をまとめて宣言できます。（上記「コード」セクション参照）\n\n## `iota`\n\n`iota` は、`const` 宣言ブロック内で使われる特別な定数ジェネレータです。`iota` は `const` ブロックが登場するたびに `0` にリセットされ、ブロック内の各 `const` 指定（行）ごとに `1` ずつ増加します。連続する定数値を生成するのに便利です。",
      "code": "package config // 例として config パッケージ\n\nimport \"time\"\n\n// パッケージレベルで定数を宣言\nconst defaultPort = 8080 // 型付けなし整数定数 (int になる)\nconst defaultHost = \"localhost\" // 型付けなし文字列定数 (string になる)\n\n// グループ化して宣言\nconst (\n\tStatusOK         = 200 // 型付けなし整数定数\n\tStatusNotFound   = 404\n\tdefaultTimeout   = 30 * time.Second // 型付けなし duration 定数 (time.Duration になる)\n\tMaxIdleConns int = 100              // 型を明示した整数定数 (int)\n)\n\n// エクスポートされる定数 (大文字始まり)\nconst Version = \"v1.2.0\"\n\n// 非公開の定数 (小文字始まり)\nconst internalKey = \"some-internal-value\"\n\n// 非推奨な命名 (Go では使わない)\n// const DEFAULT_PORT = 8080"
    },
    {
      "title": "\"コードスタイル: 関数とメソッド (Functions and Methods)\"",
      "description": "関数とメソッドは Go プログラムの基本的な構成要素です。読みやすく、保守しやすいコードを書くために、以下のスタイルガイドラインに従うことが推奨されます。\n\n## 名前付け\n\n*   **キャメルケース (Camel Case / MixedCaps):** 関数名やメソッド名は、変数や定数と同様にキャメルケースを使います。アンダースコア (`_`) は通常使いません。\n    *   良い例: `getUser`, `CalculateTotal`, `parseRequest`, `ConnectToDatabase`\n    *   悪い例: `get_user`, `calculatetotal`, `Connect_To_Database`\n*   **エクスポート:**\n    *   パッケージ外に公開する関数やメソッドは、名前の最初の文字を**大文字**にします (例: `CalculateTotal`)。\n    *   パッケージ内部でのみ使う関数やメソッドは、名前の最初の文字を**小文字**にします (例: `calculateSubtotal`)。\n*   **明確かつ簡潔に:** 関数名やメソッド名は、その処理内容を明確に、かつ簡潔に表すようにします。動詞または動詞句で始めることが多いです (例: `GetUser`, `Save`, `Validate`)。\n\n## 関数の責務と長さ\n\n*   **単一責任の原則:** 一つの関数は、一つの明確な責務を持つように設計します。複数の異なる処理を一つの大きな関数に詰め込むのは避けましょう。\n*   **短く保つ:** 関数はできるだけ短く、理解しやすい長さに保つように心がけます。数十行を超えるような長い関数は、より小さなヘルパー関数に分割することを検討します。\n\n## 引数と戻り値\n\n*   **引数の型:** （上記「コード」セクション参照）\n*   **エラー処理:** エラーが発生する可能性のある関数は、通常、**最後の戻り値**として `error` 型を返します。成功した場合は `nil` を返します。",
      "code": "// 同じ型の引数が続く場合は型をまとめることができる\nfunc process(id int, name string, age int, city string) // OK\nfunc process(id, age int, name, city string)       // より簡潔"
    },
    {
      "title": "\"コードスタイル: インターフェース (Interfaces)\"",
      "description": "インターフェースは Go のポリモーフィズム（多態性）を実現する中心的な機能であり、柔軟で疎結合なコードを書くために不可欠です。インターフェースの設計と使い方に関する Go の慣習とスタイルは以下の通りです。\n\n## インターフェース名\n\n*   **`-er` サフィックス:** 単一のメソッドを持つインターフェースの名前は、そのメソッド名に `-er` を付けるのが強い慣習です。これは、そのインターフェースが「～するもの」という能力を表すことを示唆します。\n    *   `Read() ...` メソッドを持つ -> `Reader` (`io.Reader`)\n    *   `Write() ...` メソッドを持つ -> `Writer` (`io.Writer`)\n    *   `ServeHTTP(...)` メソッドを持つ -> `Handler` (`http.Handler`)\n    *   `String() string` メソッドを持つ -> `Stringer` (`fmt.Stringer`)\n*   **複数のメソッド:** 複数のメソッドを持つインターフェースには、必ずしも `-er` を付ける必要はありません。そのインターフェースが表現する概念を表す名前を付けます（例: `sort.Interface`, `database/sql.DB`）。\n*   **`I` プレフィックスは不要:** 他の言語で見られるような `IMyInterface` のようなプレフィックスは Go では使いません。\n\n## インターフェースのサイズ\n\n*   **小さく保つ (Interface Segregation Principle):** Go では、**小さなインターフェース**（メソッド数が少ない、理想的には1つ）を組み合わせることが推奨されます。大きなインターフェースは、実装する側に多くの負担を強いるだけでなく、不必要な依存関係を生み出す可能性があります。\n*   必要なメソッドだけを持つ小さなインターフェースを定義することで、実装の柔軟性が高まり、モック化も容易になります。",
      "code": "// 単一メソッドの例\ntype Reader interface {\n\tRead(p []byte) (n int, err error)\n}\n\ntype Writer interface {\n\tWrite(p []byte) (n int, err error)\n}\n\n// 複数のメソッドの例\ntype ReadWriter interface {\n\tReader // インターフェースの埋め込み\n\tWriter\n}\n\ntype Shape interface {\n    Area() float64\n    Perimeter() float64\n}"
    },
    {
      "title": "\"コードスタイル: エラーハンドリング (Error Handling)\"",
      "description": "Go言語のエラーハンドリングは、他の多くの言語の例外処理 (`try-catch`) とは異なり、**エラーを通常の戻り値として扱う**ことを基本としています。このアプローチは、コードの制御フローを明確にし、エラー処理を強制する効果があります。\n\n## 基本原則: エラーは値、明示的にチェックする\n\n*   **エラーは値:** `error` は組み込みのインターフェース型であり、他の値と同様に扱われます。\n*   **明示的なチェック:** エラーを返す可能性のある関数を呼び出した後は、**必ず戻り値のエラーをチェック**します。Goには例外がないため、チェックを怠るとエラーが見過ごされ、プログラムが予期せぬ動作をする可能性があります。\n*   **`if err != nil` パターン:** 最も基本的なエラーチェックの方法です。関数呼び出しの直後に `if err != nil` ブロックを書き、エラーが発生した場合の処理（ログ出力、エラーのラップ、早期リターンなど）を記述します。（上記「コード」セクション参照）\n*   **早期リターン:** エラーが発生した場合は、できるだけ早く関数から `return` する（早期リターン）ことで、正常系のコードのネストを浅く保ち、可読性を高めます。\n\n## エラーメッセージとコンテキスト\n\n*   **エラーメッセージは明確に:** `errors.New` や `fmt.Errorf` でエラーを作成する際は、何が問題だったのかが分かるような明確なメッセージを記述します。\n*   **コンテキストの追加 (`%w`):** 下位の関数から返されたエラーを上位の関数でラップして返す場合、**`fmt.Errorf` の `%w` 動詞を使って元のエラーをラップ**します。これにより、エラーの原因を追跡しやすくなり、`errors.Is` や `errors.As` による判定が可能になります。",
      "code": "import (\n\t\"fmt\"\n\t\"log\" // log.Printf を使うため\n)\n\n// エラーを返す可能性のある関数の例 (仮)\nfunc potentiallyFailingFunction() (string, error) {\n\t// return \"\", errors.New(\"何か問題が発生\") // エラーの場合\n\treturn \"成功時の値\", nil // 成功の場合\n}\n\nfunc main() { // main 関数内で実行する例\n\tvalue, err := potentiallyFailingFunction()\n\tif err != nil {\n\t\t// エラー処理 (例: ログ出力、エラーをラップして return)\n\t\tlog.Printf(\"エラーが発生しました: %v\", err)\n\t\t// main 関数なので return せずに終了する例\n\t\t// return fmt.Errorf(\"処理失敗: %w\", err) // 通常の関数ならこのようにラップして返す\n\t\treturn\n\t}\n\t// 正常系の処理 (err == nil が保証される)\n\tfmt.Println(\"成功:\", value)\n}"
    },
    {
      "title": "\"コードスタイル: コメント (Comments)\"",
      "description": "Goのコードにおけるコメントは、コードの意図を伝え、可読性を高めるために重要です。Goでは主に2種類のコメントが使われます。\n\n## ドキュメンテーションコメント (Documentation Comments)\n\n*   **目的:** パッケージ、型、関数、メソッド、定数、変数など、**エクスポートされる（公開される）識別子**の役割や使い方を説明するために使われます。\n*   **形式:** コメント対象の識別子の**直前**に、空行を挟まずに `//` で始まるコメント行を記述します。\n*   **書き出し:** コメントの最初の文は、**コメント対象の識別子名で始まる**完全な文（主語＋述語）にするのが強い慣習です。これにより `godoc` が生成するドキュメントが読みやすくなります。\n    *   例: `// User はシステム内のユーザーを表します。`\n    *   例: `// CalculateTotal はアイテムの合計金額を計算して返します。`\n*   **内容:** 何をするのか (What)、なぜそうするのか (Why)、どのように使うのか (How) を簡潔に説明します。自明なことを繰り返すコメントは避けます。\n*   **パッケージコメント:** パッケージ全体の説明は、`package` 宣言の直前に記述します (`// Package mypkg は ...`)。 (`070_packages/020_package-documentation.md` 参照)\n*   **`godoc`:** ドキュメンテーションコメントは `go doc` コマンドや `pkg.go.dev` によって自動的に抽出・整形され、APIドキュメントとして利用されます。（上記「コード」セクション参照）\n\n## 実装コメント (Implementation Comments)\n\n*   **目的:** コードブロックや特定の行について、その**実装の詳細**、**複雑なロジックの意図**、**注意点**、**将来的な改善点 (TODO)** などを説明するために使われます。\n*   **形式:** `//` (行コメント) または `/* ... */` (ブロックコメント) を使います。通常は `//` が好まれます。\n*   **場所:** 説明が必要なコードの近くに記述します。\n*   **内容:** なぜそのように実装したのか (Why) を説明することが重要です。コードが何をしているか (What) をそのまま説明するだけのコメントは、コード自体を読めばわかるため、冗長になることがあります。",
      "code": "package user // 例として user パッケージ\n\nimport \"fmt\"\n\n// User はシステム内のユーザーを表す構造体です。\n// Name と Age フィールドを持ちます。\ntype User struct {\n\tName string\n\tAge  int\n}\n\n// NewUser は新しい User インスタンスを作成して返します。\n// name が空の場合はエラーを返します。\nfunc NewUser(name string, age int) (*User, error) {\n\tif name == \"\" {\n\t\treturn nil, fmt.Errorf(\"ユーザー名は空にできません\")\n\t}\n\t// 実装コメント: 年齢チェックはここでは行わない (将来追加するかも)\n\treturn &User{Name: name, Age: age}, nil\n}\n\n// String は User の文字列表現を返します (fmt.Stringer を満たす)。\nfunc (u *User) String() string {\n\tif u == nil {\n\t\treturn \"<nil>\"\n\t}\n\treturn fmt.Sprintf(\"%s (%d歳)\", u.Name, u.Age)\n}"
    },
    {
      "title": "\"コードスタイル: インデント (Indentation)\"",
      "description": "Go言語のコードスタイルにおいて、インデント（字下げ）に関するルールは非常にシンプルかつ厳格です。\n\n## ルール: インデントにはタブを使う\n\n*   Goのコードでは、インデントには**タブ文字 (`\\t`)** を使用します。スペース文字（通常2つや4つ）を使うことはありません。\n*   このルールは、Goの標準フォーマットツールである **`gofmt`** (または `go fmt` コマンド) によって**自動的に強制**されます。\n\n## `gofmt` / `go fmt` による自動フォーマット\n\nGoには `gofmt` という強力なコードフォーマッターが標準で付属しています (`go fmt` コマンドとして利用可能)。このツールを実行すると、インデント（タブの使用）、スペースの入れ方、括弧の位置、`import` の整理など、Goの標準的なコードスタイルに従ってソースコードが**自動的に整形**されます。\n\n**利点:**\n\n*   **スタイルの統一:** チームやプロジェクト全体でコードの見た目が統一され、読みやすさが向上します。\n*   **議論の不要化:** インデントをタブにするかスペースにするか、スペースなら何個にするか、といった**不毛なスタイル論争を避ける**ことができます。Goでは「`gofmt` が正義」です。\n*   **自動化:** エディタの保存時フックやCI/CDパイプラインに `go fmt` を組み込むことで、常にフォーマットされた状態を保つことができます。\n\n**使い方:**",
      "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tmessage := \"Hello, Go!\"\n\t// ↓ この行はタブでインデントされている\n\tif len(message) > 0 {\n\t\t// ↓ この行もタブでさらにインデントされている\n\t\tfmt.Println(message)\n\t\t// ↓ 同じレベルのインデント\n\t\tanotherVariable := true\n\t\tif anotherVariable {\n\t\t\t// ↓ さらにインデント\n\t\t\tfmt.Println(\"Indented with tabs\")\n\t\t}\n\t} // 対応する閉じ括弧は if と同じレベル\n}"
    },
    {
      "title": "\"ベストプラクティス: エラーを明示的に処理する\"",
      "description": "",
      "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n)\n\nfunc main() {\n\tfileName := \"my_data.txt\"\n\n\t// --- 悪い例: エラーを無視 ---\n\t// file, _ := os.Create(fileName) // エラーを変数 _ で受け取り、無視している\n\t// if file == nil {\n\t// \t// これではエラーの原因がわからない\n\t// \tlog.Println(\"ファイルの作成に失敗しました (原因不明)\")\n\t// \treturn\n\t// }\n\t// defer file.Close()\n\t// _, _ = file.WriteString(\"...\") // 書き込みエラーも無視\n\n\t// --- 良い例: エラーを明示的にチェック ---\n\tfile, err := os.Create(fileName)\n\t// ★ 必ずエラーをチェック ★\n\tif err != nil {\n\t\tlog.Printf(\"ファイルの作成に失敗しました: %v\", err)\n\t\treturn // または他の適切なエラー処理\n\t}\n\tdefer file.Close()\n\n\t_, err = file.WriteString(\"ファイルに書き込むデータ。\\n\")\n\t// ★ 書き込みエラーもチェック ★\n\tif err != nil {\n\t\tlog.Printf(\"ファイルへの書き込みに失敗しました: %v\", err)\n\t\t// 必要であれば、エラーをラップして呼び出し元に返すなども検討\n\t\t// return fmt.Errorf(\"書き込み失敗: %w\", err)\n\t}\n\n\tfmt.Println(\"ファイル操作が（おそらく）成功しました。\")\n\n\t// 後片付け\n\terr = os.Remove(fileName) // 削除エラーもチェックする方がより丁寧\n\tif err != nil {\n\t\tlog.Printf(\"ファイルの削除に失敗しました: %v\", err)\n\t}\n}"
    },
    {
      "title": "\"ベストプラクティス: 継承よりコンポジションを優先する\"",
      "description": "オブジェクト指向プログラミングに慣れていると、「継承 (Inheritance)」を使ってコードを再利用したり、is-a (〜は〜の一種である) 関係を表現したりすることがあります。しかし、Go言語には他の多くのオブジェクト指向言語に見られるような**クラス継承の仕組みがありません**。\n\nその代わりに、Goでは**コンポジション (Composition)**、特に**構造体の埋め込み (Embedding)** を使うことが推奨されます。これは \"has-a\" (〜は〜を持つ) 関係を表現し、より柔軟で疎結合な設計を促進します。\n\n## コンポジションと埋め込み\n\n*   **コンポジション:** ある型が、別の型の値を**フィールドとして持つ**ことです。",
      "code": "package main\n\nimport \"fmt\"\n\n// --- 埋め込まれる型: Logger ---\ntype Logger struct {\n\tPrefix string\n}\n\n// Logger のメソッド\nfunc (l *Logger) Log(message string) {\n\tfmt.Printf(\"%s %s\\n\", l.Prefix, message)\n}\n\n// --- 埋め込む型: Server ---\ntype Server struct {\n\tLogger // ★ Logger 型を埋め込む ★\n\tHost   string\n\tPort   int\n}\n\n// Server 独自のメソッド\nfunc (s *Server) Start() {\n\t// ★ 埋め込まれた Logger の Log メソッドを直接呼び出せる ★\n\ts.Log(fmt.Sprintf(\"サーバーを %s:%d で起動します...\", s.Host, s.Port))\n\t// 実際のサーバー起動処理...\n}\n\n// --- 埋め込む型: AdvancedServer (Server を埋め込む) ---\ntype AdvancedServer struct {\n\tServer // ★ Server 型をさらに埋め込む ★\n\tTLS    bool\n}\n\n// AdvancedServer 独自のメソッド (Server のメソッドをオーバーライドも可能)\nfunc (as *AdvancedServer) Start() {\n\t// 埋め込まれた Server の Log メソッドを呼び出す\n\tas.Log(\"AdvancedServer を起動します...\") // Prefix は AdvancedServer.Server.Logger.Prefix が使われる\n\tif as.TLS {\n\t\tas.Log(fmt.Sprintf(\"TLS 有効 (%s:%d)\", as.Host, as.Port))\n\t} else {\n\t\tas.Log(fmt.Sprintf(\"TLS 無効 (%s:%d)\", as.Host, as.Port))\n\t}\n\t// 実際の起動処理...\n\n\t// もし Server の Start を呼び出したい場合は明示的に行う\n\t// as.Server.Start() // これは再帰呼び出しになるので注意！\n}\n\n\nfunc main() {\n\t// --- Server の使用 ---\n\tserver := &Server{\n\t\tHost: \"localhost\",\n\t\tPort: 8080,\n\t\t// Logger フィールドはゼロ値 (Prefix=\"\") で初期化される\n\t}\n\t// 埋め込まれた Logger のフィールドにアクセス\n\tserver.Prefix = \"[BasicServer]\"\n\t// Server のメソッド呼び出し (内部で Logger.Log が呼ばれる)\n\tserver.Start()\n\t// 埋め込まれた Logger のメソッドを直接呼び出し\n\tserver.Log(\"BasicServer 処理完了\")\n\n\tfmt.Println(\"---\")\n\n\t// --- AdvancedServer の使用 ---\n\tadvServer := &AdvancedServer{\n\t\tServer: Server{ // 埋め込む Server を初期化\n\t\t\tHost: \"example.com\",\n\t\t\tPort: 443,\n\t\t\tLogger: Logger{ // Logger も初期化\n\t\t\t\tPrefix: \"[Advanced]\",\n\t\t\t},\n\t\t},\n\t\tTLS: true,\n\t}\n\t// AdvancedServer の Start メソッド呼び出し\n\tadvServer.Start()\n\t// 埋め込まれた Server からさらに埋め込まれた Logger のメソッドを呼び出し\n\tadvServer.Log(\"AdvancedServer 処理完了\") // as.Server.Logger.Log が呼ばれる\n\t// 埋め込まれた Server のフィールドにもアクセス可能\n\tfmt.Printf(\"AdvancedServer Host: %s\\n\", advServer.Host) // as.Server.Host と同じ\n}\n\n/* 実行結果:\n[BasicServer] サーバーを localhost:8080 で起動します...\n[BasicServer] BasicServer 処理完了\n---\n[Advanced] AdvancedServer を起動します...\n[Advanced] TLS 有効 (example.com:443)\n[Advanced] AdvancedServer 処理完了\nAdvancedServer Host: example.com\n*/"
    },
    {
      "title": "\"ベストプラクティス: 依存性注入 (DI) にインターフェースを使う\"",
      "description": "**依存性注入 (Dependency Injection, DI)** は、あるコンポーネント（例: `UserService`）が依存する別のコンポーネント（例: `UserRepository`）を、自身で生成するのではなく、**外部から与えられる（注入される）**ように設計する手法です。\n\nGoでは、この依存関係を表現するために**インターフェース**を使うことが非常に効果的であり、ベストプラクティスとされています。\n\n## なぜ DI にインターフェースを使うのか？\n\n*   **疎結合 (Loose Coupling):** コンポーネントが具体的な実装（例: `PostgresUserRepository`）ではなく、抽象的なインターフェース (`UserRepository`) に依存することで、両者の間の結合度が低くなります。`UserRepository` インターフェースを満たすものであれば、将来的に別の実装（例: `MySQLUserRepository`, `InMemoryUserRepository`）に**簡単に差し替える**ことができます。\n*   **テスト容易性 (Testability):** テスト時には、本番用の実装（例: 実際のデータベースにアクセスする `PostgresUserRepository`）の代わりに、テスト用の**モック実装 (Mock/Stub)** を注入することができます。これにより、外部依存なしにコンポーネント単体のロジックを簡単にテストできます。\n*   **柔軟性と拡張性:** 新しいデータストア実装を追加する場合でも、インターフェースを満たしていれば、既存の `UserService` コードを変更する必要がありません。\n\n## インターフェースを使った DI の実装パターン\n\n1.  **依存される側の機能をインターフェースとして定義:** 依存されるコンポーネントが提供すべきメソッドをインターフェースとして定義します（通常は利用側で定義します）。",
      "code": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t// service \"path/to/user/service\" // 仮のインポートパス\n\t// postgres \"path/to/user/postgres\" // 仮のインポートパス\n\t// memory \"path/to/user/memory\" // 仮のインポートパス\n)\n\n// --- インターフェース定義 (利用側) ---\ntype Notifier interface {\n\tNotify(message string) error\n}\n\n// --- 依存するコンポーネント ---\ntype OrderProcessor struct {\n\tnotifier Notifier // ★ インターフェース型のフィールド\n}\n\n// コンストラクタで依存性を注入\nfunc NewOrderProcessor(notifier Notifier) *OrderProcessor {\n\treturn &OrderProcessor{notifier: notifier}\n}\n\nfunc (p *OrderProcessor) ProcessOrder(orderID string) error {\n\tfmt.Printf(\"注文 %s を処理中...\\n\", orderID)\n\t// ... 注文処理ロジック ...\n\n\t// 処理完了を通知 (インターフェース経由で呼び出し)\n\tnotification := fmt.Sprintf(\"注文 %s の処理が完了しました。\", orderID)\n\terr := p.notifier.Notify(notification) // ★ 具体的な実装を知らない\n\tif err != nil {\n\t\t// 通知失敗時の処理 (例: ログ出力)\n\t\tlog.Printf(\"通知失敗 (注文 %s): %v\", orderID, err)\n\t\t// ここではエラーを返さないとする (通知は補助的な機能)\n\t}\n\treturn nil\n}\n\n// --- 具体的な実装 ---\n\n// EmailNotifier: メールで通知する実装\ntype EmailNotifier struct {\n\tAdminEmail string\n}\n\nfunc (n *EmailNotifier) Notify(message string) error {\n\tfmt.Printf(\"メール送信先 '%s': %s\\n\", n.AdminEmail, message)\n\t// 実際のメール送信処理...\n\treturn nil // 成功したとする\n}\n\n// SlackNotifier: Slack で通知する実装\ntype SlackNotifier struct {\n\tWebhookURL string\n}\n\nfunc (n *SlackNotifier) Notify(message string) error {\n\tfmt.Printf(\"Slack 送信先 '%s': %s\\n\", n.WebhookURL, message)\n\t// 実際の Slack 送信処理...\n\tif message == \"\" { return errors.New(\"空のメッセージは送信できません\") } // エラー例\n\treturn nil\n}\n\n// --- 組み立て (main) ---\nfunc main() {\n\t// --- EmailNotifier を注入 ---\n\temailNotifier := &EmailNotifier{AdminEmail: \"admin@example.com\"}\n\tprocessor1 := NewOrderProcessor(emailNotifier) // インターフェースを満たす EmailNotifier を渡す\n\tprocessor1.ProcessOrder(\"Order-A1\")\n\n\tfmt.Println(\"---\")\n\n\t// --- SlackNotifier を注入 ---\n\tslackNotifier := &SlackNotifier{WebhookURL: \"https://hooks.slack.com/...\"}\n\tprocessor2 := NewOrderProcessor(slackNotifier) // インターフェースを満たす SlackNotifier を渡す\n\tprocessor2.ProcessOrder(\"Order-B2\")\n\n\t// --- UserRepository の例 (コメントアウト) ---\n\t// // 本番環境では PostgresRepo を注入\n\t// dbRepo := postgres.NewPostgresRepo(...)\n\t// userService := service.NewUserService(dbRepo)\n\t// // userService を使った処理...\n\n\t// // テスト環境では InMemoryRepo を注入できる\n\t// // testRepo := memory.NewInMemoryRepo()\n\t// // testUserService := service.NewUserService(testRepo)\n}\n\n/* 実行結果:\n注文 Order-A1 を処理中...\nメール送信先 'admin@example.com': 注文 Order-A1 の処理が完了しました。\n---\n注文 Order-B2 を処理中...\nSlack 送信先 'https://hooks.slack.com/...': 注文 Order-B2 の処理が完了しました。\n*/"
    },
    {
      "title": "\"ベストプラクティス: Context を使う\"",
      "description": "",
      "code": "package main\n\nimport (\n\t\"context\"\n\t\"errors\" // errors.Is を使うため\n\t\"fmt\"\n\t\"time\"\n\t// \"myproject/service\" // 仮のサービスパッケージ\n)\n\n// Context を受け取るサービス関数 (仮)\nfunc doWorkWithContext(ctx context.Context, input string) (string, error) {\n\tfmt.Printf(\"  (doWork: '%s' の処理開始)\\n\", input)\n\tselect {\n\tcase <-time.After(100 * time.Millisecond): // 時間のかかる処理を模倣\n\t\tfmt.Printf(\"  (doWork: '%s' の処理完了)\\n\", input)\n\t\treturn \"結果:\" + input, nil\n\tcase <-ctx.Done(): // キャンセルをチェック\n\t\tfmt.Printf(\"  (doWork: '%s' の処理キャンセル: %v)\\n\", input, ctx.Err())\n\t\treturn \"\", ctx.Err()\n\t}\n}\n\nfunc main() {\n\t// 1. 起点となる Context\n\trootCtx := context.Background()\n\n\t// 2. タイムアウト付き Context を生成\n\tctx, cancel := context.WithTimeout(rootCtx, 50*time.Millisecond) // 50ms でタイムアウト\n\t// 3. defer cancel()\n\tdefer cancel()\n\n\tfmt.Println(\"処理を開始します...\")\n\t// 4. Context を関数に渡す\n\tresult, err := doWorkWithContext(ctx, \"my-data\")\n\n\t// 6. (doWorkWithContext 内で) ctx.Done() がチェックされる\n\t// 7. エラーをチェック (タイムアウトを検知)\n\tif err != nil {\n\t\tfmt.Printf(\"エラーが発生しました: %v\\n\", err)\n\t\tif errors.Is(err, context.DeadlineExceeded) {\n\t\t\tfmt.Println(\"-> タイムアウトが原因です。\")\n\t\t}\n\t} else {\n\t\tfmt.Printf(\"成功しました: %s\\n\", result)\n\t}\n}\n\n/* 実行結果:\n処理を開始します...\n  (doWork: 'my-data' の処理開始)\n  (doWork: 'my-data' の処理キャンセル: context deadline exceeded)\nエラーが発生しました: context deadline exceeded\n-> タイムアウトが原因です。\n*/"
    },
    {
      "title": "\"ベストプラクティス: パッケージレベルの状態を避ける\"",
      "description": "",
      "code": "package main\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\t// \"myproject/db\" // ダミー\n\t_ \"github.com/lib/pq\" // Postgres ドライバ (例)\n)\n\n// --- 悪い例: パッケージレベルの変数 ---\nvar globalDB *sql.DB // グローバルなDB接続 (非推奨)\n\nfunc InitGlobalDB(dataSourceName string) {\n\tvar err error\n\t// globalDB, err = sql.Open(\"postgres\", dataSourceName) // 実際のコード\n\tglobalDB, err = openDummyDB() // ダミー\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\n// globalDB に暗黙的に依存する関数\nfunc GetUserNameByIDGlobal(userID int) (string, error) {\n\tif globalDB == nil {\n\t\treturn \"\", fmt.Errorf(\"データベースが初期化されていません\")\n\t}\n\t// return globalDB.QueryRow(...).Scan(...) // globalDB を直接使う\n\tfmt.Printf(\"  (GetUserNameByIDGlobal: globalDB を使って ID %d を検索)\\n\", userID)\n\treturn fmt.Sprintf(\"User-%d\", userID), nil // ダミー\n}\n\n\n// --- 良い例: 構造体と依存性注入 ---\ntype UserService struct {\n\tdb *sql.DB // ★ 依存関係をフィールドとして持つ ★\n}\n\n// コンストラクタで依存性を注入\nfunc NewUserService(db *sql.DB) *UserService {\n\tif db == nil {\n\t\t// コンストラクタで nil チェックを行うのがより安全\n\t\tlog.Println(\"警告: NewUserService に nil の *sql.DB が渡されました\")\n\t}\n\treturn &UserService{db: db}\n}\n\n// メソッドは構造体のフィールド (db) を使う\nfunc (s *UserService) GetUserNameByID(userID int) (string, error) {\n\tif s.db == nil {\n\t\treturn \"\", fmt.Errorf(\"UserService の db が nil です\")\n\t}\n\t// return s.db.QueryRow(...).Scan(...) // フィールド db を使う\n\tfmt.Printf(\"  (UserService.GetUserNameByID: s.db を使って ID %d を検索)\\n\", userID)\n\treturn fmt.Sprintf(\"User-%d\", userID), nil // ダミー\n}\n\n\nfunc main() {\n\t// --- 悪い例の使い方 ---\n\t// InitGlobalDB(\"user=pqgotest dbname=pqgotest sslmode=verify-full\") // 初期化が必要\n\t// name1, err1 := GetUserNameByIDGlobal(1) // グローバル変数に依存\n\t// fmt.Printf(\"悪い例: %s, %v\\n\", name1, err1)\n\n\t// --- 良い例の使い方 ---\n\t// 依存関係 (DB接続) を main などで初期化\n\t// dbConn, err := sql.Open(\"postgres\", \"...\")\n\tdbConn, err := openDummyDB() // ダミー\n\tif err != nil { log.Fatal(err) }\n\tdefer dbConn.Close()\n\n\t// 依存性を注入して UserService を作成\n\tuserService := NewUserService(dbConn)\n\n\t// UserService のメソッドを呼び出す\n\tname2, err2 := userService.GetUserNameByID(2)\n\tfmt.Printf(\"良い例: %s, %v\\n\", name2, err2)\n}\n\n// ダミー関数\nfunc openDummyDB() (*sql.DB, error) { return &sql.DB{}, nil }\n\n/* 実行結果:\n良い例: User-2, <nil>\n*/"
    },
    {
      "title": "\"ベストプラクティス: クリーンアップに `defer` を使う\"",
      "description": "",
      "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"sync\"\n)\n\n// ファイル処理の例\nfunc processFile(filename string) error {\n\tfmt.Printf(\"\\nファイル '%s' を処理中...\\n\", filename)\n\tf, err := os.Open(filename)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"オープン失敗: %w\", err)\n\t}\n\t// ★ ファイルを開いた直後に Close を defer で登録 ★\n\tdefer func() {\n\t\tfmt.Printf(\"defer: '%s' をクローズします。\\n\", filename)\n\t\tif err := f.Close(); err != nil {\n\t\t\t// Close のエラーも考慮する (080_error-handling/180 参照)\n\t\t\tlog.Printf(\"警告: ファイルクローズ失敗: %v\", err)\n\t\t}\n\t}()\n\n\t// ... ファイル f を使った処理 ...\n\tfmt.Println(\"ファイルを読み込み中...\")\n\t// 例: 途中でエラーが発生して return する場合でも defer は実行される\n\t// if someCondition {\n\t// \treturn errors.New(\"処理中にエラー発生\")\n\t// }\n\n\tfmt.Println(\"ファイル処理完了。\")\n\treturn nil // 正常終了時も defer は実行される\n}\n\n// Mutex の例\nvar mu sync.Mutex\nvar counter int\n\nfunc incrementCounter() {\n\tmu.Lock() // ロックを取得\n\t// ★ ロック取得直後に Unlock を defer で登録 ★\n\tdefer func() {\n\t\tfmt.Println(\"defer: アンロックします。\")\n\t\tmu.Unlock()\n\t}()\n\n\tfmt.Println(\"カウンターをインクリメントします...\")\n\tcounter++\n\t// 例: ここで panic が発生しても defer は実行される\n\t// if counter == 1 { panic(\"意図的なパニック\") }\n}\n\nfunc main() {\n\t// ファイル処理の呼び出し\n\t// 一時ファイルを作成\n\ttempFile, err := os.CreateTemp(\"\", \"defer_example_*.txt\")\n\tif err != nil {\n\t\tlog.Fatalf(\"一時ファイルの作成に失敗: %v\", err)\n\t}\n\tfileName := tempFile.Name()\n\ttempFile.WriteString(\"data\")\n\ttempFile.Close() // CreateTemp で開かれたファイルを一旦閉じる\n\n\terr = processFile(fileName)\n\tif err != nil {\n\t\tlog.Printf(\"processFile エラー: %v\", err)\n\t}\n\tos.Remove(fileName) // 後片付け\n\n\tfmt.Println(\"---\")\n\n\t// Mutex 処理の呼び出し\n\tincrementCounter()\n\tfmt.Printf(\"現在のカウンター: %d\\n\", counter)\n}\n\n/* 実行結果 (一時ファイル名は実行ごとに変わる):\nファイル '/var/folders/.../defer_example_....txt' を処理中...\nファイルを読み込み中...\nファイル処理完了。\ndefer: '/var/folders/.../defer_example_....txt' をクローズします。\n---\nカウンターをインクリメントします...\ndefer: アンロックします。\n現在のカウンター: 1\n*/"
    },
    {
      "title": "\"リファレンス: 基本的なテスト関数\"",
      "description": "Go言語は、標準で**テスト**の仕組みを言語とツールチェーンに組み込んでいます。これにより、コードの品質を維持し、リグレッション（意図しない変更によるバグの再発）を防ぐことが容易になります。\n\n## テストファイルの規約\n\n*   テストコードは、テスト対象のコードと同じパッケージディレクトリ内に置きます。\n*   テストコードを含むファイル名は、**`_test.go`** というサフィックスで終わる必要があります（例: `mypackage_test.go`, `utils_test.go`）。\n*   テストファイル内のパッケージ名は、通常2つの選択肢があります。\n    *   **`package mypackage`**: テスト対象と同じパッケージ名にします。これにより、テストコードからパッケージ内の**非公開**な関数や変数にもアクセスできます（ユニットテスト向け）。\n    *   **`package mypackage_test`**: テスト対象のパッケージ名に `_test` サフィックスを付けた、**別のパッケージ**として扱います。この場合、テストコードはテスト対象パッケージの**公開**された API のみをテストすることになります（インテグレーションテストやブラックボックステストに近い）。こちらが推奨されることが多いです。\n\n## テスト関数の規約\n\n*   テスト関数は `testing` パッケージをインポート (`import \"testing\"`) します。\n*   関数名は **`Test`** で始まり、その後に続く名前の最初の文字は**大文字**である必要があります（例: `TestMyFunction`, `TestCalculateTotal`）。\n*   関数は **`*testing.T` 型の引数を一つだけ**受け取ります。この `t` パラメータは、テストの失敗を報告したり、ログを出力したりするためのメソッドを提供します。\n*   戻り値はありません。\n\n**シグネチャ:** `func TestXxx(t *testing.T) { ... }`\n\n## テストの失敗を報告する\n\n`*testing.T` が提供する主なメソッドを使って、テストが失敗したことを報告します。\n\n*   **`t.Errorf(format string, args ...any)`**: `fmt.Sprintf` と同じようにメッセージをフォーマットし、それを**エラーとして記録**します。テストの実行は**継続**されます。\n*   **`t.Fatalf(format string, args ...any)`**: `Errorf` と同様にメッセージをエラーとして記録しますが、その後すぐに現在のテスト関数**を終了**させます（`runtime.Goexit()` を呼び出します）。同じテスト関数内の後続のチェックは実行されません。\n*   **`t.Error(args ...any)`**: `fmt.Sprint` と同じように引数をフォーマットし、エラーとして記録します（`Errorf` の簡易版）。テストは継続されます。\n*   **`t.Fatal(args ...any)`**: `Error` と同様に引数をフォーマットし、エラーとして記録した後、テスト関数を終了させます（`Fatalf` の簡易版）。\n*   **`t.Logf(format string, args ...any)` / `t.Log(args ...any)`**: テストに関する情報をログとして記録します。テストが失敗した場合や `-v` フラグ付きで実行された場合に表示されます。\n\n## テストコード例\n\n簡単な足し算関数 `Add` をテストする例です。\n\n**テストコード (`mathutil/add_test.go` - 例):**",
      "code": "// テスト対象のコード (例: mathutil/add.go)\npackage mathutil\n\n// Add は 2 つの整数を加算します。\nfunc Add(a, b int) int {\n\treturn a + b\n}"
    },
    {
      "title": "\"リファレンス: テーブル駆動テスト (Table-Driven Tests)\"",
      "description": "Goのテストにおいて、同じ関数に対して複数の異なる入力と期待される出力でテストを行いたい場合、**テーブル駆動テスト (Table-Driven Tests)** というパターンが広く使われ、推奨されています。\n\nこれは、テストケース（入力値、期待される出力、テスト名など）をテーブル（通常は構造体のスライス）として定義し、ループを使って各テストケースを反復処理する書き方です。\n\n## テーブル駆動テストの利点\n\n*   **テストケースの追加・管理が容易:** 新しいテストケースを追加するには、テーブルに新しい要素を追加するだけで済みます。\n*   **コードの重複削減:** テストの実行ロジック（関数の呼び出しと比較）はループ内に一度だけ記述すれば良いため、テストケースごとにコードをコピー＆ペーストする必要がありません。\n*   **可読性の向上:** テストデータとテストロジックが分離され、どのようなケースをテストしているのかが分かりやすくなります。\n*   **サブテスト (`t.Run`) との連携:** 各テストケースを `t.Run` を使ってサブテストとして実行することで、どのケースが失敗したかが明確になり、特定のサブテストだけを実行することも可能になります。\n\n## テーブル駆動テストの構造\n\n1.  **テストケース用構造体の定義:** 各テストケースの入力値、期待される出力、そしてテストケースを識別するための名前などを保持する構造体を定義します（無名構造体を使うことも多いです）。\n2.  **テストデータの作成:** 定義した構造体のスライスを作成し、具体的なテストケースのデータを要素として格納します。\n3.  **ループによる反復処理:** 作成したテストデータのスライスを `for` ループで反復処理します。\n4.  **`t.Run` によるサブテストの実行:** ループ内で `t.Run(テストケース名, func(t *testing.T) { ... })` を呼び出します。\n    *   第一引数には、テストケースを識別するためのユニークな名前（通常はテストケース構造体の名前フィールド）を渡します。\n    *   第二引数には、実際のテストロジック（テスト対象関数の呼び出し、結果の比較、`t.Errorf`/`t.Fatalf` による失敗報告）を含む無名関数を渡します。\n    *   **注意:** ループ変数をサブテストの無名関数内で直接使う場合は、クロージャの落とし穴を避けるために、ループ内で変数をコピーする必要があります（例: `tt := tt`）。(Go 1.22以降では不要になる場合があります)\n\n## テストコード例: `Add` 関数のテーブル駆動テスト\n\n前のセクションで使った `Add` 関数をテーブル駆動テストで書き直してみます。\n\n**テストコード (`mathutil/add_test.go` - 例):**",
      "code": "// テスト対象のコード (例: mathutil/add.go)\npackage mathutil\n\nfunc Add(a, b int) int { return a + b }"
    },
    {
      "title": "\"リファレンス: ベンチマーク関数 (Benchmark Functions)\"",
      "description": "Goの `testing` パッケージは、ユニットテストだけでなく、コードの**パフォーマンスを測定**するための**ベンチマークテスト**の機能も提供しています。ベンチマークテストを使うことで、特定の関数の実行時間を計測し、最適化の効果を確認したり、異なる実装のパフォーマンスを比較したりすることができます。\n\n## ベンチマークファイルの規約\n\n*   ベンチマーク関数も、通常のテスト関数と同様に **`_test.go`** ファイル内に記述します。\n*   `testing` パッケージをインポートします (`import \"testing\"`)。\n\n## ベンチマーク関数の規約\n\n*   関数名は **`Benchmark`** で始まり、その後に続く名前の最初の文字は**大文字**である必要があります（例: `BenchmarkMyFunction`, `BenchmarkCalculateFibonacci`）。\n*   関数は **`*testing.B` 型の引数を一つだけ**受け取ります。この `b` パメータは、ベンチマークの実行を制御するためのフィールドやメソッドを提供します。\n*   戻り値はありません。\n\n**シグネチャ:** `func BenchmarkXxx(b *testing.B) { ... }`\n\n## ベンチマークの実行ループ: `b.N`\n\n*   ベンチマーク関数の主な役割は、測定対象のコードを**繰り返し実行**することです。\n*   `*testing.B` 型のフィールド **`N`** は、テストフレームワークが**自動的に決定する反復回数**を表します。ベンチマーク関数内の `for` ループは、`i := 0; i < b.N; i++` のように、`b.N` 回繰り返すように記述します。\n*   `go test -bench` コマンドは、測定対象のコードが安定した実行時間を示すまで `b.N` の値を増やしながらベンチマーク関数を複数回実行し、1操作あたりの平均実行時間などを算出します。\n\n## ベンチマークの実行: `go test -bench`\n\nベンチマークテストを実行するには、`go test` コマンドに **`-bench`** フラグを付けて実行します。\n\n*   **`go test -bench=. [パッケージ]`**: 指定したパッケージ内のすべてのベンチマーク関数を実行します (`.` はすべてのベンチマークにマッチする正規表現)。\n*   **`go test -bench=BenchmarkMyFunction [パッケージ]`**: 特定のベンチマーク関数のみを実行します。\n*   **`go test -bench=. -benchmem`**: `-benchmem` フラグを付けると、1操作あたりのメモリ割り当て回数と割り当てバイト数も表示されます。\n*   **`go test -bench=. -count=5`**: `-count` フラグで各ベンチマークの実行回数を指定できます。\n\n## ベンチマークコード例\n\n簡単な文字列結合関数のベンチマーク例です。\n\n**ベンチマークコード (`stringutil/join_test.go` - 例):**",
      "code": "// テスト対象のコード (例: stringutil/join.go)\npackage stringutil\n\nimport \"strings\"\n\n// JoinWithPlus は + 演算子で文字列を結合します。\nfunc JoinWithPlus(strs []string) string {\n\tresult := \"\"\n\tfor _, s := range strs {\n\t\tresult += s // + 演算子は毎回新しい文字列を生成するため非効率な場合がある\n\t}\n\treturn result\n}\n\n// JoinWithBuilder は strings.Builder で文字列を結合します。\nfunc JoinWithBuilder(strs []string) string {\n\tvar sb strings.Builder\n\tfor _, s := range strs {\n\t\tsb.WriteString(s) // Builder は効率的にメモリを管理\n\t}\n\treturn sb.String()\n}"
    },
    {
      "title": "\"リファレンス: Example 関数 (テスト可能なドキュメント)\"",
      "description": "",
      "code": "package examples_test // 通常は _test パッケージ\n\nimport (\n\t\"fmt\"\n\t// \"myproject/mypackage\" // 例として使うパッケージ (仮)\n)\n\n// パッケージ全体の簡単な使用例\nfunc Example() {\n\tfmt.Println(\"これはパッケージレベルの Example です。\")\n\t// Output: これはパッケージレベルの Example です。\n}\n\n// Add 関数の使用例\nfunc ExampleAdd() {\n\t// sum := mypackage.Add(1, 2) // 実際にはテスト対象の関数を呼び出す\n\tsum := 1 + 2 // 簡単のため直接計算\n\tfmt.Println(sum)\n\t// Output: 3\n}\n\n// 複数の出力がある例\nfunc ExampleMultipleOutput() {\n\tfmt.Println(\"Line 1\")\n\tfmt.Println(\"Line 2\")\n\t// Output:\n\t// Line 1\n\t// Line 2\n}\n\n// 出力がない (ドキュメント用のみ) 例\nfunc ExampleNoOutput() {\n\t// この関数は go test では実行されるが、出力の検証は行われない\n\t// ドキュメントにはコード例として表示される\n\tfmt.Println(\"この出力は検証されません。\")\n}\n\n// サフィックス付きの例 (同じ関数に対する別の例)\nfunc ExampleAdd_second() {\n\tsum := 10 + (-5)\n\tfmt.Println(sum)\n\t// Output: 5\n}\n\n/*\nテスト実行コマンド: go test . または go test -v .\n\n実行結果 (すべて成功する場合):\nPASS\nok  \tmyproject/examples\t0.XXXs\n\n実行結果 (ExampleAdd の Output が間違っている場合、例: // Output: 4):\n--- FAIL: ExampleAdd (0.00s)\ngot:\n3\nwant:\n4\nFAIL\nexit status 1\nFAIL\tmyproject/examples\t0.XXXs\n*/"
    },
    {
      "title": "\"リファレンス: テストのためのモック (Mocking)\"",
      "description": "ユニットテストを行う際、テスト対象のコードが依存している外部コンポーネント（データベース、外部API、ファイルシステムなど）があると、テストの実行が遅くなったり、外部の状態に依存して不安定になったり、テストのセットアップが複雑になったりします。\n\nこのような問題を解決するために、テスト時には外部依存性を**モック (Mock)** や**スタブ (Stub)**、**フェイク (Fake)** といったテスト用の代役オブジェクトに置き換える手法がよく使われます。Goでは、**インターフェース**と**依存性注入 (DI)** を組み合わせることで、これを容易に実現できます。\n\n## モックとは？ なぜ使うのか？\n\n*   **モック/スタブ/フェイク:** テスト対象が依存するコンポーネントの代わりとして振る舞うオブジェクト。テストに必要な最小限の機能（特定のメソッド呼び出しに対して決められた値を返す、呼び出されたことを記録するなど）を提供します。（用語の厳密な使い分けは文脈によりますが、ここでは広く「モック」と呼びます。）\n*   **目的:**\n    *   **外部依存性の排除:** データベースやネットワーク接続が不要になり、テストが高速かつ安定します。\n    *   **テスト対象の分離:** テスト対象コンポーネントのロジックのみに集中してテストできます。\n    *   **特定の状況のシミュレーション:** 依存コンポーネントがエラーを返す場合や、特定のデータを返す場合など、通常では再現しにくい状況を簡単に作り出すことができます。\n\n## インターフェースと DI によるモックの実現\n\n**「ベストプラクティス: 依存性注入 (DI) にインターフェースを使う」** (`130_references/110_best-practice-use-interfaces-for-di.md`) で説明したように、依存関係をインターフェースで定義し、外部から注入する設計にしておくことが鍵となります。\n\n1.  **インターフェース定義:** 依存される側の機能（例: データストア）をインターフェース (`UserStore`) として定義します。\n2.  **依存する側の実装:** テスト対象のコンポーネント (`UserHandler`) は、具体的な実装ではなく、このインターフェース (`UserStore`) に依存するようにします。\n3.  **モック実装の作成:** テストコード (`_test.go` ファイル内) で、依存インターフェース (`UserStore`) を満たす**モック用の構造体** (`mockUserStore`) を定義し、テストに必要な振る舞い（例: 特定のIDに対して特定のユーザーを返す）を実装します。\n4.  **テスト実行:** テスト関数内でモックのインスタンスを作成し、それをテスト対象コンポーネントのコンストラクタなどに**注入**してテストを実行します。\n\n## テストコード例: `UserHandler` のテスト\n\n`UserStore` インターフェースに依存する `UserHandler` をテストする例です。\n\n**テストコード (`handler/user_handler_test.go` - 例):**",
      "code": "// テスト対象のコード (例: handler/user_handler.go)\npackage handler\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t// \"myproject/model\" // 仮のモデルパッケージ\n)\n\n// User モデル (仮)\ntype User struct { ID, Name string }\n\n// UserStore インターフェース (依存される側)\ntype UserStore interface {\n\tGetUser(id string) (*User, error)\n}\n\n// UserHandler (テスト対象、UserStore に依存)\ntype UserHandler struct {\n\tstore UserStore // ★ インターフェースに依存\n}\n\n// コンストラクタ\nfunc NewUserHandler(store UserStore) *UserHandler {\n\treturn &UserHandler{store: store}\n}\n\n// GetUser ハンドラメソッド (例)\nfunc (h *UserHandler) GetUser(id string) (*User, error) {\n\tif id == \"\" {\n\t\treturn nil, errors.New(\"ID が空です\")\n\t}\n\tuser, err := h.store.GetUser(id) // ★ インターフェース経由で呼び出し\n\tif err != nil {\n\t\t// エラーをラップするなど\n\t\treturn nil, fmt.Errorf(\"ユーザー取得失敗: %w\", err)\n\t}\n\treturn user, nil\n}"
    },
    {
      "title": "\"デザインパターン: 関数オプションパターン (Function Options Pattern)\"",
      "description": "Goで構造体のインスタンスを生成する際、特にその構造体が多くの設定可能なフィールド（オプション）を持つ場合、コンストラクタ関数に多数の引数を渡す必要が出てきて、コードが読みにくくなったり、将来的なオプション追加が難しくなったりすることがあります。\n\nこのような問題を解決するための一般的なデザインパターンが**関数オプションパターン (Function Options Pattern)** です。これは、オプションを設定するための関数（オプション関数）を定義し、コンストラクタに可変長引数として渡す方法です。\n\n## 関数オプションパターンの仕組み\n\n1.  **オプション関数の型を定義:** オプションを設定したい対象の構造体（例: `*MyType`）へのポインタを引数に取り、戻り値のない関数型を定義します。",
      "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\n// --- 設定対象の構造体 ---\ntype Server struct {\n\tAddr    string        // 必須\n\tTimeout time.Duration // オプション (デフォルトあり)\n\tMaxConn int           // オプション (デフォルトあり)\n\tUseTLS  bool          // オプション (デフォルトあり)\n\tCertFile string       // TLS 用オプション\n\tKeyFile  string       // TLS 用オプション\n}\n\n// --- オプション関数の型 ---\ntype ServerOption func(*Server)\n\n// --- オプション設定関数 ---\n\n// WithTimeout はタイムアウトを設定するオプション関数を返す\nfunc WithTimeout(timeout time.Duration) ServerOption {\n\treturn func(s *Server) {\n\t\ts.Timeout = timeout\n\t}\n}\n\n// WithMaxConn は最大接続数を設定するオプション関数を返す\nfunc WithMaxConn(maxConn int) ServerOption {\n\treturn func(s *Server) {\n\t\ts.MaxConn = maxConn\n\t}\n}\n\n// WithTLS は TLS を有効にするオプション関数を返す\nfunc WithTLS(certFile, keyFile string) ServerOption {\n\treturn func(s *Server) {\n\t\ts.UseTLS = true\n\t\ts.CertFile = certFile\n\t\ts.KeyFile = keyFile\n\t}\n}\n\n// --- コンストラクタ ---\nfunc NewServer(addr string, opts ...ServerOption) *Server {\n\t// 1. デフォルト値で Server を初期化\n\tserver := &Server{\n\t\tAddr:    addr,\n\t\tTimeout: 30 * time.Second, // デフォルトタイムアウト\n\t\tMaxConn: 100,             // デフォルト最大接続数\n\t\tUseTLS:  false,            // デフォルトは TLS 無効\n\t}\n\n\t// 2. 渡されたオプションを適用\n\tfmt.Printf(\"Applying %d options...\\n\", len(opts))\n\tfor _, opt := range opts {\n\t\topt(server) // 各オプション関数を実行して server のフィールドを変更\n\t}\n\n\t// 3. 設定済みの Server を返す\n\treturn server\n}\n\nfunc main() {\n\t// --- サーバーの生成 ---\n\n\t// 例1: デフォルト設定 + タイムアウトのみ変更\n\tfmt.Println(\"--- Server 1 ---\")\n\tserver1 := NewServer(\":8080\", WithTimeout(10*time.Second))\n\tfmt.Printf(\"Server 1 config: %+v\\n\", *server1)\n\n\t// 例2: TLS を有効化 (タイムアウトと最大接続数はデフォルト)\n\tfmt.Println(\"\\n--- Server 2 ---\")\n\tserver2 := NewServer(\":443\", WithTLS(\"mycert.pem\", \"mykey.pem\"))\n\tfmt.Printf(\"Server 2 config: %+v\\n\", *server2)\n\n\t// 例3: すべてのオプションを設定\n\tfmt.Println(\"\\n--- Server 3 ---\")\n\tserver3 := NewServer(\"127.0.0.1:9000\",\n\t\tWithTLS(\"cert.pem\", \"key.pem\"), // 順番は任意\n\t\tWithMaxConn(500),\n\t\tWithTimeout(5*time.Second),\n\t)\n\tfmt.Printf(\"Server 3 config: %+v\\n\", *server3)\n\n\t// 例4: オプションなし (すべてデフォルト)\n\tfmt.Println(\"\\n--- Server 4 ---\")\n\tserver4 := NewServer(\":8888\") // オプションを渡さない\n\tfmt.Printf(\"Server 4 config: %+v\\n\", *server4)\n}\n\n/* 実行結果:\n--- Server 1 ---\nApplying 1 options...\nServer 1 config: {Addr::8080 Timeout:10s MaxConn:100 UseTLS:false CertFile: KeyFile:}\n\n--- Server 2 ---\nApplying 1 options...\nServer 2 config: {Addr::443 Timeout:30s MaxConn:100 UseTLS:true CertFile:mycert.pem KeyFile:mykey.pem}\n\n--- Server 3 ---\nApplying 3 options...\nServer 3 config: {Addr:127.0.0.1:9000 Timeout:5s MaxConn:500 UseTLS:true CertFile:cert.pem KeyFile:key.pem}\n\n--- Server 4 ---\nApplying 0 options...\nServer 4 config: {Addr::8888 Timeout:30s MaxConn:100 UseTLS:false CertFile: KeyFile:}\n*/"
    },
    {
      "title": "\"デザインパターン: ワーカープールパターン (Worker Pool)\"",
      "description": "",
      "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\n// ダミーのジョブと結果\ntype Job int\ntype Result int\n\n// ワーカー関数\nfunc worker(id int, jobs <-chan Job, results chan<- Result, wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\tfor job := range jobs { // jobs が close されるまで受信\n\t\tfmt.Printf(\"ワーカー %d: ジョブ %d 開始\\n\", id, job)\n\t\ttime.Sleep(100 * time.Millisecond) // 処理をシミュレート\n\t\tresults <- Result(job * 2)         // 結果を送信\n\t\tfmt.Printf(\"ワーカー %d: ジョブ %d 完了\\n\", id, job)\n\t}\n\tfmt.Printf(\"ワーカー %d: 終了\\n\", id)\n}\n\nfunc main() {\n\tconst numJobs = 5\n\tconst numWorkers = 2\n\n\tjobs := make(chan Job, numJobs)\n\tresults := make(chan Result, numJobs)\n\tvar wg sync.WaitGroup\n\n\t// ワーカーを起動\n\tfmt.Printf(\"%d 個のワーカーを起動\\n\", numWorkers)\n\twg.Add(numWorkers)\n\tfor w := 1; w <= numWorkers; w++ {\n\t\tgo worker(w, jobs, results, &wg)\n\t}\n\n\t// ジョブを送信\n\tfmt.Printf(\"%d 個のジョブを送信\\n\", numJobs)\n\tfor j := 1; j <= numJobs; j++ {\n\t\tjobs <- Job(j)\n\t}\n\tclose(jobs) // ★ ジョブ送信完了後、jobs チャネルをクローズ\n\n\t// すべてのワーカーの終了を待つ\n\tfmt.Println(\"ワーカーの終了を待機...\")\n\twg.Wait()\n\tfmt.Println(\"すべてのワーカーが終了\")\n\n\t// 結果を収集 (結果チャネルもクローズするのが安全)\n\tclose(results) // ★ ワーカー終了後に results チャネルをクローズ\n\tfmt.Println(\"結果を収集:\")\n\tfor result := range results {\n\t\tfmt.Printf(\"結果受信: %d\\n\", result)\n\t}\n\tfmt.Println(\"収集完了\")\n}\n\n/* 実行結果の例:\n2 個のワーカーを起動\n5 個のジョブを送信\nワーカーの終了を待機...\nワーカー 1: ジョブ 1 開始\nワーカー 2: ジョブ 2 開始\nワーカー 1: ジョブ 1 完了\nワーカー 1: ジョブ 3 開始\nワーカー 2: ジョブ 2 完了\nワーカー 2: ジョブ 4 開始\nワーカー 1: ジョブ 3 完了\nワーカー 1: ジョブ 5 開始\nワーカー 2: ジョブ 4 完了\nワーカー 2: 終了\nワーカー 1: ジョブ 5 完了\nワーカー 1: 終了\nすべてのワーカーが終了\n結果を収集:\n結果受信: 2\n結果受信: 4\n結果受信: 6\n結果受信: 8\n結果受信: 10\n収集完了\n*/"
    }
  ]
}