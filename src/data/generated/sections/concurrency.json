{
  "title": "Concurrency",
  "codeExamples": [
    {
      "title": "並行処理: Goroutine (ゴルーチン) の開始",
      "description": "Goの**並行処理 (Concurrency)** の中心が **Goroutine** です。\n\n**Goroutine とは？**\n*   **軽量な実行単位:** OSスレッドより遥かに軽量で多数実行可能。\n*   **並行実行:** 複数の処理が見かけ上同時に進行する。\n    (物理的な同時実行は**並列 Parallel**)\n*   **簡単な起動:** `go` キーワードで関数呼び出しを起動。\n\n**Goroutine の起動: `go` キーワード**\n関数呼び出しの前に `go` を付けると、その関数は新しい\nGoroutine として起動され、呼び出し元とは**並行**に実行されます。\n**構文:**",
      "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\n// Goroutine で実行する関数\nfunc say(s string) {\n\tfor i := 0; i < 3; i++ {\n\t\tfmt.Printf(\"%s: %d\\n\", s, i)\n\t\ttime.Sleep(100 * time.Millisecond)\n\t}\n\tfmt.Printf(\"%s: 完了\\n\", s)\n}\n\nfunc main() {\n\tfmt.Println(\"main: 開始\")\n\n\t// say 関数を新しい Goroutine として起動\n\tgo say(\"Hello\")\n\tfmt.Println(\"main: say(\\\"Hello\\\") Goroutine 起動\")\n\n\t// 匿名関数も Goroutine で起動可能\n\t// go func(msg string) { ... }(\"メッセージ\")\n\n\tfmt.Println(\"main: 他の処理...\")\n\ttime.Sleep(50 * time.Millisecond)\n\n\t// ★ 注意: main がここで終了すると say Goroutine も終了してしまう\n\t//          完了を待つ必要がある (次のセクションで解説)\n\t//          time.Sleep は不確実なため、実際のコードでは使わない！\n\tfmt.Println(\"main: 少し待機 (悪い例)...\")\n\ttime.Sleep(500 * time.Millisecond)\n\n\tfmt.Println(\"main: 終了\")\n}"
    },
    {
      "title": "並行処理: Goroutine の終了を待つ (`sync.WaitGroup`)",
      "description": "",
      "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\" // sync パッケージ\n\t\"time\"\n)\n\n// Goroutine で実行するワーカー関数\nfunc worker(id int, wg *sync.WaitGroup) {\n\t// ★ 最初に defer で Done() を登録\n\tdefer wg.Done() // Goroutine 完了時にカウンターを減らす\n\n\tfmt.Printf(\"Worker %d: Start\\n\", id)\n\ttime.Sleep(time.Duration(id) * 100 * time.Millisecond) // 処理のシミュレート\n\tfmt.Printf(\"Worker %d: End\\n\", id)\n}\n\nfunc main() {\n\tvar wg sync.WaitGroup // WaitGroup を宣言\n\n\tnumWorkers := 3\n\tfmt.Printf(\"Starting %d workers...\\n\", numWorkers)\n\n\t// ★ 起動する Goroutine の数を Add で設定\n\twg.Add(numWorkers)\n\n\t// Goroutine を起動\n\tfor i := 1; i <= numWorkers; i++ {\n\t\tgo worker(i, &wg) // wg のポインタを渡す\n\t}\n\n\tfmt.Println(\"Waiting for workers to finish...\")\n\t// ★ Wait でカウンターが 0 になるのを待つ\n\twg.Wait() // 全ての worker が Done() を呼ぶまでブロック\n\n\tfmt.Println(\"All workers finished.\")\n}"
    },
    {
      "title": "並行処理: 複数の Goroutine と WaitGroup",
      "description": "",
      "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\tnumWorkers := 5\n\n\tfmt.Printf(\"%d 個のワーカー起動...\\n\", numWorkers)\n\n\t// ループで複数の Goroutine を起動\n\tfor i := 1; i <= numWorkers; i++ {\n\t\twg.Add(1) // Goroutine 起動前にカウンターを増やす\n\t\t// ループ変数 i を Goroutine に引数として渡す\n\t\tgo func(workerID int) {\n\t\t\tdefer wg.Done() // Goroutine 完了時にカウンターを減らす\n\n\t\t\tfmt.Printf(\"Worker %d: Start\\n\", workerID)\n\t\t\ttime.Sleep(time.Duration(workerID) * 50 * time.Millisecond)\n\t\t\tfmt.Printf(\"Worker %d: End\\n\", workerID)\n\t\t}(i) // ★ 現在の i の値を引数として渡す\n\t}\n\n\tfmt.Println(\"全ワーカーの終了待機...\")\n\twg.Wait() // カウンターが 0 になるまで待つ\n\n\tfmt.Println(\"全ワーカー終了\")\n}"
    },
    {
      "title": "並行処理: チャネル (Channel) の基本",
      "description": "",
      "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\t// バッファなしチャネル作成\n\tch1 := make(chan string)\n\n\tgo func() {\n\t\tfmt.Println(\"Goroutine: 送信開始\")\n\t\tch1 <- \"Hello\" // 送信 (受信側が待つまでブロックする可能性)\n\t\tfmt.Println(\"Goroutine: 送信完了\")\n\t\ttime.Sleep(50 * time.Millisecond)\n\t\tch1 <- \"World\"\n\t\tfmt.Println(\"Goroutine: 送信完了、クローズ\")\n\t\tclose(ch1) // ★ 送信側がクローズ\n\t}()\n\n\tfmt.Println(\"main: 受信待機...\")\n\tmsg1 := <-ch1 // 受信 (送信されるまでブロックする可能性)\n\tfmt.Printf(\"main: 受信1: %s\\n\", msg1)\n\tmsg2 := <-ch1 // 再度受信\n\tfmt.Printf(\"main: 受信2: %s\\n\", msg2)\n\n\t// クローズ後の受信確認\n\tmsg3, ok := <-ch1\n\tif !ok {\n\t\tfmt.Printf(\"main: 受信3: クローズ済み (値:%q, ok:%t)\\n\", msg3, ok)\n\t}\n\t// close(ch1) // 再クローズは panic\n\t// ch1 <- \"Bye\" // クローズ後送信は panic\n}"
    },
    {
      "title": "並行処理: `for range` によるチャネルからの受信",
      "description": "",
      "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\n// メッセージを送信し、最後にチャネルをクローズする関数\nfunc produceMessages(count int, ch chan<- string) {\n\tfmt.Println(\"Producer: 開始\")\n\tfor i := 1; i <= count; i++ {\n\t\tmsg := fmt.Sprintf(\"Msg %d\", i)\n\t\tfmt.Printf(\"Producer: 送信 '%s'\\n\", msg)\n\t\tch <- msg\n\t\ttime.Sleep(50 * time.Millisecond)\n\t}\n\tfmt.Println(\"Producer: クローズ\")\n\tclose(ch) // ★ 送信完了後にクローズ\n}\n\nfunc main() {\n\tmessageChannel := make(chan string)\n\tgo produceMessages(3, messageChannel) // Goroutine で送信\n\n\tfmt.Println(\"Consumer: 受信開始 (for range)...\")\n\t// ★ for range でチャネルから受信\n\t// チャネルがクローズされるまでループが続く\n\tfor msg := range messageChannel {\n\t\tfmt.Printf(\"Consumer: 受信 '%s'\\n\", msg)\n\t}\n\tfmt.Println(\"Consumer: ループ終了 (チャネルクローズ)\")\n}"
    },
    {
      "title": "並行処理: 方向付きチャネル (Directional Channels)",
      "description": "",
      "code": "package main\n\nimport \"fmt\"\n\n// 送信専用チャネル (chan<- string) を受け取る関数\nfunc producer(out chan<- string) {\n\tfmt.Println(\"Producer: 送信開始\")\n\tout <- \"データ\" // 送信のみ可能\n\t// <-out // 受信はコンパイルエラー\n\tfmt.Println(\"Producer: 送信完了\")\n\t// close(out) // 送信専用はクローズ不可\n}\n\n// 受信専用チャネル (<-chan string) を受け取る関数\nfunc consumer(in <-chan string) {\n\tfmt.Println(\"Consumer: 受信開始\")\n\tmsg := <-in // 受信のみ可能\n\tfmt.Printf(\"Consumer: 受信: %s\\n\", msg)\n\t// in <- \"x\" // 送信はコンパイルエラー\n\tfmt.Println(\"Consumer: 受信完了\")\n}\n\nfunc main() {\n\t// 通常の双方向チャネルを作成\n\tch := make(chan string, 1)\n\n\t// 双方向チャネルを方向付きチャネルとして渡せる\n\tgo producer(ch) // producer は chan<- string を期待\n\tconsumer(ch)    // consumer は <-chan string を期待\n\n\tclose(ch) // クローズは元の双方向チャネルで行う\n}"
    },
    {
      "title": "並行処理: ワーカープール (Worker Pool) パターン",
      "description": "",
      "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\n// ワーカー: jobs から受信し、処理して results へ送信\nfunc worker(id int, jobs <-chan int, results chan<- int, wg *sync.WaitGroup) {\n\tdefer wg.Done() // 完了を通知\n\tfor job := range jobs { // jobs が close されるまで受信\n\t\tfmt.Printf(\"Worker %d: Job %d 開始\\n\", id, job)\n\t\ttime.Sleep(100 * time.Millisecond) // 処理シミュレート\n\t\tresult := job * 2\n\t\tfmt.Printf(\"Worker %d: Job %d 完了, Result %d\\n\", id, job, result)\n\t\tresults <- result // 結果を送信\n\t}\n\tfmt.Printf(\"Worker %d: 終了\\n\", id)\n}\n\nfunc main() {\n\tconst numJobs = 5\n\tconst numWorkers = 3\n\n\tjobs := make(chan int, numJobs)\n\tresults := make(chan int, numJobs)\n\tvar wg sync.WaitGroup\n\n\t// ワーカー Goroutine 起動\n\tfmt.Printf(\"%d ワーカー起動...\\n\", numWorkers)\n\tfor w := 1; w <= numWorkers; w++ {\n\t\twg.Add(1)\n\t\tgo worker(w, jobs, results, &wg)\n\t}\n\n\t// ジョブ送信\n\tfmt.Printf(\"%d ジョブ送信...\\n\", numJobs)\n\tfor j := 1; j <= numJobs; j++ {\n\t\tjobs <- j\n\t}\n\tclose(jobs) // ★ 全ジョブ送信後、jobs をクローズ\n\tfmt.Println(\"全ジョブ送信完了、jobs クローズ\")\n\n\t// 全ワーカーの終了待機\n\tfmt.Println(\"ワーカー終了待機...\")\n\twg.Wait()\n\tfmt.Println(\"全ワーカー終了\")\n\n\t// ★ 全ワーカー終了後、results をクローズ\n\tclose(results)\n\n\t// 結果収集\n\tfmt.Println(\"結果収集...\")\n\ttotal := 0\n\tfor result := range results { // results が close されるまで受信\n\t\tfmt.Printf(\"結果受信: %d\\n\", result)\n\t\ttotal += result\n\t}\n\tfmt.Printf(\"結果合計: %d\\n\", total)\n}"
    },
    {
      "title": "並行処理: `select` 文による複数チャネル操作の待機",
      "description": "複数のチャネル送受信操作を**同時に待ち受け**、\n最初に準備ができたものを実行するのが **`select`** 文です。\n`switch` に似ていますが、`case` はチャネル操作を評価します。\n\n**構文と動作:**",
      "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tch1 := make(chan string)\n\tch2 := make(chan string)\n\n\t// Goroutine 1: 1秒後に ch1 へ送信\n\tgo func() { time.Sleep(1 * time.Second); ch1 <- \"from 1\" }()\n\t// Goroutine 2: 500ミリ秒後に ch2 へ送信\n\tgo func() { time.Sleep(500 * time.Millisecond); ch2 <- \"from 2\" }()\n\n\tfmt.Println(\"受信待機中...\")\n\n\t// select で ch1 または ch2 から受信可能な方を待つ\n\tselect {\n\tcase msg1 := <-ch1:\n\t\tfmt.Printf(\"ch1 受信: %s\\n\", msg1)\n\tcase msg2 := <-ch2:\n\t\tfmt.Printf(\"ch2 受信: %s\\n\", msg2) // ch2 が先に準備できる\n\t}\n\n\tfmt.Println(\"最初のメッセージ受信完了\")\n\n\t// (もう一方を受信するには再度 select や受信操作が必要)\n\t// msg := <-ch1 // 例\n\t// fmt.Println(\"残りを別途受信:\", msg)\n}"
    },
    {
      "title": "並行処理: `select` によるタイムアウト処理",
      "description": "チャネル操作は相手の準備ができるまでブロックする可能性がありますが、\n無期限に待たずに一定時間で中断（タイムアウト）したい場合があります。\n`select` 文と `time.After` で実現できます。\n\n**`time.After` によるタイムアウト:**\n`time.After(d time.Duration)` は、指定期間 `d` 経過後に\n現在時刻を一度だけ送信する**受信専用チャネル** (`<-chan Time`) を返します。\n\n**`select` での利用パターン:**",
      "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\n// 時間のかかる処理 (シミュレーション)\nfunc longOperation(duration time.Duration, resultChan chan<- string) {\n\tfmt.Printf(\" Goroutine: %v 処理開始...\\n\", duration)\n\ttime.Sleep(duration)\n\tresult := fmt.Sprintf(\"完了 (%v)\", duration)\n\tfmt.Printf(\" Goroutine: 結果 '%s' 送信\\n\", result)\n\t// 注意: タイムアウト後も送信しようとする可能性がある\n\tresultChan <- result\n}\n\nfunc main() {\n\tch1 := make(chan string, 1)\n\tgo longOperation(2*time.Second, ch1) // 2秒かかる処理\n\n\tfmt.Println(\"1秒間のタイムアウトを設定して待機...\")\n\n\tselect {\n\tcase res := <-ch1: // 処理結果の受信を待つ\n\t\tfmt.Printf(\"受信成功: %s\\n\", res)\n\tcase <-time.After(1 * time.Second): // 1秒待つ\n\t\t// 1秒以内に ch1 から受信できなければ、こちらが実行される\n\t\tfmt.Println(\"タイムアウトしました！\")\n\t}\n\n\t// (タイムアウトしなかった場合の例は解説参照)\n\t// time.Sleep(2 * time.Second) // Goroutine が完了するのを待つ (デモ用)\n}"
    },
    {
      "title": "並行処理: `select` と終了チャネル (Quit Channel)",
      "description": "実行中の Goroutine に外部から安全に終了を通知する古典的な\nパターンが**終了チャネル (Quit Channel)** です。\n\n**パターン:**\n1. **終了チャネル作成:** 通常 `make(chan struct{})` を使う\n   (空構造体はメモリ消費ゼロ)。\n2. **Goroutine へ渡す:** 終了させたい Goroutine に引数\n   (通常 `<-chan struct{}`) として渡す。\n3. **`select` で待機:** Goroutine 内のループで `select` を使い、\n   通常の処理用チャネルと**終了チャネルからの受信**を待つ。",
      "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\n// 終了通知を受け取るまで処理を続けるワーカー\nfunc worker(id int, dataChan <-chan string, quitChan <-chan struct{}) {\n\tfmt.Printf(\"Worker %d: 開始\\n\", id)\n\tfor {\n\t\tselect {\n\t\tcase data := <-dataChan:\n\t\t\tfmt.Printf(\"Worker %d: 処理 '%s'\\n\", id, data)\n\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\tcase <-quitChan: // ★ 終了チャネルから受信 (またはクローズ検知)\n\t\t\tfmt.Printf(\"Worker %d: 終了シグナル受信\\n\", id)\n\t\t\treturn // Goroutine 終了\n\t\t}\n\t}\n}\n\nfunc main() {\n\tdataChan := make(chan string)\n\tquitChan := make(chan struct{}) // 終了通知用チャネル\n\n\tgo worker(1, dataChan, quitChan) // ワーカー起動\n\n\tdataChan <- \"データ A\"\n\tdataChan <- \"データ B\"\n\ttime.Sleep(200 * time.Millisecond)\n\n\tfmt.Println(\"main: 終了シグナル送信 (close)\")\n\tclose(quitChan) // ★ チャネルをクローズして終了を通知\n\n\ttime.Sleep(100 * time.Millisecond) // 終了を待つ (WaitGroup推奨)\n\tfmt.Println(\"main: 終了\")\n}"
    },
    {
      "title": "並行処理: ノンブロッキング `select` (`default` ケース)",
      "description": "",
      "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tmessages := make(chan string) // バッファなし\n\tmsgToSend := \"Hi\"\n\n\t// ノンブロッキング受信\n\t// messages は空なので受信はブロックするはず\n\tselect {\n\tcase msg := <-messages:\n\t\tfmt.Println(\"受信:\", msg)\n\tdefault: // ★ 他の case がブロックするので default が実行される\n\t\tfmt.Println(\"受信メッセージなし\")\n\t}\n\n\t// ノンブロッキング送信\n\t// messages に受信側がいないので送信はブロックするはず\n\tselect {\n\tcase messages <- msgToSend:\n\t\tfmt.Println(\"送信成功:\", msgToSend)\n\tdefault: // ★ 他の case がブロックするので default が実行される\n\t\tfmt.Println(\"送信失敗 (ブロックするため)\")\n\t}\n\n\t// 受信を試みる (ノンブロッキング)\n\t// この時点でも受信できないので default が実行される\n\tselect {\n\tcase msg := <-messages:\n\t\tfmt.Println(\"受信:\", msg)\n\tdefault:\n\t\tfmt.Println(\"再度受信試行: 受信メッセージなし\")\n\t}\n}"
    },
    {
      "title": "並行処理: 共有メモリの保護 (`sync.Mutex`)",
      "description": "",
      "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nvar mu sync.Mutex // 共有カウンターを保護する Mutex\n\n// Mutex を使って安全にカウンターをインクリメント\nfunc safeIncrement(wg *sync.WaitGroup, counter *int) {\n\tdefer wg.Done()\n\n\tmu.Lock() // ロック獲得\n\t// ★ defer で必ず Unlock する\n\tdefer mu.Unlock()\n\n\t// Lock と Unlock の間は一度に1つの Goroutine のみ実行可能\n\t*counter = *counter + 1\n}\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\titerations := 1000\n\tsafeCounter := 0\n\n\tfmt.Println(\"--- Mutex あり ---\")\n\twg.Add(iterations)\n\tfor i := 0; i < iterations; i++ {\n\t\tgo safeIncrement(&wg, &safeCounter)\n\t}\n\twg.Wait()\n\t// 常に期待値になる\n\tfmt.Printf(\"最終カウンター: %d (期待値: %d)\\n\", safeCounter, iterations)\n\n\t// 競合検出: go run -race main.go\n}"
    },
    {
      "title": "並行処理: 読み取り/書き込みロック (`sync.RWMutex`)",
      "description": "",
      "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\nvar config = make(map[string]string)\nvar rwmu sync.RWMutex // 読み取り/書き込みロック\n\n// 読み取り (RLock/RUnlock)\nfunc getConfig(key string, wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\trwmu.RLock() // 読み取りロック獲得\n\tdefer rwmu.RUnlock() // 必ず解放\n\n\tvalue := config[key]\n\tfmt.Printf(\"Reader: Read '%s' -> '%s'\\n\", key, value)\n\ttime.Sleep(50 * time.Millisecond)\n}\n\n// 書き込み (Lock/Unlock)\nfunc setConfig(key, value string, wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\trwmu.Lock() // 書き込みロック獲得 (排他的)\n\tdefer rwmu.Unlock() // 必ず解放\n\n\tfmt.Printf(\"Writer: Set '%s' = '%s'\\n\", key, value)\n\tconfig[key] = value\n\ttime.Sleep(100 * time.Millisecond)\n}\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\n\t// 初期設定 (書き込み)\n\twg.Add(1); go setConfig(\"key1\", \"val1\", &wg); wg.Wait()\n\n\t// 複数リーダーと1ライター起動\n\tfor i := 0; i < 3; i++ { wg.Add(1); go getConfig(\"key1\", &wg) }\n\ttime.Sleep(10 * time.Millisecond)\n\twg.Add(1); go setConfig(\"key1\", \"val2\", &wg)\n\tfor i := 0; i < 2; i++ { wg.Add(1); go getConfig(\"key1\", &wg) }\n\n\twg.Wait() // 全て完了を待つ\n\tfmt.Println(\"Final key1:\", config[\"key1\"]) // val2\n}"
    },
    {
      "title": "並行処理: 一度だけの実行 (`sync.Once`)",
      "description": "",
      "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\nvar config map[string]string\nvar loadConfigOnce sync.Once // ★ sync.Once 変数\n\n// 設定読み込み関数 (一度だけ実行される)\nfunc loadConfig() {\n\tfmt.Println(\"--- 設定読み込み実行 ---\")\n\ttime.Sleep(100 * time.Millisecond) // 時間がかかる処理を模倣\n\tconfig = map[string]string{\"apiKey\": \"xyz\"}\n\tfmt.Println(\"--- 設定読み込み完了 ---\")\n}\n\n// 設定取得関数 (必要なら初期化)\nfunc getConfig(key string, wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\t// ★ Do メソッドで loadConfig を呼び出す\n\t//   最初の呼び出し時のみ loadConfig が実行される\n\tloadConfigOnce.Do(loadConfig)\n\n\t// Do の後では config は初期化済み\n\tvalue := config[key]\n\tfmt.Printf(\"Goroutine: Get '%s' -> '%s'\\n\", key, value)\n}\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\tnumGoroutines := 3\n\twg.Add(numGoroutines)\n\tfor i := 0; i < numGoroutines; i++ {\n\t\tgo getConfig(\"apiKey\", &wg) // 複数 Goroutine から呼び出し\n\t}\n\twg.Wait()\n\tfmt.Println(\"初回取得完了\")\n\n\t// 再度呼び出しても loadConfig は実行されない\n\twg.Add(1); go getConfig(\"apiKey\", &wg); wg.Wait()\n}"
    },
    {
      "title": "\"並行処理: sync.WaitGroup (再確認)\"",
      "description": "",
      "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc task(id int, wg *sync.WaitGroup) {\n\tdefer wg.Done() // タスク完了時にカウンターを減らす\n\tfmt.Printf(\"タスク %d: 開始\\n\", id)\n\ttime.Sleep(time.Duration(id) * 100 * time.Millisecond) // 処理をシミュレート\n\tfmt.Printf(\"タスク %d: 完了\\n\", id)\n}\n\nfunc main() {\n\tvar wg sync.WaitGroup // WaitGroup を宣言\n\n\tnumTasks := 3\n\tfmt.Printf(\"%d 個のタスクを Goroutine で実行します...\\n\", numTasks)\n\n\twg.Add(numTasks) // 待機する Goroutine の数を設定\n\n\t// Goroutine を起動\n\tgo task(1, &wg)\n\tgo task(2, &wg)\n\tgo task(3, &wg)\n\n\tfmt.Println(\"すべてのタスクの完了を待機します...\")\n\twg.Wait() // カウンターが 0 になるまで待機\n\n\tfmt.Println(\"すべてのタスクが完了しました。\")\n}\n\n/* 実行結果の例 (Goroutine の実行順序により多少前後する可能性あり):\n3 個のタスクを Goroutine で実行します...\nすべてのタスクの完了を待機します...\nタスク 1: 開始\nタスク 2: 開始\nタスク 3: 開始\nタスク 1: 完了\nタスク 2: 完了\nタスク 3: 完了\nすべてのタスクが完了しました。\n*/"
    },
    {
      "title": "並行処理: 条件変数 (`sync.Cond`)",
      "description": "",
      "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\nvar (\n\tdata      string\n\tdataMutex sync.Mutex\n\tdataCond  = sync.NewCond(&dataMutex) // Mutex に関連付け\n\twg        sync.WaitGroup\n)\n\n// 消費者: データが準備されるのを待つ\nfunc consumer() {\n\tdefer wg.Done()\n\tfmt.Println(\"Consumer: 待機開始\")\n\tdataCond.L.Lock() // ロック取得\n\tfor data == \"\" { // ★ 条件チェックループ\n\t\tfmt.Println(\"Consumer: Wait...\")\n\t\tdataCond.Wait() // アンロックして待機、起こされたら再ロック\n\t}\n\tfmt.Printf(\"Consumer: データ受信 '%s'\\n\", data)\n\tdataCond.L.Unlock() // ロック解放\n}\n\n// 生産者: データを準備して通知\nfunc producer() {\n\tdefer wg.Done()\n\tfmt.Println(\"Producer: 準備開始\")\n\ttime.Sleep(100 * time.Millisecond) // 準備時間\n\tdataCond.L.Lock() // ロック取得\n\tdata = \"準備完了データ\"\n\tfmt.Println(\"Producer: 準備完了、Signal 送信\")\n\tdataCond.Signal() // 待機中の Goroutine を1つ起こす\n\tdataCond.L.Unlock() // ロック解放\n}\n\nfunc main() {\n\twg.Add(2)\n\tgo consumer()\n\ttime.Sleep(10 * time.Millisecond) // consumer が先に Wait するように\n\tgo producer()\n\twg.Wait()\n\tfmt.Println(\"完了\")\n}"
    },
    {
      "title": "並行処理: アトミック操作 (`sync/atomic` パッケージ)",
      "description": "",
      "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"sync/atomic\" // atomic パッケージ\n)\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\tvar counter atomic.Int64 // ★ atomic.Int64 で宣言\n\titerations := 1000\n\n\twg.Add(iterations)\n\tfor i := 0; i < iterations; i++ {\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\t// ★ Add メソッドでアトミックにインクリメント\n\t\t\tcounter.Add(1)\n\t\t}()\n\t}\n\twg.Wait()\n\n\t// ★ Load メソッドでアトミックに読み取り\n\tfinalCount := counter.Load()\n\tfmt.Printf(\"最終カウンター: %d\\n\", finalCount) // 常に 1000\n}"
    },
    {
      "title": "\"並行処理: アトミック操作 (Go 1.19 未満の古い方法)\"",
      "description": "",
      "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"sync/atomic\" // atomic パッケージをインポート\n)\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\tvar counter int64 // ★ 通常の int64 型で宣言\n\titerations := 1000\n\n\tfmt.Printf(\"%d 回インクリメントします...\\n\", iterations)\n\n\twg.Add(iterations)\n\tfor i := 0; i < iterations; i++ {\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\t// ★ atomic.AddInt64 でアトミックにインクリメント ★\n\t\t\t// 第一引数にはカウンター変数のポインタ (&counter) を渡す\n\t\t\tatomic.AddInt64(&counter, 1)\n\t\t}()\n\t}\n\n\twg.Wait() // すべての Goroutine が完了するのを待つ\n\n\t// ★ atomic.LoadInt64 でアトミックに値を読み取る ★\n\t// 第一引数にはカウンター変数のポインタ (&counter) を渡す\n\tfinalCount := atomic.LoadInt64(&counter)\n\tfmt.Printf(\"最終カウンター: %d (期待値: %d)\\n\", finalCount, iterations)\n\n\t// --- その他の操作例 ---\n\tfmt.Println(\"\\n--- その他の操作 ---\")\n\n\t// CompareAndSwap: 現在値が 1000 なら 0 にする\n\tswapped := atomic.CompareAndSwapInt64(&counter, 1000, 0)\n\tfmt.Printf(\"CompareAndSwapInt64(1000, 0): %t, 現在値: %d\\n\", swapped, atomic.LoadInt64(&counter))\n\n\t// Swap: 現在値を 500 に設定し、古い値を取得\n\toldValue := atomic.SwapInt64(&counter, 500)\n\tfmt.Printf(\"SwapInt64(500): 古い値=%d, 現在値: %d\\n\", oldValue, atomic.LoadInt64(&counter))\n\n\t// Store: 現在値を -100 に設定\n\tatomic.StoreInt64(&counter, -100)\n\tfmt.Printf(\"StoreInt64(-100): 現在値: %d\\n\", atomic.LoadInt64(&counter))\n}\n\n/* 実行結果:\n1000 回インクリメントします...\n最終カウンター: 1000 (期待値: 1000)\n\n--- その他の操作 ---\nCompareAndSwapInt64(1000, 0): true, 現在値: 0\nSwapInt64(500): 古い値=0, 現在値: 500\nStoreInt64(-100): 現在値: -100\n*/"
    },
    {
      "title": "並行処理: アトミックポインタ (`atomic.Pointer[T]`, Go 1.19+)",
      "description": "",
      "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"sync/atomic\"\n)\n\ntype Config struct { Version string; APIKey string }\n\n// Config へのポインタをアトミックに保持\nvar currentConfig atomic.Pointer[Config]\n\n// 設定読み取り (アトミックにポインタ取得)\nfunc configReader(id int, wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\tcfg := currentConfig.Load() // アトミックにポインタ取得\n\tif cfg != nil {\n\t\tfmt.Printf(\"Reader %d: Read Ver='%s'\\n\", id, cfg.Version)\n\t} else {\n\t\tfmt.Printf(\"Reader %d: Config nil\\n\", id)\n\t}\n}\n\n// 設定更新 (アトミックにポインタ設定)\nfunc configUpdater(newCfg *Config, wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\tfmt.Printf(\"Updater: Set Ver='%s'\\n\", newCfg.Version)\n\tcurrentConfig.Store(newCfg) // アトミックにポインタ設定\n\t// ok := currentConfig.CompareAndSwap(oldCfg, newCfg) // CASも可能\n}\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\tinitialCfg := &Config{Version: \"v1\"}\n\tcurrentConfig.Store(initialCfg) // 初期設定\n\n\twg.Add(2)\n\tgo configReader(1, &wg)\n\tgo configUpdater(&Config{Version: \"v2\"}, &wg)\n\twg.Wait()\n\n\tfinalCfg := currentConfig.Load()\n\tfmt.Printf(\"Final Version: %s\\n\", finalCfg.Version) // v2\n}"
    },
    {
      "title": "並行処理: Context の生成 (`context` パッケージ)",
      "description": "",
      "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\ntype contextKey string // Value 用のキー型\nconst userIDKey contextKey = \"userID\"\n\nfunc main() {\n\t// 1. ルート Context (通常 Background を使う)\n\tctxBg := context.Background()\n\tfmt.Println(\"1. Background:\", ctxBg)\n\t// ctxTodo := context.TODO() // 未定の場合のプレースホルダー\n\n\t// 2. キャンセル可能 Context\n\tctxCancel, cancelFunc := context.WithCancel(ctxBg)\n\tdefer cancelFunc() // ★ 必ず cancel を呼ぶ\n\tfmt.Println(\"2. WithCancel:\", ctxCancel)\n\t// cancelFunc() // 呼ぶとキャンセルされる\n\n\t// 3. タイムアウト付き Context\n\tctxTimeout, cancelTimeout := context.WithTimeout(ctxBg, 100*time.Millisecond)\n\tdefer cancelTimeout() // ★ 必ず cancel を呼ぶ\n\tfmt.Println(\"3. WithTimeout:\", ctxTimeout)\n\n\t// 4. 値付き Context\n\tctxValue := context.WithValue(ctxBg, userIDKey, \"user-123\")\n\tfmt.Println(\"4. WithValue:\", ctxValue)\n\tretrieved := ctxValue.Value(userIDKey)\n\tfmt.Printf(\"   Value: %v (%T)\\n\", retrieved, retrieved)\n}"
    },
    {
      "title": "並行処理: Context による値の伝達 (`context.WithValue`)",
      "description": "",
      "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// Context キー用の独自型\ntype contextKey string\nconst requestIDKey contextKey = \"requestID\"\n\n// ミドルウェア: Context にリクエストIDを追加\nfunc addRequestID(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\treqID := \"req-123\" // 簡単な例\n\t\t// ★ WithValue で Context に値を追加\n\t\tctxWithID := context.WithValue(r.Context(), requestIDKey, reqID)\n\t\t// ★ 新しい Context を持つリクエストで次を呼び出す\n\t\tnext.ServeHTTP(w, r.WithContext(ctxWithID))\n\t})\n}\n\n// ハンドラ: Context からリクエストIDを取得\nfunc myHandler(w http.ResponseWriter, r *http.Request) {\n\t// ★ r.Context() で Context を取得\n\tctx := r.Context()\n\t// ★ Value() と型アサーションで値を取得\n\treqID, ok := ctx.Value(requestIDKey).(string)\n\tif !ok { reqID = \"unknown\" }\n\n\tfmt.Printf(\"[%s] ハンドラ処理\\n\", reqID)\n\tfmt.Fprintf(w, \"[%s] 完了\", reqID)\n\t// processData(ctx) // 後続処理にも ctx を渡せる\n}\n\nfunc main() {\n\thandlerWithMiddleware := addRequestID(http.HandlerFunc(myHandler))\n\thttp.Handle(\"/data\", handlerWithMiddleware)\n\tfmt.Println(\"Listening on :8080...\")\n\t// http.ListenAndServe(\":8080\", nil) // サーバー起動 (実行は省略)\n}"
    },
    {
      "title": "並行処理: Context を使ったキャンセル処理 (`ctx.Done()`, `ctx.Err()`)",
      "description": "**`context`** パッケージの主な目的は、処理の**キャンセル**や\n**タイムアウト/デッドライン**のシグナルを伝達することです。\nこれにより不要な処理を早期中断できます。\n\n**Context の受け渡し規約:**\nContext を利用する関数は、通常、**第一引数**として\n`ctx context.Context` を受け取るのが Go の慣習です。\n`func DoSomething(ctx context.Context, ...) error`\n\n**キャンセルの検知: `ctx.Done()` と `select`**\n`ctx.Done()` メソッドは受信専用チャネル (`<-chan struct{}`) を返します。\nこのチャネルは Context が**キャンセルされるとクローズ**されます。\n`select` 文でこのチャネルからの受信を待つことでキャンセルを検知できます。",
      "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\n// Context を受け取り、キャンセルをチェックする関数\nfunc longRunningTask(ctx context.Context, taskID int) error {\n\tfmt.Printf(\"Task %d: 開始\\n\", taskID)\n\tfor i := 0; i < 5; i++ {\n\t\tselect {\n\t\tcase <-ctx.Done(): // ★ Done() チャネルでキャンセルを検知\n\t\t\tfmt.Printf(\"Task %d: キャンセル (%v)\\n\", taskID, ctx.Err())\n\t\t\treturn ctx.Err() // キャンセル理由を返す\n\t\tcase <-time.After(200 * time.Millisecond): // 処理/待機を模倣\n\t\t\tfmt.Printf(\"Task %d: Step %d\\n\", taskID, i+1)\n\t\t}\n\t}\n\tfmt.Printf(\"Task %d: 正常終了\\n\", taskID)\n\treturn nil\n}\n\nfunc main() {\n\t// タイムアウト (500ms) 付き Context を作成\n\tctxTimeout, cancel := context.WithTimeout(context.Background(), 500*time.Millisecond)\n\tdefer cancel() // ★ cancel 関数を必ず呼ぶ\n\n\t// タスク実行 (1000ms かかるはず)\n\terr := longRunningTask(ctxTimeout, 1)\n\tif err != nil {\n\t\tfmt.Printf(\"Main: エラー: %v\\n\", err) // context deadline exceeded\n\t}\n}"
    },
    {
      "title": "並行処理: Context による明示的なキャンセル",
      "description": "",
      "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\n// キャンセルされるまで作業するワーカー\nfunc worker(ctx context.Context, id int, wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\tfmt.Printf(\"Worker %d: 開始\\n\", id)\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done(): // ★ キャンセルを検知\n\t\t\tfmt.Printf(\"Worker %d: キャンセル (%v)\\n\", id, ctx.Err())\n\t\t\treturn\n\t\tcase <-time.After(150 * time.Millisecond): // 作業模倣\n\t\t\tfmt.Printf(\"Worker %d: 動作中...\\n\", id)\n\t\t}\n\t}\n}\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\n\t// キャンセル可能なルート Context と cancel 関数を作成\n\tctx, cancelAll := context.WithCancel(context.Background())\n\tdefer cancelAll() // ★ main 終了時に必ず cancel を呼ぶ\n\n\tnumWorkers := 2\n\twg.Add(numWorkers)\n\tfor i := 1; i <= numWorkers; i++ {\n\t\tgo worker(ctx, i, &wg) // 同じ ctx を渡す\n\t}\n\n\ttime.Sleep(400 * time.Millisecond) // しばらく実行\n\n\tfmt.Println(\"\\nMain: キャンセル実行 (cancelAll)\")\n\tcancelAll() // ★ これで全ワーカーにキャンセルが伝播\n\n\twg.Wait() // 全ワーカーの終了を待つ\n\tfmt.Println(\"Main: 全ワーカー終了\")\n}"
    }
  ]
}