[
  {
    "title": "Basics",
    "codeExamples": [
      {
        "title": "Hello World: Goプログラムの第一歩",
        "description": "",
        "code": "package main // 実行可能なプログラムは main パッケージに属する\n\nimport \"fmt\" // フォーマット済み I/O を提供する fmt パッケージをインポート\n\n// main 関数: プログラムの実行開始地点 (エントリーポイント)\nfunc main() {\n\t// fmt.Println: 引数を標準出力に書き出し、改行を追加する\n\tfmt.Println(\"Hello, World!\")\n}",
        "tags": [
          "basics",
          "入門"
        ]
      },
      {
        "title": "変数宣言: 値を記憶する箱 (`var`)",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\t// var キーワードで変数を宣言し、初期値を設定\n\tvar message string = \"こんにちは、Go!\"\n\tvar count int = 10\n\tvar pi float64 = 3.14159\n\tvar enabled bool = true\n\n\tfmt.Println(message)\n\tfmt.Println(\"カウント:\", count)\n\tfmt.Println(\"円周率:\", pi)\n\tfmt.Println(\"有効:\", enabled)\n\n\t// 初期値を省略するとゼロ値で初期化される\n\tvar name string // \"\"\n\tvar age int     // 0\n\tfmt.Println(\"名前(初期値):\", name)\n\tfmt.Println(\"年齢(初期値):\", age)\n}",
        "tags": [
          "basics",
          "変数",
          "var",
          "ゼロ値"
        ]
      },
      {
        "title": "短縮変数宣言 `:=`: より簡潔に書く",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\t// 短縮変数宣言 `:=` を使用\n\t// var と型指定を省略でき、型は右辺から推論される\n\tlanguage := \"Go\"      // string と推論\n\tversion := 1.22       // float64 と推論\n\treleased := true      // bool と推論\n\tyear := 2009          // int と推論\n\n\tfmt.Println(language, version, released, year)\n\tfmt.Printf(\"Type of year: %T\\n\", year) // Type of year: int\n\n\t// 再代入は `=` を使う\n\tyear = 2024\n\t// year := 2025 // エラー: no new variables on left side of :=\n\n\t// 少なくとも一つ新しい変数があれば `:=` を使える\n\tyear, month := 2025, 3 // OK: month が新しい\n\tfmt.Println(year, month)\n}",
        "tags": [
          "basics",
          "変数",
          "型推論",
          ":="
        ]
      },
      {
        "title": "複数の変数をまとめて宣言する",
        "description": "関連する複数の変数を一度に宣言する方法がいくつかあります。\n\n**1. `var()` ブロック:**\n`var` キーワードの後に括弧 `()` を続け、ブロック内に複数の変数を宣言します。型が異なってもOK。パッケージレベルでも使用可能。",
        "code": "package main\n\nimport \"fmt\"\n\n// ダミー関数 (複数の値を返す)\nfunc getConfig() (string, int, bool) {\n\treturn \"localhost\", 8080, true\n}\n\nfunc main() {\n\t// `:=` を使って複数の変数を宣言・初期化\n\t// 左辺の変数と右辺の値が順番に対応\n\thost, port, enabled := \"example.com\", 443, true\n\tfmt.Println(host, port, enabled)\n\n\t// 関数の複数の戻り値を一度に受け取る\n\tserverHost, serverPort, serverEnabled := getConfig()\n\tfmt.Println(serverHost, serverPort, serverEnabled)\n\n\t// 一部の戻り値だけ必要な場合は _ を使う\n\t_, portOnly, _ := getConfig()\n\tfmt.Println(\"Port only:\", portOnly)\n}",
        "tags": [
          "basics",
          "変数",
          "var",
          ":="
        ]
      },
      {
        "title": "変数の初期化: 宣言と同時に値を設定",
        "description": "変数を宣言する際、同時に最初の値（**初期値**）を設定することを**初期化**と呼びます。初期化により、変数が意図しないゼロ値を持つことを防ぎ、コードの意図が明確になります。\n\n**初期化と型推論:**\n`var` で変数を宣言する際に初期値を指定すると、多くの場合、型指定を省略できます。Goコンパイラが初期値から型を推論するためです。\n`var 変数名 = 初期値`\n*   コンパイラが `初期値` の型を判断し、自動的に `変数名` の型を決定します。\n*   これは短縮変数宣言 `:=` と同じ型推論の仕組みです。\n*   ただし、`var` は関数外（パッケージレベル）でも使用できます。\n\nコード例では `greeting`, `number`, `ratio` が型推論によって型が決まっています。`explicitType` は型を明示的に指定しています。\n\n**関数の戻り値を使った初期化:**\n変数の初期値には、他の関数呼び出しの結果（戻り値）も使用できます。",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\t// var で宣言時に初期値を指定すると、型を省略できる (型推論)\n\tvar greeting = \"おはよう\" // string と推論\n\tvar number = 100      // int と推論\n\tvar ratio = 0.5       // float64 と推論\n\n\tfmt.Printf(\"greeting: %s (%T)\\n\", greeting, greeting)\n\tfmt.Printf(\"number: %d (%T)\\n\", number, number)\n\tfmt.Printf(\"ratio: %f (%T)\\n\", ratio, ratio)\n\n\t// 型を明示することも可能\n\tvar explicitType int = 200\n\tfmt.Printf(\"explicitType: %d (%T)\\n\", explicitType, explicitType)\n}",
        "tags": [
          "basics",
          "変数",
          "初期化",
          "型推論"
        ]
      },
      {
        "title": "ブランク識別子 `_`: 使わない値を無視する",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc main() {\n\t// 1. 関数の戻り値を一部無視\n\t// strconv.Atoi は (int, error) を返す\n\tnumericValue, _ := strconv.Atoi(\"42\") // エラーは無視\n\tfmt.Println(\"Value:\", numericValue)\n\n\t_, err := strconv.Atoi(\"abc\") // 値は無視\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t}\n\n\t// 2. for range でインデックスや値を無視\n\tnums := []int{10, 20, 30}\n\t// インデックスを無視\n\tfor _, num := range nums {\n\t\tfmt.Println(\"Num:\", num)\n\t}\n\t// 値を無視\n\tfor i := range nums { // 値を受け取る変数を省略するとインデックスのみになる\n\t\tfmt.Println(\"Index:\", i)\n\t}\n}",
        "tags": [
          "basics",
          "変数",
          "ブランク識別子",
          "_"
        ]
      },
      {
        "title": "定数宣言 `const`: 基本的な使い方",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\n// パッケージレベル定数\nconst Pi float64 = 3.14159 // 型を明示\nconst AppName = \"MyApp\"     // 型を省略 (string と推論)\nconst MaxUsers = 1000       // 型を省略 (int と推論)\nconst Enabled = true        // 型を省略 (bool と推論)\n\nfunc main() {\n\t// 関数内ローカル定数\n\tconst LocalConst = \"ローカル定数\"\n\n\tfmt.Println(\"Pi:\", Pi)\n\tfmt.Println(\"AppName:\", AppName)\n\tfmt.Println(\"MaxUsers:\", MaxUsers)\n\tfmt.Println(\"Enabled:\", Enabled)\n\tfmt.Println(\"LocalConst:\", LocalConst)\n\n\t// Pi = 3.14 // 定数は再代入不可 (コンパイルエラー)\n}",
        "tags": [
          "basics",
          "定数",
          "const",
          "基本"
        ]
      },
      {
        "title": "型無し定数 (Untyped Constant): 柔軟な型解釈",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nconst UntypedInt = 100     // 型無し整数定数\nconst UntypedFloat = 3.14   // 型無し浮動小数点定数\nconst UntypedString = \"hello\" // 型無し文字列定数\n\nfunc main() {\n\tvar i int = UntypedInt       // OK: int に代入可能\n\tvar f64 float64 = UntypedInt // OK: float64 に代入可能 (100.0)\n\tvar f32 float32 = UntypedFloat // OK: float32 に代入可能\n\tvar s string = UntypedString // OK: string に代入可能\n\n\tfmt.Println(i, f64, f32, s) // 100 100 3.14 hello\n\n\tconst TypedInt int = 200 // 型付き整数定数\n\t// var f float64 = TypedInt // コンパイルエラー: 型が違うため代入不可\n}",
        "tags": [
          "basics",
          "定数",
          "const",
          "型無し定数",
          "untyped"
        ]
      },
      {
        "title": "複数の定数をまとめて宣言 `const()`",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\n// const() ブロックで関連する定数をまとめる\nconst (\n\tStatusOK        = 200 // HTTP OK\n\tStatusNotFound  = 404 // HTTP Not Found\n\tInternalError = 500 // HTTP Internal Server Error\n\t// ... 他のステータスコード\n)\n\nfunc main() {\n\tfmt.Println(\"OK:\", StatusOK)\n\tfmt.Println(\"Not Found:\", StatusNotFound)\n\tfmt.Println(\"Error:\", InternalError)\n}",
        "tags": [
          "basics",
          "定数",
          "const"
        ]
      },
      {
        "title": "`iota`: 連続する定数を簡単に作る魔法の言葉",
        "description": "`const()` ブロック内で連続した整数値を定数として定義したい場合に便利なのが **`iota`** です。`iota` は `const` 宣言ブロック内で使われる**定数ジェネレータ**です。\n\n**基本動作:**\n*   `iota` は `const` ブロックの最初の行で `0` にリセットされます (例: `A`, `D`)。\n*   `const` ブロック内で次の行に移ると、`iota` の値は自動的に `1` 増加します (例: `B` は 1, `C` は 2)。\n*   ある行の式が省略されると、直前の行と同じ式が適用されます。例の `E` と `F` では、直前の `D = iota` の式 `iota` が適用され、その時点での `iota` の値（それぞれ 1 と 2）が設定されます。\n\n**応用例:**\n`iota` は、曜日、状態、カテゴリなど、連続した整数値で表現したい定数群（他の言語での**列挙型 (enum)** に似たもの）を定義するのに非常に便利です。",
        "code": "package main\n\nimport \"fmt\"\n\n// iota は const ブロック内で 0 から始まり、行ごとに +1 される\nconst (\n\tA = iota // 0\n\tB = iota // 1\n\tC = iota // 2\n)\n\n// 式を省略すると直前の式が繰り返される\nconst (\n\tD = iota // 0\n\tE        // 1 (iota が繰り返される)\n\tF        // 2 (iota が繰り返される)\n)\n\nfunc main() {\n\tfmt.Println(\"Block 1:\", A, B, C) // 0 1 2\n\tfmt.Println(\"Block 2:\", D, E, F) // 0 1 2\n}",
        "tags": [
          "basics",
          "定数",
          "const",
          "iota",
          "列挙型"
        ]
      },
      {
        "title": "`iota` とビット演算: ビットフラグを賢く定義する",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\n// iota とビットシフトでビットフラグを定義\nconst (\n\tReadable   = 1 << iota // 1 (001)\n\tWritable   = 1 << iota // 2 (010)\n\tExecutable = 1 << iota // 4 (100)\n)\n\nfunc main() {\n\t// フラグを組み合わせる (ビットOR)\n\treadWrite := Readable | Writable // 1 | 2 = 3 (011)\n\tfmt.Println(\"ReadWrite:\", readWrite)\n\n\t// 特定のフラグが立っているか確認 (ビットAND)\n\tcanWrite := (readWrite & Writable) != 0   // (3 & 2) != 0 -> true\n\tcanExecute := (readWrite & Executable) != 0 // (3 & 4) != 0 -> false\n\n\tfmt.Println(\"Can Write:\", canWrite)\n\tfmt.Println(\"Can Execute:\", canExecute)\n}",
        "tags": [
          "basics",
          "定数",
          "const",
          "iota",
          "ビット演算",
          "ビットフラグ"
        ]
      },
      {
        "title": "パッケージの命名規則: コードを整理する名前付け",
        "description": "",
        "code": "package main // プログラムのエントリーポイントとなる特別なパッケージ\n\nimport \"fmt\"\n// import \"net/http\" // 例: http パッケージ\n// import \"mypackage/util\" // 例: util パッケージ\n\nfunc main() {\n\tfmt.Println(\"This is the main package.\")\n}",
        "tags": [
          "basics",
          "パッケージ",
          "命名規則"
        ]
      },
      {
        "title": "エクスポートされる識別子: パッケージの外から使える名前",
        "description": "",
        "code": "// greeting パッケージ\npackage greeting\n\n// エクスポートされる定数 (大文字始まり)\nconst DefaultPrefix = \"Hello, \"\n\n// エクスポートされない定数 (小文字始まり)\nconst defaultSuffix = \"!\"\n\n// エクスポートされる関数 (大文字始まり)\nfunc Say(name string) string {\n\treturn formatMessage(name) // 内部で非公開関数を呼ぶ\n}\n\n// エクスポートされない関数 (小文字始まり)\nfunc formatMessage(name string) string {\n\treturn DefaultPrefix + name + defaultSuffix\n}\n\n// エクスポートされる型とフィールド\n// type Message struct {\n//     PublicField string\n//     privateField int // 非公開フィールド\n// }",
        "tags": [
          "basics",
          "パッケージ",
          "命名規則",
          "エクスポート",
          "公開",
          "キャメルケース"
        ]
      },
      {
        "title": "エクスポートされない識別子: パッケージ内部の名前",
        "description": "",
        "code": "package greeting\n\n// エクスポートされる定数 (比較用)\nconst DefaultPrefix = \"Hello, \"\n\n// エクスポートされない定数 (小文字始まり)\nconst defaultSuffix = \"!\"\n\n// エクスポートされる関数 (比較用)\nfunc Say(name string) string {\n\treturn formatMessage(name) // 内部で非公開関数を呼ぶ\n}\n\n// エクスポートされない関数 (小文字始まり)\nfunc formatMessage(name string) string {\n\treturn DefaultPrefix + name + defaultSuffix\n}\n\n// エクスポートされる型 (比較用)\ntype Message struct {\n\tPublicText string\n\t// エクスポートされないフィールド (小文字始まり)\n\tpriority int\n}",
        "tags": [
          "basics",
          "パッケージ",
          "命名規則",
          "非公開",
          "キャメルケース"
        ]
      },
      {
        "title": "識別子内の頭字語: HTTP, URL, ID などの扱い方",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\n// エクスポートされる例 (頭字語は大文字)\nfunc ServeHTTP() { fmt.Println(\"ServeHTTP called\") }\ntype CustomerID string\ntype APIConfig struct {\n\tAPIKey    string\n\tEndpointURL string\n}\n\n// エクスポートされない例 (識別子全体が小文字始まり)\nconst defaultUserID CustomerID = \"user-001\"\nfunc buildURL(path string) string { return \"https://example.com/\" + path }\n// func serveHTTP() {} // もし非公開ならこう書く\n\nfunc main() {\n\tServeHTTP()\n\tvar userID CustomerID = \"cust-123\"\n\tconfig := APIConfig{APIKey: \"xyz\", EndpointURL: buildURL(\"data\")}\n\tfmt.Println(userID, config.APIKey, config.EndpointURL)\n\tfmt.Println(defaultUserID)\n}",
        "tags": [
          "basics",
          "命名規則",
          "頭字語",
          "キャメルケース"
        ]
      },
      {
        "title": "インターフェースの命名: `-er` サフィックスの慣習",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\n// Logger インターフェース (Log メソッドを一つ持つ)\ntype Logger interface {\n\tLog(message string)\n}\n\n// ConsoleLogger は Logger インターフェースを実装\ntype ConsoleLogger struct{ Prefix string }\nfunc (cl ConsoleLogger) Log(message string) {\n\tfmt.Println(cl.Prefix + message)\n}\n\n// Logger インターフェースを受け取る関数\nfunc process(logger Logger, data string) {\n\tlogger.Log(\"Processing: \" + data)\n}\n\nfunc main() {\n\tmyLogger := ConsoleLogger{Prefix: \"[INFO] \"}\n\tprocess(myLogger, \"Data A\") // ConsoleLogger は Logger として渡せる\n}",
        "tags": [
          "basics",
          "命名規則",
          "インターフェース",
          "-er"
        ]
      },
      {
        "title": "パッケージとディレクトリ構造: コードの置き場所",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t// calculator パッケージをインポート\n\t// パスは \"モジュールパス/ディレクトリパス\"\n\t\"myproject/calculator\" // \"myproject\" は go.mod の module 名 (例)\n)\n\nfunc main() {\n\t// パッケージ名を使って関数を呼び出す\n\tsum := calculator.Add(5, 3)\n\tdiff := calculator.Subtract(5, 3)\n\n\tfmt.Println(\"Sum:\", sum)\n\tfmt.Println(\"Difference:\", diff)\n}\n\n// --- calculator/calculator.go (別ファイル) ---\n/*\npackage calculator // ディレクトリ名と同じパッケージ名\n\nfunc Add(a, b int) int { return a + b }\nfunc Subtract(a, b int) int { return a - b }\n*/",
        "tags": [
          "basics",
          "パッケージ",
          "ディレクトリ",
          "import"
        ]
      },
      {
        "title": "パッケージのインポート `import`: 他のコードを利用する",
        "description": "",
        "code": "package main\n\n// import() ブロックで複数のパッケージをインポート\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"strings\"\n\t\"time\"\n\t// \"github.com/google/uuid\" // サードパーティ例\n\t// \"myproject/myutils\"    // ローカルパッケージ例\n)\n\nfunc main() {\n\t// パッケージ名を使って関数や変数にアクセス\n\tupper := strings.ToUpper(\"hello\")\n\tnow := time.Now()\n\tnum := rand.Intn(10)\n\n\tfmt.Println(upper, now.Format(time.Kitchen), num)\n}",
        "tags": [
          "basics",
          "パッケージ",
          "import",
          "エイリアス",
          "ドットインポート",
          "ブランクインポート"
        ]
      }
    ]
  },
  {
    "title": "Basic Types",
    "codeExamples": [
      {
        "title": "整数 (Integer)",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar i int = -100\n\tfmt.Printf(\"int 型変数 i: 値=%d\\n\", i)\n\n\tvar r rune = 'あ'\n\tfmt.Printf(\"rune 型変数 r: 値=%c (数値=%d)\\n\", r, r)\n\n\tvar r2 rune = 12354 // 'あ' の Unicode コードポイント\n\tfmt.Printf(\"rune 型変数 r2: 値=%c\\n\", r2)\n}",
        "tags": [
          "basic-types",
          "整数",
          "int",
          "rune"
        ]
      },
      {
        "title": "符号なし整数 (Unsigned Integer)",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar u uint = 100\n\tfmt.Printf(\"uint: %d\\n\", u)\n\n\tvar u8 uint8 = 255\n\tfmt.Printf(\"uint8: %d\\n\", u8)\n\n\tvar u16 uint16 = 65535\n\tfmt.Printf(\"uint16: %d\\n\", u16)\n\n\tvar u32 uint32 = 4294967295\n\tfmt.Printf(\"uint32: %d\\n\", u32)\n\n\tvar u64 uint64 = 18446744073709551615\n\tfmt.Printf(\"uint64: %d\\n\", u64)\n\n\tvar b byte = 'A' // uint8 の別名\n\tfmt.Printf(\"byte: %d ('%c')\\n\", b, b)\n\n\tvar ptr uintptr = 0xdeadbeef // 通常は使わない\n\tfmt.Printf(\"uintptr: %x\\n\", ptr)\n}",
        "tags": [
          "basic-types",
          "整数",
          "uint",
          "byte",
          "uintptr"
        ]
      },
      {
        "title": "浮動小数点数 (Floating-Point)",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\t// float64 (デフォルト)\n\tvar pi float64 = 3.14159\n\tradius := 5.0 // 型推論で float64\n\tarea := pi * radius * radius\n\tfmt.Printf(\"Area (float64): %.5f\\n\", area)\n\n\t// float32\n\tvar gravity float32 = 9.81\n\tmass := float32(10.0) // 型変換\n\tforce := mass * gravity\n\tfmt.Printf(\"Force (float32): %.3f\\n\", force)\n\n\t// 誤差の注意点\n\tsum := 0.1 + 0.2\n\tfmt.Printf(\"0.1 + 0.2 = %.17f\\n\", sum) // 正確に 0.3 にならない可能性\n\tfmt.Printf(\"sum == 0.3 is %t\\n\", sum == 0.3)\n}",
        "tags": [
          "basic-types",
          "浮動小数点数",
          "float32",
          "float64",
          "精度"
        ]
      },
      {
        "title": "複素数 (Complex)",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\t// complex128 (デフォルト)\n\tvar c1 complex128 = 1.5 + 2.5i\n\tc2 := 3 + 4i // 型推論\n\tc3 := complex(0.5, -1.2)\n\n\tfmt.Printf(\"c1: %v (%T)\\n\", c1, c1)\n\tfmt.Printf(\"c2: %v\\n\", c2)\n\tfmt.Printf(\"c3: %v\\n\", c3)\n\n\t// 演算\n\taddResult := c1 + c2\n\tmulResult := c1 * c2\n\tfmt.Printf(\"c1 + c2 = %v\\n\", addResult)\n\tfmt.Printf(\"c1 * c2 = %v\\n\", mulResult)\n\n\t// 実部と虚部\n\tfmt.Printf(\"real(c1): %f\\n\", real(c1))\n\tfmt.Printf(\"imag(c1): %f\\n\", imag(c1))\n}",
        "tags": [
          "basic-types",
          "複素数",
          "complex64",
          "complex128"
        ]
      },
      {
        "title": "文字列 (String)",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar greeting string = \"Hello, Go!\"\n\tvar name = \"Gopher\"\n\tmessage := \"Welcome!\"\n\n\temptyStr1 := \"\"\n\tvar emptyStr2 string // ゼロ値は \"\"\n\n\tfmt.Println(greeting)\n\tfmt.Println(\"名前:\", name)\n\tfmt.Println(message)\n\tfmt.Println(\"空文字列1:\", emptyStr1)\n\tfmt.Println(\"空文字列2:\", emptyStr2)\n\n\t// greeting[0] = 'h' // コンパイルエラー (不変のため)\n\n\tnewGreeting := \"Hi, Go!\" // 新しい文字列を作成\n\tfmt.Println(\"新しい挨拶:\", newGreeting)\n}",
        "tags": [
          "basic-types",
          "文字列",
          "string",
          "不変"
        ]
      },
      {
        "title": "生文字列リテラル (Raw String Literal)",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tnormalString := \"通常文字列:\\n改行と C:\\\\Path\"\n\tfmt.Println(\"--- 通常の文字列 ---\")\n\tfmt.Println(normalString)\n\n\trawString := `生文字列リテラル:\n改行と C:\\Path (エスケープ不要)\nダブルクォート \" もそのまま書ける。`\n\tfmt.Println(\"\\n--- 生文字列 ---\")\n\tfmt.Println(rawString)\n}",
        "tags": [
          "basic-types",
          "文字列",
          "string",
          "リテラル",
          "バッククォート"
        ]
      },
      {
        "title": "文字列の基本操作 (長さ, アクセス, 部分文字列)",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\ts := \"abcdefg\"\n\n\tsub1 := s[1:3] // \"bc\"\n\tfmt.Printf(\"s[1:3] = \\\"%s\\\"\\n\", sub1)\n\n\tsub2 := s[:4] // \"abcd\"\n\tfmt.Printf(\"s[:4]  = \\\"%s\\\"\\n\", sub2)\n\n\tsub3 := s[2:] // \"cdefg\"\n\tfmt.Printf(\"s[2:]  = \\\"%s\\\"\\n\", sub3)\n\n\tsub4 := s[:] // \"abcdefg\"\n\tfmt.Printf(\"s[:]   = \\\"%s\\\"\\n\", sub4)\n\n\tfmt.Printf(\"元の文字列 s = \\\"%s\\\"\\n\", s) // 元は不変\n}",
        "tags": [
          "basic-types",
          "文字列",
          "string",
          "len",
          "インデックス",
          "スライス"
        ]
      },
      {
        "title": "文字列の連結 (結合)",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\ts1 := \"Hello\"\n\ts2 := \"World\"\n\tspace := \" \"\n\n\tgreeting := s1 + space + s2 + \"!\"\n\tfmt.Println(greeting) // Hello World!\n\n\tfmt.Println(\"元の s1:\", s1) // 元の文字列は不変\n\tfmt.Println(\"元の s2:\", s2)\n\n\tmessage := \"Go is \"\n\tmessage += \"fun!\" // += も使える\n\tfmt.Println(message) // Go is fun!\n}",
        "tags": [
          "basic-types",
          "文字列",
          "string",
          "連結",
          "+",
          "strings.Builder",
          "strings.Join"
        ]
      },
      {
        "title": "文字列と UTF-8 / Rune",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"unicode/utf8\"\n)\n\nfunc main() {\n\ts := \"Go言語\" // 4文字\n\n\tfmt.Printf(\"文字列: \\\"%s\\\"\\n\", s)\n\tfmt.Printf(\"バイト長 (len): %d\\n\", len(s)) // 8\n\n\truneCount := utf8.RuneCountInString(s)\n\tfmt.Printf(\"文字数 (RuneCount): %d\\n\", runeCount) // 4\n\n\tfmt.Println(\"\\n--- バイト単位アクセス (for i) ---\")\n\tfor i := 0; i < len(s); i++ {\n\t\tfmt.Printf(\" %d:%x\", i, s[i])\n\t}\n\tfmt.Println()\n\n\tfmt.Println(\"\\n--- 文字(Rune)単位アクセス (for range) ---\")\n\tfor i, r := range s {\n\t\tfmt.Printf(\" %d:'%c'(%U)\", i, r, r)\n\t}\n\tfmt.Println()\n}",
        "tags": [
          "basic-types",
          "文字列",
          "string",
          "rune",
          "UTF-8",
          "for range",
          "unicode/utf8"
        ]
      },
      {
        "title": "真偽値 (Boolean)",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar isGoFun bool = true\n\tvar isLearning bool // ゼロ値は false\n\n\tisEnabled := true\n\thasError := false\n\n\tfmt.Println(\"Goは楽しい？:\", isGoFun)\n\tfmt.Println(\"学習中？:\", isLearning)\n\tfmt.Println(\"有効フラグ:\", isEnabled)\n\tfmt.Println(\"エラーあり？:\", hasError)\n\n\tif isEnabled {\n\t\tfmt.Println(\"機能が有効です。\")\n\t} else {\n\t\tfmt.Println(\"機能が無効です。\")\n\t}\n\n\tif !hasError { // ! は否定演算子\n\t\tfmt.Println(\"エラーはありません。\")\n\t}\n}",
        "tags": [
          "basic-types",
          "真偽値",
          "bool",
          "true",
          "false"
        ]
      },
      {
        "title": "真偽値の演算 (論理演算)",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\ta := true\n\tb := false\n\n\t// && (AND)\n\tfmt.Printf(\"%t && %t = %t\\n\", a, b, a && b) // false\n\n\t// || (OR)\n\tfmt.Printf(\"%t || %t = %t\\n\", a, b, a || b) // true\n\n\t// ! (NOT)\n\tfmt.Printf(\"!%t = %t\\n\", a, !a) // false\n\tfmt.Printf(\"!%t = %t\\n\", b, !b) // true\n\n\t// 組み合わせ\n\tresult1 := (a || b) && a // true\n\tresult2 := !(a && b)   // true\n\tfmt.Printf(\"(%t || %t) && %t = %t\\n\", a, b, a, result1)\n\tfmt.Printf(\"!(%t && %t) = %t\\n\", a, b, result2)\n}",
        "tags": [
          "basic-types",
          "真偽値",
          "bool",
          "論理演算",
          "AND",
          "OR",
          "NOT",
          "&&",
          "||",
          "!"
        ]
      },
      {
        "title": "真偽値になる式 (比較演算)",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tage := 25\n\tscore := 85\n\tname := \"Alice\"\n\n\tif age >= 20 {\n\t\tfmt.Println(\"成人です。\")\n\t}\n\n\tif name == \"Alice\" {\n\t\tfmt.Println(\"こんにちは、Alice さん！\")\n\t}\n\n\t// 複数の条件を && (AND) で組み合わせる\n\tif age >= 20 && score >= 70 {\n\t\tfmt.Println(\"あなたは条件を満たしています。\")\n\t}\n}",
        "tags": [
          "basic-types",
          "真偽値",
          "bool",
          "比較演算子",
          "if"
        ]
      },
      {
        "title": "数値型間の明示的な変換",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar i int = 100\n\tvar f float64 = 3.14\n\n\t// 異なる型同士の演算には変換が必要\n\t// fmt.Println(i + f) // コンパイルエラー\n\n\t// int を float64 に変換\n\tresult1 := float64(i) + f\n\tfmt.Printf(\"float64(%d) + %f = %f\\n\", i, f, result1)\n\n\t// float64 を int に変換 (小数点以下切り捨て)\n\tresult2 := i + int(f) // int(3.14) は 3\n\tfmt.Printf(\"%d + int(%f) = %d\\n\", i, f, result2)\n\n\t// 異なる型への代入にも変換が必要\n\tvar f2 float64 = float64(i)\n\tfmt.Printf(\"int -> float64: %f\\n\", f2)\n\n\t// 精度低下の例\n\tvar largeF float64 = 123.789\n\tvar intFromF int = int(largeF) // 123 になる\n\tfmt.Printf(\"int(%.3f) = %d\\n\", largeF, intFromF)\n\n\t// オーバーフローの可能性 (例: int64 -> int8)\n\t// var big int64 = 1000\n\t// var small int8 = int8(big) // 範囲外だと予期しない値に\n}",
        "tags": [
          "basic-types",
          "型変換",
          "キャスト",
          "int",
          "float64",
          "uint"
        ]
      },
      {
        "title": "文字列と整数の変換 (Itoa, Atoi)",
        "description": "数値と文字列間の変換には、標準ライブラリの\n`strconv` (\"string conversion\") パッケージを使います。\n\n**整数 (`int`) から 文字列 (`string`) へ: `strconv.Itoa()`**\n`int` 型の整数を10進数表現の文字列に変換します。\n(Itoa: Integer to ASCII)\n例: `s := strconv.Itoa(123)` // s は \"123\" になる\n\n**文字列 (`string`) から 整数 (`int`) へ: `strconv.Atoi()`**\n10進数表現の文字列を `int` 型の整数に変換します。\n(Atoi: ASCII to Integer)\n\n**重要: `Atoi` のエラー処理**\n文字列から数値への変換は、文字列が数値として\n解釈できない場合に**失敗する可能性**があります。\nそのため、`Atoi` は2つの値を返します。\n1.  変換後の `int` 値 (成功時)\n2.  `error` 値 (成功時は `nil`, 失敗時はエラー情報)\n\n**`Atoi` を使う際は、必ずエラーチェックを行います。**",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tstr1 := \"9876\"\n\tstr2 := \" -123 \"\n\tstr3 := \"456abc\" // 変換不可\n\tstr4 := \"123.45\" // 整数ではない\n\n\tnum1, err1 := strconv.Atoi(str1)\n\tif err1 != nil {\n\t\tfmt.Printf(\"エラー(%s): %v\\n\", str1, err1)\n\t} else {\n\t\tfmt.Printf(\"%s -> %d (%T)\\n\", str1, num1, num1)\n\t}\n\n\tnum2, err2 := strconv.Atoi(str2)\n\tif err2 != nil {\n\t\tfmt.Printf(\"エラー(%s): %v\\n\", str2, err2)\n\t} else {\n\t\tfmt.Printf(\"%s -> %d (%T)\\n\", str2, num2, num2)\n\t}\n\n\t_, err3 := strconv.Atoi(str3) // 結果は使わないがエラーはチェック\n\tif err3 != nil {\n\t\tfmt.Printf(\"エラー(%s): %v\\n\", str3, err3)\n\t}\n\n\t_, err4 := strconv.Atoi(str4)\n\tif err4 != nil {\n\t\tfmt.Printf(\"エラー(%s): %v\\n\", str4, err4)\n\t}\n}",
        "tags": [
          "basic-types",
          "型変換",
          "文字列",
          "string",
          "整数",
          "int",
          "strconv",
          "Itoa",
          "Atoi",
          "エラー処理"
        ]
      },
      {
        "title": "文字列とバイトスライス (`[]byte`) の変換",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\ts := \"Hello Go!\"\n\tfmt.Printf(\"元の文字列: \\\"%s\\\" (%T)\\n\", s, s)\n\n\t// string から []byte へ変換\n\tbyteSlice := []byte(s)\n\tfmt.Printf(\"変換後のバイトスライス: %v (%T)\\n\", byteSlice, byteSlice)\n\n\tfmt.Print(\"バイトスライスの各要素 (ASCII): \")\n\tfor _, b := range byteSlice {\n\t\tfmt.Printf(\"%d \", b)\n\t}\n\tfmt.Println()\n\n\t// バイトスライスは変更可能\n\tif len(byteSlice) > 0 {\n\t\tbyteSlice[0] = 'J' // 'H' (72) -> 'J' (74)\n\t}\n\tfmt.Printf(\"変更後のバイトスライス: %v\\n\", byteSlice)\n\n\t// 元の文字列 s は不変\n\tfmt.Printf(\"元の文字列は不変: \\\"%s\\\"\\n\", s)\n}",
        "tags": [
          "basic-types",
          "型変換",
          "文字列",
          "string",
          "バイトスライス",
          "byte",
          "[]byte"
        ]
      },
      {
        "title": "数値文字列の解析 (Parse)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc main() {\n\t// 10進数\n\ti10, err1 := strconv.ParseInt(\"-123\", 10, 64)\n\tif err1 == nil {\n\t\tfmt.Printf(\"\\\"-123\\\" (10進) -> %d\\n\", i10)\n\t}\n\n\t// 16進数 (base=0 で自動判別)\n\ti16, err2 := strconv.ParseInt(\"0xFF\", 0, 64)\n\tif err2 == nil {\n\t\tfmt.Printf(\"\\\"0xFF\\\" (16進) -> %d\\n\", i16) // 255\n\t}\n\n\t// 2進数 (base=0, bitSize=8)\n\ti2, err3 := strconv.ParseInt(\"0b1011\", 0, 8)\n\tif err3 == nil {\n\t\tfmt.Printf(\"\\\"0b1011\\\" (2進) -> %d (int8: %d)\\n\", i2, int8(i2)) // 11\n\t}\n\n\t// 符号なし整数\n\tu10, err4 := strconv.ParseUint(\"456\", 10, 64)\n\tif err4 == nil {\n\t\tfmt.Printf(\"\\\"456\\\" (10進) -> %d\\n\", u10)\n\t}\n\n\t// エラー例: 範囲外\n\t_, err5 := strconv.ParseInt(\"300\", 10, 8) // int8 は -128~127\n\tif err5 != nil {\n\t\tfmt.Printf(\"エラー (\\\"300\\\" as int8): %v\\n\", err5)\n\t}\n\n\t// エラー例: 不正な文字\n\t_, err6 := strconv.ParseInt(\"12a3\", 10, 64)\n\tif err6 != nil {\n\t\tfmt.Printf(\"エラー (\\\"12a3\\\"): %v\\n\", err6)\n\t}\n}",
        "tags": [
          "basic-types",
          "型変換",
          "文字列",
          "string",
          "数値",
          "strconv",
          "ParseFloat",
          "ParseInt",
          "ParseUint",
          "エラー処理"
        ]
      },
      {
        "title": "値の文字列へのフォーマット (Format)",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tname := \"Gopher\"\n\tage := 13\n\tpi := 3.14159\n\n\tmessage := fmt.Sprintf(\"名前: %s, 年齢: %d歳\", name, age)\n\tfmt.Println(message)\n\n\tpiStr := fmt.Sprintf(\"円周率: %.2f\", pi)\n\tfmt.Println(piStr)\n\n\tnumStr := fmt.Sprintf(\"商品番号: %06d\", 123)\n\tfmt.Println(numStr)\n\n\ttypeStr := fmt.Sprintf(\"変数 age の型は %T です\", age)\n\tfmt.Println(typeStr)\n\n\ttype Point struct{ X, Y int }\n\tp := Point{10, 20}\n\tstructStr1 := fmt.Sprintf(\"Point: %v\", p)\n\tstructStr2 := fmt.Sprintf(\"Point: %+v\", p)\n\tstructStr3 := fmt.Sprintf(\"Point: %#v\", p)\n\tfmt.Println(structStr1)\n\tfmt.Println(structStr2)\n\tfmt.Println(structStr3)\n}",
        "tags": [
          "basic-types",
          "型変換",
          "文字列",
          "string",
          "フォーマット",
          "strconv",
          "FormatBool",
          "FormatFloat",
          "FormatInt",
          "FormatUint",
          "fmt",
          "Sprintf"
        ]
      },
      {
        "title": "ゼロ値 (Zero Value)",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\ntype Point struct {\n\tX, Y int\n}\n\nfunc main() {\n\tvar i int\n\tvar f float64\n\tvar b bool\n\tvar s string\n\tvar p *int // ポインタ\n\tvar slice []int\n\tvar mp map[string]int\n\tvar pt Point // 構造体\n\n\tfmt.Printf(\"int:     %d\\n\", i)\n\tfmt.Printf(\"float64: %f\\n\", f)\n\tfmt.Printf(\"bool:    %t\\n\", b)\n\tfmt.Printf(\"string:  \\\"%s\\\"\\n\", s)\n\tfmt.Printf(\"pointer: %v\\n\", p)\n\tfmt.Printf(\"slice:   %v (len=%d)\\n\", slice, len(slice))\n\tfmt.Printf(\"map:     %v (len=%d)\\n\", mp, len(mp))\n\tfmt.Printf(\"struct:  %+v\\n\", pt)\n}",
        "tags": [
          "basic-types",
          "ゼロ値",
          "初期化",
          "nil"
        ]
      }
    ]
  },
  {
    "title": "Flow Control",
    "codeExamples": [
      {
        "title": "制御構文: 条件分岐 `if`, `else if`, `else`",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\ttemperature := 25\n\n\tif temperature >= 30 {\n\t\tfmt.Println(\"暑いですね！\")\n\t} else if temperature >= 15 {\n\t\tfmt.Println(\"過ごしやすい気温です。\")\n\t} else if temperature >= 0 {\n\t\tfmt.Println(\"少し肌寒いですね。\")\n\t} else {\n\t\tfmt.Println(\"とても寒いです！\")\n\t}\n}",
        "tags": [
          "flow-control",
          "if",
          "else if",
          "else",
          "条件分岐"
        ]
      },
      {
        "title": "制御構文: `if` 文と短い初期化ステートメント",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n)\n\nfunc getRandomValue() int {\n\treturn rand.Intn(20) // 0-19 の乱数\n}\n\nfunc main() {\n\tif value := getRandomValue(); value > 10 {\n\t\tfmt.Printf(\"値 %d は 10 より大きい\\n\", value)\n\t} else if value > 5 {\n\t\tfmt.Printf(\"値 %d は 5 より大きく 10 以下\\n\", value)\n\t} else {\n\t\tfmt.Printf(\"値 %d は 5 以下\\n\", value)\n\t}\n\t// fmt.Println(value) // エラー: value は if の外では未定義\n}",
        "tags": [
          "flow-control",
          "if",
          "初期化ステートメント",
          "スコープ"
        ]
      },
      {
        "title": "制御構文: `if` 文を使ったエラーチェック",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\n// エラーを返す可能性のある関数 (例)\nfunc processData(input string) (string, error) {\n\tval, err := strconv.Atoi(input)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"変換失敗: %w\", err) // エラー時は nil 以外を返す\n\t}\n\treturn fmt.Sprintf(\"結果: %d\", val*2), nil // 成功時は nil を返す\n}\n\nfunc main() {\n\tinput := \"123\" // または \"abc\" などエラーになる入力\n\n\t// if の初期化ステートメントで関数を呼び出し、エラーをチェック\n\tif result, err := processData(input); err != nil {\n\t\t// エラー処理 (err はこの if ブロック内でのみ有効)\n\t\tfmt.Printf(\"'%s' の処理エラー: %v\\n\", input, err)\n\t} else {\n\t\t// 正常処理 (result と err はこの else ブロック内でのみ有効)\n\t\tfmt.Printf(\"'%s' の処理成功: %s\\n\", input, result)\n\t}\n\t// fmt.Println(err) // エラー: err は if の外では未定義\n}",
        "tags": [
          "flow-control",
          "if",
          "エラー処理",
          "error",
          "nil"
        ]
      },
      {
        "title": "制御構文: `return` 後の `else` を避けるスタイル (早期リターン)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc processIfNotEmptyEarlyReturn(input string) (string, error) {\n\t// 先に異常系のチェックとリターン (ガード節)\n\tif input == \"\" {\n\t\treturn \"\", errors.New(\"入力が空です\")\n\t}\n\n\t// ここから下は input が空でないことが保証される\n\t// 正常系の処理がインデントされずに書ける\n\tprocessed := \"処理結果: \" + input\n\tfmt.Println(\"正常系の処理を実行中...\")\n\treturn processed, nil\n}\n\nfunc main() {\n\tres1, err1 := processIfNotEmptyEarlyReturn(\"データあり\")\n\tif err1 != nil { fmt.Println(\"エラー:\", err1) } else { fmt.Println(res1) }\n\n\tres2, err2 := processIfNotEmptyEarlyReturn(\"\")\n\tif err2 != nil { fmt.Println(\"エラー:\", err2) } else { fmt.Println(res2) }\n}",
        "tags": [
          "flow-control",
          "if",
          "else",
          "return",
          "エラー処理",
          "コーディングスタイル",
          "早期リターン",
          "ガード節"
        ]
      },
      {
        "title": "制御構文: 繰り返し処理 `for` (基本形)",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"--- 0から4までカウントアップ ---\")\n\tfor i := 0; i < 5; i++ {\n\t\tfmt.Println(\"現在の i:\", i)\n\t}\n\t// fmt.Println(i) // エラー: i はループの外では未定義\n}",
        "tags": [
          "flow-control",
          "for",
          "ループ",
          "繰り返し"
        ]
      },
      {
        "title": "制御構文: `for` を `while` ループとして使う",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tsum := 0\n\tnum := 1\n\n\t// sum が 100 以下の間ループ (while sum <= 100)\n\tfor sum <= 100 {\n\t\tsum += num\n\t\tnum++\n\t\tfmt.Printf(\"num=%d, sum=%d\\n\", num-1, sum)\n\t}\n\n\tfmt.Printf(\"\\n最終合計: %d\\n\", sum)\n}",
        "tags": [
          "flow-control",
          "for",
          "while",
          "ループ",
          "繰り返し"
        ]
      },
      {
        "title": "制御構文: 無限ループ `for {}` と `break`",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tcount := 0\n\tfmt.Println(\"無限ループ開始 (5回で break)\")\n\n\tfor { // 条件式を省略すると無限ループ\n\t\tcount++\n\t\tfmt.Printf(\"ループ %d 回目\\n\", count)\n\n\t\tif count >= 5 {\n\t\t\tfmt.Println(\"break します。\")\n\t\t\tbreak // ループを終了\n\t\t}\n\t}\n\n\tfmt.Println(\"ループ終了。\")\n}",
        "tags": [
          "flow-control",
          "for",
          "無限ループ",
          "ループ",
          "繰り返し",
          "break"
        ]
      },
      {
        "title": "制御構文: `for range` ループ (配列, スライス, 文字列)",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\t// 配列の例\n\tprimes := [4]int{2, 3, 5, 7}\n\tfmt.Println(\"--- 配列の for range ---\")\n\tfor index, value := range primes {\n\t\tfmt.Printf(\"インデックス %d: 値 %d\\n\", index, value)\n\t}\n\n\t// 値だけが必要な場合 (インデックスを _ で無視)\n\tfmt.Println(\"\\n--- 値だけを使う場合 ---\")\n\tsum := 0\n\tnums := []int{10, 20, 30} // スライス\n\tfor _, num := range nums {\n\t\tsum += num\n\t}\n\tfmt.Printf(\"合計: %d\\n\", sum)\n\n\t// インデックスだけが必要な場合\n\t// for i := range nums { fmt.Println(i) }\n}",
        "tags": [
          "flow-control",
          "for",
          "for range",
          "ループ",
          "繰り返し",
          "配列",
          "スライス",
          "文字列",
          "rune"
        ]
      },
      {
        "title": "制御構文: `for range` ループ (マップ)",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tscores := map[string]int{\n\t\t\"Alice\": 85,\n\t\t\"Bob\":   92,\n\t\t\"Carol\": 78,\n\t}\n\n\tfmt.Println(\"--- マップのキーと値 ---\")\n\t// キー(name)と値(score)を取得\n\tfor name, score := range scores {\n\t\tfmt.Printf(\"名前: %s, 点数: %d\\n\", name, score)\n\t}\n\t// 順序は保証されない！\n\n\tfmt.Println(\"\\n--- キーだけを使う場合 ---\")\n\t// 値を受け取る変数を省略するとキーのみ取得\n\tfor name := range scores {\n\t\tfmt.Printf(\"名前: %s\\n\", name)\n\t}\n\n\t// 値だけを使う場合\n\t// for _, score := range scores { ... }\n}",
        "tags": [
          "flow-control",
          "for",
          "for range",
          "ループ",
          "繰り返し",
          "マップ",
          "map"
        ]
      },
      {
        "title": "制御構文: `for range` ループ (チャネル)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\" // 説明のため短時間スリープさせるのに使用\n)\n\nfunc main() {\n\tmessageChannel := make(chan int)\n\n\t// 別 Goroutine で値を送信\n\tgo func() {\n\t\tfor i := 1; i <= 3; i++ {\n\t\t\tfmt.Printf(\"送信: %d\\n\", i)\n\t\t\tmessageChannel <- i\n\t\t\ttime.Sleep(10 * time.Millisecond) // 送受信の様子を見るため少し待つ\n\t\t}\n\t\tclose(messageChannel) // ★重要: 送信完了後にクローズ\n\t\tfmt.Println(\"送信側: チャネルクローズ完了\")\n\t}()\n\n\tfmt.Println(\"受信側: ループ開始\")\n\t// チャネルから値を受信 (チャネルがクローズされるまで)\n\tfor value := range messageChannel {\n\t\tfmt.Printf(\"受信: %d\\n\", value)\n\t}\n\tfmt.Println(\"受信側: ループ終了 (チャネルクローズのため)\")\n}",
        "tags": [
          "flow-control",
          "for",
          "for range",
          "ループ",
          "繰り返し",
          "チャネル",
          "channel",
          "並行処理",
          "close"
        ]
      },
      {
        "title": "制御構文: `for range` でインデックスや値を無視する",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\t// スライスの例\n\tnumbers := []int{10, 20, 30, 40}\n\n\tfmt.Println(\"--- 値のみ (スライス) ---\")\n\tsum := 0\n\tfor _, value := range numbers { // インデックスを _ で無視\n\t\tfmt.Printf(\"値: %d\\n\", value)\n\t\tsum += value\n\t}\n\tfmt.Printf(\"合計: %d\\n\", sum)\n\n\t// マップの例\n\tconfig := map[string]string{\n\t\t\"host\": \"localhost\", \"port\": \"8080\", \"user\": \"admin\",\n\t}\n\n\tfmt.Println(\"\\n--- キーのみ (マップ) ---\")\n\tfor key, _ := range config { // 値を _ で無視\n\t\tfmt.Printf(\"設定キー: %s\\n\", key)\n\t}\n\n\tfmt.Println(\"\\n--- 値のみ (マップ) ---\")\n\tfor _, value := range config { // キーを _ で無視\n\t\tfmt.Printf(\"設定値: %s\\n\", value)\n\t}\n}",
        "tags": [
          "flow-control",
          "for",
          "for range",
          "ループ",
          "繰り返し",
          "ブランク識別子",
          "_"
        ]
      },
      {
        "title": "制御構文: 条件分岐 `switch` (基本形)",
        "description": "一つの変数の値に基づいて多数の分岐を行いたい場合、\n`if-else if-else` よりも **`switch`** 文が\n簡潔に書けることがあります。\n\n**基本構文:**",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\ttoday := time.Now().Weekday()\n\tfmt.Printf(\"今日は %s です。\\n\", today)\n\n\tswitch today {\n\tcase time.Saturday, time.Sunday: // 複数の値を指定\n\t\tfmt.Println(\"週末です！\")\n\tcase time.Friday:\n\t\tfmt.Println(\"金曜日！あと一日！\")\n\tdefault: // 上記以外 (月〜木)\n\t\tfmt.Println(\"平日です。頑張りましょう！\")\n\t}\n}",
        "tags": [
          "flow-control",
          "switch",
          "case",
          "default",
          "条件分岐"
        ]
      },
      {
        "title": "制御構文: 式を省略した `switch` 文",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc getGradeSwitch(score int) string {\n\tgrade := \"\"\n\tswitch { // 式を省略 (switch true と同じ)\n\tcase score >= 90:\n\t\tgrade = \"A\"\n\tcase score >= 80:\n\t\tgrade = \"B\"\n\tcase score >= 70:\n\t\tgrade = \"C\"\n\tcase score >= 60:\n\t\tgrade = \"D\"\n\tdefault:\n\t\tgrade = \"F\"\n\t}\n\treturn grade\n}\n\nfunc main() {\n\tfmt.Printf(\"85点の成績: %s\\n\", getGradeSwitch(85)) // B\n\tfmt.Printf(\"55点の成績: %s\\n\", getGradeSwitch(55)) // F\n}",
        "tags": [
          "flow-control",
          "switch",
          "case",
          "default",
          "条件分岐",
          "if"
        ]
      },
      {
        "title": "制御構文: `switch` 文と初期化ステートメント",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n)\n\n// ランダムなステータスコードを返す (例)\nfunc getStatusCode() int {\n\tcodes := []int{200, 400, 404, 500, 503}\n\treturn codes[rand.Intn(len(codes))]\n}\n\nfunc main() {\n\t// 初期化ステートメントで値を取得し、switch で評価\n\tswitch code := getStatusCode(); code {\n\tcase 200:\n\t\tfmt.Println(\"ステータス: OK (200)\")\n\tcase 400:\n\t\tfmt.Println(\"ステータス: Bad Request (400)\")\n\tcase 404:\n\t\tfmt.Println(\"ステータス: Not Found (404)\")\n\tcase 500:\n\t\tfmt.Println(\"ステータス: Internal Server Error (500)\")\n\tdefault:\n\t\tfmt.Printf(\"ステータス: 不明 (%d)\\n\", code)\n\t}\n\t// fmt.Println(code) // エラー: code は switch の外では未定義\n}",
        "tags": [
          "flow-control",
          "switch",
          "case",
          "default",
          "初期化ステートメント",
          "スコープ"
        ]
      },
      {
        "title": "制御構文: `switch` 文での `fallthrough`",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tnumber := 2\n\tfmt.Printf(\"数値 %d の評価:\\n\", number)\n\n\tswitch number {\n\tcase 1:\n\t\tfmt.Println(\" - case 1\")\n\tcase 2:\n\t\tfmt.Println(\" - case 2\")\n\t\tfallthrough // 次の case 3 へ\n\tcase 3:\n\t\tfmt.Println(\" - case 3 (fallthrough)\") // number==2 でも実行される\n\tcase 4:\n\t\tfmt.Println(\" - case 4\")\n\t\tfallthrough // 次の default へ\n\tdefault:\n\t\tfmt.Println(\" - default (case 4 から fallthrough)\")\n\t}\n}",
        "tags": [
          "flow-control",
          "switch",
          "case",
          "fallthrough"
        ]
      },
      {
        "title": "制御構文: 型スイッチ (Type Switch)",
        "description": "Goのインターフェース型、特に空インターフェース `any`\n(`interface{}`) は、任意の型の値を保持できます。\nインターフェース変数に格納された値の**実際の型**に\n基づいて処理を分岐させたい場合に**型スイッチ**を使います。\nこれは `switch` 文の特殊な形式です。\n\n**構文:**",
        "code": "package main\n\nimport \"fmt\"\n\nfunc printTypeAndValue(value any) { // any は interface{} のエイリアス\n\tfmt.Printf(\"入力: %v, \", value)\n\n\tswitch v := value.(type) { // 型スイッチ\n\tcase nil:\n\t\tfmt.Println(\"型: nil\")\n\tcase int:\n\t\tfmt.Printf(\"型: int, 値*2: %d\\n\", v*2) // v は int\n\tcase string:\n\t\tfmt.Printf(\"型: string, 値: %s\\n\", v) // v は string\n\tcase bool:\n\t\tfmt.Printf(\"型: bool, 値: %t\\n\", v) // v は bool\n\tdefault:\n\t\tfmt.Printf(\"型: 不明 (%T)\\n\", v) // v は元の型 (any)\n\t}\n}\n\nfunc main() {\n\tprintTypeAndValue(123)\n\tprintTypeAndValue(\"Hello\")\n\tprintTypeAndValue(true)\n\tprintTypeAndValue(nil)\n\tprintTypeAndValue(1.23) // default にマッチ\n}",
        "tags": [
          "flow-control",
          "switch",
          "case",
          "type",
          "インターフェース",
          "interface",
          "any",
          "型アサーション"
        ]
      },
      {
        "title": "制御構文: `defer` による後処理の予約",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\n// ファイルを作成し、テキストを書き込む関数 (defer の例)\nfunc writeFile(filename, text string) error {\n\tfile, err := os.Create(filename)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"ファイル作成失敗: %w\", err)\n\t}\n\t// ★ファイルを開いた直後にクローズ処理を defer で予約\n\tdefer file.Close()\n\tfmt.Println(\"defer file.Close() を登録\")\n\n\t_, err = file.WriteString(text)\n\tif err != nil {\n\t\t// エラーで return する場合も defer は実行される\n\t\treturn fmt.Errorf(\"ファイル書き込み失敗: %w\", err)\n\t}\n\n\tfmt.Println(\"書き込み成功、関数終了\")\n\t// 正常に return する場合も defer は実行される\n\treturn nil\n}\n\n// main 関数 (呼び出し例) は省略\n// func main() {\n// \twriteFile(\"temp.txt\", \"Hello defer\")\n// \tos.Remove(\"temp.txt\")\n// }",
        "tags": [
          "flow-control",
          "defer",
          "クリーンアップ",
          "リソース解放",
          "関数"
        ]
      },
      {
        "title": "制御構文: 複数の `defer` と実行順序 (LIFO)",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"main: 開始\")\n\n\tdefer fmt.Println(\"defer 1 (最後に実行)\") // 1番目に defer\n\tdefer fmt.Println(\"defer 2\")             // 2番目に defer\n\tdefer fmt.Println(\"defer 3 (最初に実行)\") // 3番目に defer\n\n\tfmt.Println(\"main: 終了前\")\n\t// main 関数終了直前に defer 3 -> defer 2 -> defer 1 の順で実行\n}",
        "tags": [
          "flow-control",
          "defer",
          "LIFO",
          "スタック",
          "関数"
        ]
      },
      {
        "title": "制御構文: `defer` される関数の引数評価タイミング",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc printValue(prefix string, value int) {\n\tfmt.Printf(\"%s: %d\\n\", prefix, value)\n}\n\nfunc main() {\n\ti := 0\n\tfmt.Printf(\"初期値 i = %d\\n\", i)\n\n\t// defer 実行時に i の値 (0) が評価・記憶される\n\tdefer printValue(\"defer 1\", i)\n\n\ti++\n\tfmt.Printf(\"i++ 後 i = %d\\n\", i)\n\n\t// defer 実行時に i の値 (1) が評価・記憶される\n\tdefer printValue(\"defer 2\", i)\n\n\ti++\n\tfmt.Printf(\"さらに i++ 後 i = %d\\n\", i)\n\n\tfmt.Println(\"main 関数終了直前\")\n\t// LIFO順で実行: defer 2 (引数1), defer 1 (引数0)\n}",
        "tags": [
          "flow-control",
          "defer",
          "引数評価",
          "関数"
        ]
      },
      {
        "title": "制御構文: `defer` とミューテックス (`sync.Mutex`)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\n// 共有データとMutexを持つ構造体\ntype SafeCounter struct {\n\tmu    sync.Mutex\n\tvalue int\n}\n\n// 値を安全にインクリメントするメソッド\nfunc (c *SafeCounter) Increment() {\n\tc.mu.Lock() // ロック取得\n\t// ★ Lock() の直後に Unlock() を defer で予約\n\tdefer c.mu.Unlock()\n\n\t// --- クリティカルセクション ---\n\tc.value++\n\tfmt.Printf(\"インクリメント実行中: %d\\n\", c.value)\n\t// --- クリティカルセクション終了 ---\n\t// 関数終了時に defer された Unlock が実行される\n}\n\n// main 関数 (呼び出し例) は省略\n// func main() {\n// \tcounter := SafeCounter{}\n// \t// 複数の Goroutine から counter.Increment() を呼び出す\n// }",
        "tags": [
          "flow-control",
          "defer",
          "mutex",
          "sync",
          "並行処理",
          "ロック",
          "アンロック",
          "リソース解放"
        ]
      },
      {
        "title": "制御構文: パニック `panic`",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc divide(a, b int) int {\n\tfmt.Printf(\"divide(%d, %d) 呼び出し\\n\", a, b)\n\tdefer fmt.Printf(\"divide(%d, %d) 終了\\n\", a, b) // panic でも実行される\n\n\tif b == 0 {\n\t\tpanic(\"ゼロ除算エラー！\") // 意図的な panic\n\t}\n\treturn a / b // panic が発生すると実行されない\n}\n\nfunc main() {\n\tfmt.Println(\"--- 意図的な panic ---\")\n\t// divide(10, 0) // コメント解除で panic 発生\n\tfmt.Println(\"divide(10, 2) 結果:\", divide(10, 2))\n\n\tfmt.Println(\"\\nmain 関数終了\")\n}\n\n/*\ndivide(10, 0) 実行時の出力例:\n--- 意図的な panic ---\ndivide(10, 0) 呼び出し\ndivide(10, 0) 終了\npanic: ゼロ除算エラー！\n\ngoroutine 1 [running]:\nmain.divide(...)\n        ...\nmain.main()\n        ...\nexit status 2\n*/",
        "tags": [
          "flow-control",
          "panic",
          "エラー処理",
          "defer",
          "ランタイムエラー"
        ]
      },
      {
        "title": "制御構文: パニックからの回復 `recover`",
        "description": "`panic` は通常プログラムを異常終了させますが、\n組み込み関数 **`recover`** を使うと、\n`panic` から**回復**し実行を継続できます。\n\n**`recover` とは？**\n`panic` で中断された Goroutine の制御を取り戻す関数です。\n\n**重要ルール:**\n`recover` は **`defer` された関数の中で\n呼び出された場合にのみ**効果を発揮します。\n\n**動作:**\n*   Goroutine が `panic` 中に `defer` 内で `recover()` が\n    呼ばれると、`recover` は `panic` に渡された値を返し、\n    プログラムの異常終了プロセスが停止します。\n    `defer` 関数の完了後、通常の実行が再開されます\n    (panic発生関数の呼び出し元に戻る)。\n*   `panic` していない場合や `defer` 外で呼ばれた場合、\n    `recover` は `nil` を返します。\n\n**使い方: `defer` との組み合わせ**\n通常、`defer func() { ... }()` 内で `recover` を呼び出します。",
        "code": "package main\n\nimport \"fmt\"\n\nfunc mightPanic(shouldPanic bool) (result string, err error) {\n\t// defer + 無名関数 + recover で panic を捕捉\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\t// panic が発生した場合、r は panic 値\n\t\t\tfmt.Printf(\"Recovered from panic: %v\\n\", r)\n\t\t\t// panic を通常の error に変換して返す\n\t\t\terr = fmt.Errorf(\"内部 panic: %v\", r)\n\t\t}\n\t}()\n\n\tif shouldPanic {\n\t\tfmt.Println(\"Panic を発生させます...\")\n\t\tpanic(\"意図的なパニック\")\n\t}\n\n\tfmt.Println(\"Panic は発生しませんでした。\")\n\tresult = \"正常終了\"\n\treturn result, nil // err は nil (ゼロ値)\n}\n\nfunc main() {\n\tfmt.Println(\"--- panic する場合 ---\")\n\tres, err := mightPanic(true)\n\tif err != nil {\n\t\tfmt.Printf(\"エラー: %v\\n\", err) // recover で設定されたエラー\n\t} else {\n\t\tfmt.Printf(\"結果: %s\\n\", res)\n\t}\n\tfmt.Println(\"main 終了 (panic せずに到達)\")\n}",
        "tags": [
          "flow-control",
          "panic",
          "recover",
          "defer",
          "エラー処理"
        ]
      },
      {
        "title": "制御構文: `panic` と `recover` の適切な使い方",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\n// panic を起こす可能性があり、内部で recover する関数\nfunc SafeDivide(a, b int) (result int, err error) {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\terr = fmt.Errorf(\"panic を回復: %v\", r)\n\t\t}\n\t}()\n\tresult = a / b // b が 0 だと panic する\n\treturn result, nil\n}\n\nfunc main() {\n\tfmt.Println(\"--- 正常な除算 ---\")\n\tres1, err1 := SafeDivide(10, 2)\n\tif err1 != nil { fmt.Println(\"エラー:\", err1) } else { fmt.Printf(\"結果: %d\\n\", res1) }\n\n\tfmt.Println(\"\\n--- ゼロ除算 (panic -> error) ---\")\n\tres2, err2 := SafeDivide(10, 0) // panic するが recover される\n\tif err2 != nil {\n\t\tfmt.Println(\"エラー:\", err2) // recover で設定された error\n\t} else {\n\t\tfmt.Printf(\"結果: %d\\n\", res2)\n\t}\n\tfmt.Println(\"\\nプログラムは正常終了\")\n}",
        "tags": [
          "flow-control",
          "panic",
          "recover",
          "error",
          "エラー処理",
          "ベストプラクティス"
        ]
      }
    ]
  },
  {
    "title": "Functions",
    "codeExamples": [
      {
        "title": "関数: 処理をまとめる部品",
        "description": "**関数 (Function)** は、特定のタスクを実行する\n一連の処理をまとめ、名前を付けて再利用可能にした部品です。\n\n**なぜ使うか？**\n*   **再利用性:** 同じコードを繰り返し書かなくて済む。\n*   **可読性:** 処理に名前が付き、コードが理解しやすくなる。\n*   **保守性:** 修正箇所が関数の定義だけで済む。\n*   **モジュール化:** プログラムを機能単位に分割できる。\n\n**基本構文:**",
        "code": "package main\n\nimport \"fmt\"\n\n// 2つの int 引数を取り、合計 (int) を返す関数\nfunc add(a int, b int) int {\n\tsum := a + b\n\treturn sum // 戻り値を返す\n}\n\nfunc main() {\n\t// add 関数を呼び出し、戻り値を受け取る\n\tresult1 := add(5, 3)\n\tfmt.Printf(\"add(5, 3) = %d\\n\", result1) // 8\n\n\tresult2 := add(10, -2)\n\tfmt.Printf(\"add(10, -2) = %d\\n\", result2) // 8\n}",
        "tags": [
          "functions",
          "func",
          "引数",
          "パラメータ",
          "戻り値",
          "return"
        ]
      },
      {
        "title": "関数: 引数の型指定をまとめる",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\n// x と y は両方とも int 型\nfunc multiply(x, y int) int {\n\treturn x * y\n}\n\n// width と height は int 型、label は string 型\nfunc drawRectangle(width, height int, label string) {\n\tfmt.Printf(\"描画: 幅=%d, 高さ=%d, ラベル=\\\"%s\\\"\\n\", width, height, label)\n}\n\nfunc main() {\n\tproduct := multiply(6, 7)\n\tfmt.Printf(\"multiply(6, 7) = %d\\n\", product)\n\n\tdrawRectangle(100, 50, \"ボタン\")\n}",
        "tags": [
          "functions",
          "func",
          "引数",
          "パラメータ"
        ]
      },
      {
        "title": "関数: 複数の戻り値",
        "description": "Goの関数は**複数の値を返す**ことができます。\nこれはGoの特徴的で便利な機能です。\n\n**宣言方法:**\n戻り値の型指定部分を `()` で囲み、\n返す値の型をカンマ `,` で区切って列挙します。\n`func 関数名(...) (戻り値1の型, 戻り値2の型, ...)`\n\n**返し方:**\n`return` 文で、宣言した型と順序に合わせて\n値をカンマ区切りで返します。\n`return 値1, 値2, ...`\n\n**受け取り方:**\n関数呼び出しの左辺で、複数の変数をカンマ区切りで\n記述し、それぞれの戻り値を代入します。\n`var1, var2, ... := 関数名(...)`\n\n**戻り値の無視:**\n不要な戻り値はブランク識別子 `_` で無視できます。\n`q, _, err := divideAndRemainder(...)`\n\n**エラー処理での活用:**\nGoでは、処理結果とエラー情報を一緒に返すために\n複数の戻り値が非常によく使われます。\n最後の戻り値を `error` 型にするのが一般的です。",
        "code": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\n// 商 (int) と 余り (int) と エラー (error) の3つを返す\nfunc divideAndRemainder(a, b int) (int, int, error) {\n\tif b == 0 {\n\t\treturn 0, 0, errors.New(\"ゼロ除算エラー\") // エラー時\n\t}\n\tquotient := a / b\n\tremainder := a % b\n\treturn quotient, remainder, nil // 成功時 (エラーは nil)\n}\n\nfunc main() {\n\t// 戻り値を複数の変数で受け取る\n\tq1, r1, err1 := divideAndRemainder(10, 3)\n\tif err1 != nil { fmt.Println(\"エラー:\", err1) } else { fmt.Printf(\"10/3: 商%d, 余り%d\\n\", q1, r1) }\n\n\t// 一部の戻り値を _ で無視 (余りを無視)\n\tq2, _, err2 := divideAndRemainder(14, 5)\n\tif err2 != nil { fmt.Println(\"エラー:\", err2) } else { fmt.Printf(\"14/5: 商%d\\n\", q2) }\n\n\t// エラーのみチェック\n\t_, _, err3 := divideAndRemainder(5, 0)\n\tif err3 != nil { fmt.Println(\"エラー:\", err3) }\n}",
        "tags": [
          "functions",
          "func",
          "戻り値",
          "return",
          "エラー処理",
          "_"
        ]
      },
      {
        "title": "関数: 名前付き戻り値 (Named Return Values)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\n// 戻り値に名前 (quotient, remainder, err) を付ける\nfunc divideAndRemainderNamed(a, b int) (quotient, remainder int, err error) {\n\t// 関数開始時、quotient=0, remainder=0, err=nil で初期化\n\n\tif b == 0 {\n\t\terr = errors.New(\"ゼロ除算エラー\")\n\t\treturn // Naked Return: (0, 0, エラー情報) が返る\n\t}\n\n\tquotient = a / b\n\tremainder = a % b\n\t// err は nil のまま\n\treturn // Naked Return: (商, 余り, nil) が返る\n}\n\nfunc main() {\n\tq1, r1, err1 := divideAndRemainderNamed(10, 3)\n\tif err1 != nil { fmt.Println(\"エラー:\", err1) } else { fmt.Printf(\"10/3: 商%d, 余り%d\\n\", q1, r1) }\n\n\t_, _, err2 := divideAndRemainderNamed(5, 0) // 戻り値は使わないがエラーはチェック\n\tif err2 != nil { fmt.Println(\"エラー:\", err2) }\n}",
        "tags": [
          "functions",
          "func",
          "戻り値",
          "return",
          "naked return"
        ]
      },
      {
        "title": "関数: エラーを返す (`error` 型)",
        "description": "Goには例外 (`try-catch`) はなく、エラー処理は\n**`error` 型の値を返す**ことで行います。\n「エラーは値である (Errors are values)」という考え方です。\n\n**`error` 型:**\n組み込みインターフェース型です。",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\n// ファイル内容 ([]byte) と エラー (error) を返す関数\nfunc readFileContent(path string) ([]byte, error) {\n\tfile, err := os.Open(path) // エラーの可能性\n\tif err != nil {\n\t\t// 失敗: 結果のゼロ値(nil)とエラーを返す\n\t\treturn nil, fmt.Errorf(\"ファイル '%s' を開けません: %w\", path, err)\n\t}\n\tdefer file.Close() // 必ず閉じる\n\n\tdata, err := io.ReadAll(file) // エラーの可能性\n\tif err != nil {\n\t\t// 失敗: 結果のゼロ値(nil)とエラーを返す\n\t\treturn nil, fmt.Errorf(\"ファイル '%s' 読込失敗: %w\", path, err)\n\t}\n\n\t// 成功: データと nil (エラーなし) を返す\n\treturn data, nil\n}\n\nfunc main() {\n\t// テスト用ファイル作成 (エラー無視)\n\t_ = os.WriteFile(\"temp.txt\", []byte(\"テスト\"), 0644)\n\tdefer os.Remove(\"temp.txt\") // 終了時に削除\n\n\t// 成功例\n\tcontent, err := readFileContent(\"temp.txt\")\n\tif err != nil { fmt.Println(\"エラー:\", err) } else { fmt.Printf(\"成功: %s\\n\", string(content)) }\n\n\t// 失敗例\n\t_, err = readFileContent(\"not_exist.txt\")\n\tif err != nil { fmt.Println(\"エラー:\", err) }\n}",
        "tags": [
          "functions",
          "func",
          "戻り値",
          "return",
          "エラー処理",
          "error",
          "nil",
          "errors",
          "fmt.Errorf"
        ]
      },
      {
        "title": "関数: 可変長引数 (...) の定義",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\n// 任意の個数の int 引数を受け取り合計を返す\n// nums は関数内で []int スライスとして扱われる\nfunc sum(nums ...int) int {\n\tfmt.Printf(\"引数: %v (%T)\\n\", nums, nums)\n\ttotal := 0\n\tfor _, num := range nums {\n\t\ttotal += num\n\t}\n\treturn total\n}\n\nfunc main() {\n\tfmt.Println(sum(1, 2, 3))       // 引数 3つ -> 6\n\tfmt.Println(sum(10, 20))        // 引数 2つ -> 30\n\tfmt.Println(sum())              // 引数 0個 -> 0\n\tfmt.Println(sum(5, -1, 4, 10)) // 引数 4つ -> 18\n}",
        "tags": [
          "functions",
          "func",
          "引数",
          "パラメータ",
          "可変長引数",
          "...",
          "スライス"
        ]
      },
      {
        "title": "関数: 可変長引数関数の呼び出し",
        "description": "可変長引数を持つ関数 (`func f(args ...T)`) を\n呼び出す方法は主に2つあります。\n\n**1. 個別の引数を渡す**\n通常の関数のように、カンマ `,` で区切って\n値を直接渡します。0個以上の任意の個数を渡せます。",
        "code": "package main\n\nimport \"fmt\"\n\n// 可変長引数関数 (再掲)\nfunc sum(nums ...int) int {\n\tfmt.Printf(\"渡された引数 (スライスとして): %v\\n\", nums)\n\ttotal := 0\n\tfor _, num := range nums {\n\t\ttotal += num\n\t}\n\treturn total\n}\n\nfunc main() {\n\tmyNumbers := []int{5, 10, 15}\n\tmoreNumbers := []int{1, 2}\n\temptySlice := []int{}\n\n\t// スライスを展開して渡す: スライス名...\n\ttotal1 := sum(myNumbers...) // 5, 10, 15 が渡される\n\tfmt.Printf(\"合計1: %d\\n\\n\", total1)\n\n\ttotal2 := sum(moreNumbers...) // 1, 2 が渡される\n\tfmt.Printf(\"合計2: %d\\n\\n\", total2)\n\n\ttotal3 := sum(emptySlice...) // 空のスライス -> 引数0個\n\tfmt.Printf(\"合計3: %d\\n\\n\", total3)\n\n\t// sum(1, myNumbers...) // これはコンパイルエラー\n}",
        "tags": [
          "functions",
          "func",
          "引数",
          "パラメータ",
          "可変長引数",
          "...",
          "スライス"
        ]
      },
      {
        "title": "関数: 可変長引数 (スライス) の一部を渡す",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\n// joinStrings は可変長引数を受け取り連結する (例)\nfunc joinStrings(strs ...string) string {\n\treturn strings.Join(strs, \" \")\n}\n\n// title と body (可変長) を受け取る関数\nfunc processDocument(title string, body ...string) {\n\tfmt.Printf(\"\\nタイトル: %s\\n\", title)\n\tif len(body) >= 2 {\n\t\t// body スライスの最初の2要素を取得 (body[:2]) し、\n\t\t// それを ... で展開して joinStrings に渡す\n\t\tfirstTwo := joinStrings(body[:2]...)\n\t\tfmt.Printf(\"冒頭2単語: \\\"%s\\\"\\n\", firstTwo)\n\n\t\t// 同様に body[1:]... で2単語目以降を渡すことも可能\n\t} else if len(body) > 0 {\n\t\tfmt.Printf(\"本文: \\\"%s\\\"\\n\", joinStrings(body...))\n\t} else {\n\t\tfmt.Println(\"本文なし\")\n\t}\n}\n\nfunc main() {\n\tprocessDocument(\"レポート\", \"これは\", \"テスト\", \"です\")\n\tprocessDocument(\"短いメモ\", \"重要\")\n}",
        "tags": [
          "functions",
          "func",
          "引数",
          "パラメータ",
          "可変長引数",
          "...",
          "スライス",
          "スライス操作"
        ]
      },
      {
        "title": "関数: 可変長引数と固定引数の組み合わせ",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\n// 固定引数 prefix と 可変長引数 messages を組み合わせる\nfunc printWithPrefix(prefix string, messages ...string) {\n\tfmt.Printf(\"[%s] \", prefix)\n\tif len(messages) > 0 {\n\t\tfmt.Println(strings.Join(messages, \" \"))\n\t} else {\n\t\tfmt.Println(\"(メッセージなし)\")\n\t}\n}\n\nfunc main() {\n\t// 固定引数 + 個別の可変長引数\n\tprintWithPrefix(\"INFO\", \"処理開始\")\n\tprintWithPrefix(\"DEBUG\", \"値:\", \"10\")\n\tprintWithPrefix(\"ERROR\") // 可変長部分は0個\n\n\t// 固定引数 + スライス展開\n\tlogMsgs := []string{\"データ受信\", \"完了\"}\n\tprintWithPrefix(\"PROCESS\", logMsgs...)\n}",
        "tags": [
          "functions",
          "func",
          "引数",
          "パラメータ",
          "可変長引数",
          "...",
          "スライス"
        ]
      },
      {
        "title": "関数: クロージャ (Closure) の定義",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\n// `func(int) int` 型の関数を返す関数\nfunc adder() func(int) int {\n\tsum := 0 // この sum は返される関数にキャプチャされる\n\tfmt.Println(\"adder 呼び出し, sum 初期値:\", sum)\n\n\t// 関数リテラル (無名関数) を返す -> これがクロージャ\n\treturn func(x int) int {\n\t\tsum += x // キャプチャした sum を更新\n\t\tfmt.Printf(\"  内部関数: x=%d 加算, 現在 sum=%d\\n\", x, sum)\n\t\treturn sum\n\t}\n}\n\nfunc main() {\n\t// adder() が返すクロージャを pos に代入\n\t// pos は専用の sum 変数 (初期値 0) を持つ\n\tpos := adder()\n\n\tfmt.Println(pos(1))  // sum = 1\n\tfmt.Println(pos(10)) // sum = 11\n\tfmt.Println(pos(5))  // sum = 16\n\n\t// neg := adder() // 再度呼ぶと別の sum を持つクロージャが作られる\n\t// fmt.Println(neg(-1)) // neg の sum = -1\n\t// fmt.Println(pos(100)) // pos の sum = 116 (neg とは独立)\n}",
        "tags": [
          "functions",
          "func",
          "クロージャ",
          "関数リテラル",
          "スコープ",
          "状態"
        ]
      },
      {
        "title": "関数: クロージャの使い方 (状態の保持)",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\n// adder 関数は `func(int) int` 型のクロージャを返す (再掲)\nfunc adder() func(int) int {\n\tsum := 0 // この sum が状態としてキャプチャされる\n\treturn func(x int) int {\n\t\tsum += x\n\t\treturn sum\n\t}\n}\n\nfunc main() {\n\t// pos は adder() が返したクロージャ (内部に sum=0 を保持)\n\tpos := adder()\n\n\t// pos を呼び出すたびに、pos が持つ sum が更新される\n\tfmt.Println(pos(1)) // -> 1\n\tfmt.Println(pos(8)) // -> 9 (1+8)\n\tfmt.Println(pos(3)) // -> 12 (9+3)\n\n\t// neg := adder() // 再度呼ぶと別の sum を持つクロージャが作られる\n\t// fmt.Println(neg(-2)) // neg の sum は -2\n\t// fmt.Println(pos(100)) // pos の sum は 12+100 = 112\n}",
        "tags": [
          "functions",
          "func",
          "クロージャ",
          "関数リテラル",
          "スコープ",
          "状態"
        ]
      },
      {
        "title": "関数: クロージャごとに独立した状態",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\n// adder 関数 (再掲)\nfunc adder() func(int) int {\n\tsum := 0\n\treturn func(x int) int {\n\t\tsum += x\n\t\treturn sum\n\t}\n}\n\nfunc main() {\n\t// 1つ目のクロージャ (内部に sum=0 を持つ)\n\tpos1 := adder()\n\t// 2つ目のクロージャ (別の独立した sum=0 を持つ)\n\tpos2 := adder()\n\n\tfmt.Println(pos1(10)) // pos1 の sum は 10\n\tfmt.Println(pos2(20)) // pos2 の sum は 20 (pos1 に影響なし)\n\tfmt.Println(pos1(40)) // pos1 の sum は 50 (10+40)\n\tfmt.Println(pos2(5))  // pos2 の sum は 25 (20+5)\n}",
        "tags": [
          "functions",
          "func",
          "クロージャ",
          "関数リテラル",
          "スコープ",
          "状態"
        ]
      },
      {
        "title": "関数: ループ内でのクロージャの落とし穴",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar funcs []func()\n\n\tfmt.Println(\"ループ内でクロージャ作成...\")\n\tfor i := 0; i < 3; i++ {\n\t\t// このクロージャは変数 i への参照をキャプチャする\n\t\tfuncs = append(funcs, func() {\n\t\t\t// 実行されるのはループ終了後なので、i は 3 になっている\n\t\t\tfmt.Printf(\"i の値: %d\\n\", i)\n\t\t})\n\t\tfmt.Printf(\"  ループ %d 回目 (現在の i = %d)\\n\", i, i)\n\t}\n\n\tfmt.Println(\"\\nクロージャ実行...\")\n\tfor j := 0; j < len(funcs); j++ {\n\t\tfmt.Printf(\"funcs[%d]() -> \", j)\n\t\tfuncs[j]() // すべて i=3 と出力される\n\t}\n}",
        "tags": [
          "functions",
          "func",
          "クロージャ",
          "関数リテラル",
          "スコープ",
          "ループ",
          "for",
          "落とし穴"
        ]
      },
      {
        "title": "関数: ループ内クロージャの落とし穴の解決策",
        "description": "`for` ループ内でクロージャがループ変数の参照を共有してしまう\n問題を解決し、各反復時点での値を正しくキャプチャする\n一般的な方法が2つあります。\n\n**解決策1: ループ内で新しい変数を作成 (コード例)**\nループの各反復の**内部**で、ループ変数と同じ名前の\n**新しい変数**を宣言し (`i := i`)、ループ変数の\n現在の値をコピーします。\nクロージャ内ではこの**新しい変数**を参照します。\n\n*   `i := i`: これは**シャドーイング**と呼ばれ、\n    ループの反復ごとに新しい変数 `i` が作られます。\n*   クロージャ `func() { fmt.Println(i) }` は、\n    この**内側の `i`** への参照をキャプチャします。\n*   各クロージャは、作成された時点のループ変数の値を\n    持つ独立した変数を参照するため、期待通りの結果になります。\n\nこの `i := i` は Go 1.22 より前のバージョンで一般的な\n解決策でした。(Go 1.22 からはループ変数の扱いが変わり、\nこの問題は発生しにくくなりましたが、パターンとして有効な場面もあります。)\n\n**解決策2: ループ変数を引数として渡す**\nもう一つの方法は、ループ変数の値をクロージャ生成時に\n**引数**として渡すことです。",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar funcs []func()\n\n\tfmt.Println(\"ループ内でクロージャ作成 (解決策1)...\")\n\tfor i := 0; i < 3; i++ {\n\t\t// ループごとに新しい変数 i を宣言し、値をコピー\n\t\ti := i // この内側の i をクロージャがキャプチャする\n\n\t\tfuncs = append(funcs, func() {\n\t\t\tfmt.Printf(\"i の値: %d\\n\", i) // 内側の i を参照\n\t\t})\n\t\tfmt.Printf(\"  ループ %d 回目 (内側の i = %d)\\n\", i, i)\n\t}\n\n\tfmt.Println(\"\\nクロージャ実行...\")\n\tfor j := 0; j < len(funcs); j++ {\n\t\tfmt.Printf(\"funcs[%d]() -> \", j)\n\t\tfuncs[j]() // 期待通り 0, 1, 2 が出力される\n\t}\n}",
        "tags": [
          "functions",
          "func",
          "クロージャ",
          "関数リテラル",
          "スコープ",
          "ループ",
          "for"
        ]
      },
      {
        "title": "関数: 関数型 (Function Type) の宣言",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\n// 関数型の宣言: int引数2つ、戻り値int の関数型に Operator という名前を付ける\ntype Operator func(int, int) int\n\n// Operator 型の関数を引数として受け取る関数\nfunc calculate(a, b int, op Operator) int {\n\tfmt.Printf(\"実行: %T\\n\", op)\n\treturn op(a, b)\n}\n\n// Operator 型のシグネチャに合致する具体的な関数\nfunc add(a, b int) int {\n\treturn a + b\n}\n\nfunc main() {\n\t// 関数型の変数に関数を代入\n\tvar opAdd Operator = add\n\n\t// 関数型を引数として渡す\n\tresult1 := calculate(10, 5, opAdd) // 変数を渡す\n\tresult2 := calculate(10, 5, add)   // 関数を直接渡す\n\n\tfmt.Printf(\"10 + 5 = %d\\n\", result1)\n\tfmt.Printf(\"10 + 5 = %d\\n\", result2)\n}",
        "tags": [
          "functions",
          "func",
          "型",
          "関数型",
          "type"
        ]
      },
      {
        "title": "関数: 関数を変数に代入する",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc add(a, b int) int {\n\treturn a + b\n}\n\n// 関数型を定義 (オプション)\ntype BinaryIntOperator func(int, int) int\n\nfunc main() {\n\t// 関数型の変数を宣言し、関数名を代入\n\tvar operation BinaryIntOperator\n\toperation = add // シグネチャが一致すれば代入可能\n\n\t// 変数 operation を使って add 関数を呼び出す\n\tresult1 := operation(10, 5)\n\tfmt.Printf(\"operation(10, 5) = %d\\n\", result1) // 15\n\n\t// 関数リテラル (無名関数) を変数に代入\n\tgreet := func(name string) string {\n\t\treturn \"Hello, \" + name + \"!\"\n\t}\n\tmessage := greet(\"Gopher\")\n\tfmt.Println(message) // Hello, Gopher!\n}",
        "tags": [
          "functions",
          "func",
          "関数型",
          "変数",
          "第一級オブジェクト",
          "関数リテラル"
        ]
      },
      {
        "title": "関数: 関数を引数として渡す (高階関数)",
        "description": "Goでは関数が第一級オブジェクトのため、関数を\n**他の関数の引数として渡す**ことができます。\n関数を引数に取ったり戻り値で返す関数を\n**高階関数 (Higher-Order Function)** と呼びます。\n\n**関数を引数に取る関数の定義:**\n引数リストで**関数型**を指定します。\n`type` で定義した関数型名を使うと読みやすくなります。",
        "code": "package main\n\nimport \"fmt\"\n\n// 関数型の定義\ntype IntTransformer func(int) int\n\n// 高階関数の定義: スライスと IntTransformer 型の関数を受け取る\nfunc mapInts(slice []int, transformer IntTransformer) []int {\n\tresult := make([]int, len(slice))\n\tfor i, value := range slice {\n\t\tresult[i] = transformer(value) // 引数で渡された関数を実行\n\t}\n\treturn result\n}\n\n// 適用する具体的な関数\nfunc double(n int) int {\n\treturn n * 2\n}\n\nfunc main() {\n\tnumbers := []int{1, 2, 3, 4}\n\n\t// 1. 通常の関数名を渡す\n\tdoubled := mapInts(numbers, double)\n\tfmt.Println(\"2倍:\", doubled) // [2 4 6 8]\n\n\t// 2. 関数リテラル (無名関数) を直接渡す\n\tnegated := mapInts(numbers, func(n int) int {\n\t\treturn -n\n\t})\n\tfmt.Println(\"符号反転:\", negated) // [-1 -2 -3 -4]\n}",
        "tags": [
          "functions",
          "func",
          "関数型",
          "引数",
          "高階関数",
          "コールバック"
        ]
      },
      {
        "title": "関数: 関数を戻り値として返す (高階関数, クロージャ生成)",
        "description": "Goでは関数を**他の関数の戻り値として返す**ことも可能です。\nこれも**高階関数**の一種であり、**クロージャ**を生成する\n一般的な方法です。\n\n**定義方法:**\n関数宣言の戻り値の型指定部分に、返したい関数の\n**関数型**を指定します。",
        "code": "package main\n\nimport \"fmt\"\n\n// int を受け取り int を返す関数型\ntype IntUnaryOperator func(int) int\n\n// IntUnaryOperator 型の関数を返す高階関数\nfunc multiplier(factor int) IntUnaryOperator {\n\tfmt.Printf(\"multiplier(%d) 呼び出し\\n\", factor)\n\t// factor をキャプチャしたクロージャを返す\n\treturn func(n int) int {\n\t\treturn n * factor\n\t}\n}\n\nfunc main() {\n\t// 2倍する関数 (クロージャ) を取得\n\tdouble := multiplier(2)\n\n\t// 生成されたクロージャを使う\n\tfmt.Println(double(5))  // 10\n\tfmt.Println(double(10)) // 20\n\n\t// 3倍する関数も同様に生成可能\n\t// triple := multiplier(3)\n\t// fmt.Println(triple(5)) // 15\n\n\t// 直接呼び出しも可能\n\t// fmt.Println(multiplier(10)(5)) // 50\n}",
        "tags": [
          "functions",
          "func",
          "関数型",
          "戻り値",
          "高階関数",
          "クロージャ"
        ]
      },
      {
        "title": "関数 vs メソッド: 基本的な違い",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Point struct {\n\tX, Y float64\n}\n\n// Point 型に関連付けられた Distance メソッド\n// (p Point) がレシーバ\nfunc (p Point) Distance(q Point) float64 {\n\tdx := q.X - p.X // p.X はレシーバ p の X 座標\n\tdy := q.Y - p.Y // p.Y はレシーバ p の Y 座標\n\treturn math.Sqrt(dx*dx + dy*dy)\n}\n\nfunc main() {\n\tp1 := Point{1, 2}\n\tp2 := Point{4, 6}\n\n\t// メソッド呼び出し: p1 に対して Distance メソッドを呼び出す\n\tdist := p1.Distance(p2)\n\tfmt.Printf(\"p1.Distance(p2) = %f\\n\", dist) // 5.000000\n}",
        "tags": [
          "functions",
          "func",
          "メソッド",
          "method",
          "レシーバ",
          "型"
        ]
      }
    ]
  },
  {
    "title": "Data Structures",
    "codeExamples": [
      {
        "title": "データ構造: 配列 (Array) の宣言",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\t// サイズ 5 の int 配列 (ゼロ値 0 で初期化)\n\tvar numbers [5]int\n\n\t// サイズ 3 の string 配列 (ゼロ値 \"\" で初期化)\n\tvar names [3]string\n\n\t// サイズ 2 の bool 配列 (ゼロ値 false で初期化)\n\tvar flags [2]bool\n\n\tfmt.Printf(\"numbers: %v (%T, len=%d)\\n\", numbers, numbers, len(numbers))\n\tfmt.Printf(\"names:   %q (%T, len=%d)\\n\", names, names, len(names))\n\tfmt.Printf(\"flags:   %v (%T, len=%d)\\n\", flags, flags, len(flags))\n\n\t// var a [5]int\n\t// var b [10]int\n\t// a = b // コンパイルエラー: 型が違う ([5]int と [10]int)\n}",
        "tags": [
          "data-structures",
          "配列",
          "array",
          "固定長",
          "ゼロ値"
        ]
      },
      {
        "title": "データ構造: 配列 (Array) の初期化",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\t// サイズ 3 の int 配列を初期化\n\tnumbers := [3]int{10, 20, 30}\n\tfmt.Printf(\"numbers: %v (%T)\\n\", numbers, numbers)\n\n\t// サイズ 4 の string 配列を初期化\n\tfruits := [4]string{\"Apple\", \"Banana\", \"Cherry\", \"Date\"}\n\tfmt.Printf(\"fruits: %q (%T)\\n\", fruits, fruits)\n\n\t// 要素数がサイズと一致しないとコンパイルエラー\n\t// error1 := [3]int{1, 2} // エラー\n\t// error2 := [3]int{1, 2, 3, 4} // エラー\n}",
        "tags": [
          "data-structures",
          "配列",
          "array",
          "初期化",
          "リテラル"
        ]
      },
      {
        "title": "データ構造: 配列 (Array) のサイズ推論 `...`",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\t// [...] で初期値の数からサイズを推論 (サイズ 4)\n\tnumbers := [...]int{10, 20, 30, 40}\n\tfmt.Printf(\"numbers: %v (%T, len=%d)\\n\", numbers, numbers, len(numbers))\n\n\t// サイズ 3 の配列になる\n\tweekdays := [...]string{\"Mon\", \"Tue\", \"Wed\"}\n\tfmt.Printf(\"weekdays: %q (%T, len=%d)\\n\", weekdays, weekdays, len(weekdays))\n\n\t// サイズ 1 の配列\n\tsingle := [...]bool{true}\n\tfmt.Printf(\"single: %v (%T, len=%d)\\n\", single, single, len(single))\n\n\t// サイズ 0 の配列\n\tempty := [...]float64{}\n\tfmt.Printf(\"empty: %v (%T, len=%d)\\n\", empty, empty, len(empty))\n}",
        "tags": [
          "data-structures",
          "配列",
          "array",
          "初期化",
          "リテラル",
          "サイズ推論",
          "..."
        ]
      },
      {
        "title": "データ構造: 配列 (Array) の要素へのアクセス",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar numbers [5]int // ゼロ値 [0 0 0 0 0]\n\tfmt.Printf(\"初期状態: %v\\n\", numbers)\n\n\t// 要素への書き込み (代入)\n\tnumbers[0] = 10\n\tnumbers[1] = 20\n\tnumbers[4] = 50\n\tfmt.Printf(\"代入後:   %v\\n\", numbers)\n\n\t// 要素の読み取り\n\tfirst := numbers[0]\n\tlast := numbers[4]\n\tfmt.Printf(\"最初:%d, 最後:%d, インデックス2:%d\\n\", first, last, numbers[2])\n\n\t// ループを使ったアクセス\n\tfmt.Println(\"--- ループ ---\")\n\tfor i := 0; i < len(numbers); i++ {\n\t\tfmt.Printf(\" %d: %d\\n\", i, numbers[i])\n\t\t// numbers[i] = numbers[i] * 2 // 値の変更も可能\n\t}\n\n\t// 範囲外アクセスは panic を引き起こす\n\t// fmt.Println(numbers[5]) // panic: runtime error: index out of range\n}",
        "tags": [
          "data-structures",
          "配列",
          "array",
          "インデックス",
          "アクセス",
          "代入",
          "範囲外アクセス",
          "panic"
        ]
      },
      {
        "title": "データ構造: 多次元配列 (Multi-dimensional Array)",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\t// 2行3列の配列をリテラルで初期化\n\tmatrix := [2][3]int{\n\t\t{10, 20, 30}, // 行 0\n\t\t{40, 50, 60}, // 行 1\n\t}\n\n\t// 要素の読み取り (行インデックス, 列インデックス)\n\tval1 := matrix[0][1] // 1行目(0), 2列目(1) -> 20\n\tval2 := matrix[1][2] // 2行目(1), 3列目(2) -> 60\n\tfmt.Printf(\"matrix[0][1]=%d, matrix[1][2]=%d\\n\", val1, val2)\n\n\t// 要素への書き込み (代入)\n\tmatrix[0][0] = 11\n\tfmt.Println(\"変更後:\", matrix) // [[11 20 30] [40 50 60]]\n\n\t// ネストしたループで全要素アクセス\n\tfmt.Println(\"--- 全要素 ---\")\n\tfor i := 0; i < len(matrix); i++ { // 行ループ (len=2)\n\t\tfor j := 0; j < len(matrix[i]); j++ { // 列ループ (len=3)\n\t\t\tfmt.Printf(\" matrix[%d][%d]=%d\\n\", i, j, matrix[i][j])\n\t\t}\n\t}\n\t// 範囲外アクセスは panic (例: matrix[2][0])\n}",
        "tags": [
          "data-structures",
          "配列",
          "array",
          "多次元配列",
          "2次元配列",
          "行列"
        ]
      },
      {
        "title": "データ構造: 配列は値型 (コピーされる)",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\n// 配列を受け取る関数 (値渡し)\nfunc modifyArray(arr [3]int) {\n\tfmt.Printf(\"  modifyArray 内 (変更前): %v\\n\", arr)\n\tarr[0] = 999 // 関数内のコピーを変更\n\tfmt.Printf(\"  modifyArray 内 (変更後): %v\\n\", arr)\n}\n\nfunc main() {\n\t// 配列の代入 (コピーが発生)\n\toriginal := [3]int{1, 2, 3}\n\tcopied := original // 全要素がコピーされる\n\tcopied[0] = 100    // コピー先を変更\n\n\tfmt.Printf(\"original: %v\\n\", original) // 元は不変 [1 2 3]\n\tfmt.Printf(\"copied:   %v\\n\", copied)   // コピーが変更 [100 2 3]\n\n\t// 関数への配列の引き渡し (コピーが発生)\n\tarrForFunc := [3]int{10, 20, 30}\n\tfmt.Printf(\"\\n関数呼び出し前: %v\\n\", arrForFunc)\n\tmodifyArray(arrForFunc) // 値のコピーが渡される\n\tfmt.Printf(\"関数呼び出し後: %v\\n\", arrForFunc) // 元は不変 [10 20 30]\n}",
        "tags": [
          "data-structures",
          "配列",
          "array",
          "値型",
          "コピー",
          "関数引数"
        ]
      },
      {
        "title": "データ構造: スライス (Slice) の宣言",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\t// スライスの宣言 (初期値なし)\n\tvar numbers []int\n\tvar names []string\n\n\t// ゼロ値は nil\n\tfmt.Printf(\"numbers: %v (%T)\\n\", numbers, numbers)\n\tfmt.Printf(\"names:   %q (%T)\\n\", names, names)\n\n\tif numbers == nil {\n\t\tfmt.Println(\"numbers は nil スライスです。\")\n\t}\n\n\t// nil スライスの長さと容量は 0\n\tfmt.Printf(\"len=%d, cap=%d\\n\", len(numbers), cap(numbers))\n\n\t// nil スライスへの append は可能\n\tnumbers = append(numbers, 10)\n\tfmt.Printf(\"append 後: %v (len=%d, cap=%d)\\n\", numbers, len(numbers), cap(numbers))\n}",
        "tags": [
          "data-structures",
          "スライス",
          "slice",
          "可変長",
          "参照型",
          "nil"
        ]
      },
      {
        "title": "データ構造: `make` 関数によるスライス (Slice) の作成",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\t// 長さのみ指定: make([]要素型, 長さ)\n\t// 長さ 5、容量 5 の int スライス (要素は 0)\n\ts1 := make([]int, 5)\n\tfmt.Printf(\"s1: %v (len=%d, cap=%d)\\n\", s1, len(s1), cap(s1))\n\ts1[0] = 10 // アクセス・代入可能\n\tfmt.Printf(\"s1変更後: %v\\n\", s1)\n\n\t// 長さと容量を指定: make([]要素型, 長さ, 容量)\n\t// 長さ 3、容量 10 の string スライス (要素は \"\")\n\ts2 := make([]string, 3, 10)\n\tfmt.Printf(\"s2: %q (len=%d, cap=%d)\\n\", s2, len(s2), cap(s2))\n\ts2[0] = \"A\"\n\t// s2[3] = \"B\" // エラー: 長さ(3)を超えるインデックスはアクセス不可\n\n\t// 長さ 0、容量 5 のスライス\n\ts3 := make([]int, 0, 5)\n\tfmt.Printf(\"s3: %v (len=%d, cap=%d)\\n\", s3, len(s3), cap(s3))\n}",
        "tags": [
          "data-structures",
          "スライス",
          "slice",
          "make",
          "長さ",
          "容量",
          "ゼロ値"
        ]
      },
      {
        "title": "データ構造: スライスリテラルによる作成と初期化",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\t// int スライスリテラル\n\tnumbers := []int{10, 20, 30, 40, 50}\n\tfmt.Printf(\"numbers: %v (len=%d, cap=%d)\\n\", numbers, len(numbers), cap(numbers))\n\n\t// string スライスリテラル\n\tnames := []string{\"Alice\", \"Bob\", \"Charlie\"}\n\tfmt.Printf(\"names: %q (len=%d, cap=%d)\\n\", names, len(names), cap(names))\n\n\t// bool スライスリテラル\n\tflags := []bool{true, false, true}\n\tfmt.Printf(\"flags: %v (len=%d, cap=%d)\\n\", flags, len(flags), cap(flags))\n\n\t// 空のスライスリテラル (nil ではない)\n\temptySlice := []float64{}\n\tfmt.Printf(\"emptySlice: %v (len=%d, cap=%d)\\n\", emptySlice, len(emptySlice), cap(emptySlice))\n\tif emptySlice != nil {\n\t\tfmt.Println(\"emptySlice は nil ではありません\")\n\t}\n}",
        "tags": [
          "data-structures",
          "スライス",
          "slice",
          "初期化",
          "リテラル"
        ]
      },
      {
        "title": "データ構造: スライス操作 (Slicing) - 配列やスライスから作る",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tprimes := [6]int{2, 3, 5, 7, 11, 13}\n\tfmt.Printf(\"元の配列: %v\\n\", primes)\n\n\t// 配列からスライスを作成: primes[1:4]\n\t// インデックス 1 から 4-1=3 まで (要素 3, 5, 7)\n\ts1 := primes[1:4]\n\tfmt.Printf(\"s1 = primes[1:4]: %v (len=%d, cap=%d)\\n\", s1, len(s1), cap(s1))\n\n\t// s1 からさらにスライスを作成: s1[:2]\n\t// s1 のインデックス 0 から 2-1=1 まで (要素 3, 5)\n\ts4 := s1[:2]\n\tfmt.Printf(\"s4 = s1[:2]: %v (len=%d, cap=%d)\\n\", s4, len(s4), cap(s4))\n\n\t// 内部配列の共有と変更の影響\n\tfmt.Printf(\"変更前: s4=%v, primes=%v\\n\", s4, primes)\n\ts4[1] = 99 // s4[1] は primes[2] と同じ場所を指す\n\tfmt.Printf(\"変更後: s4=%v, primes=%v\\n\", s4, primes) // primes も変更される!\n}",
        "tags": [
          "data-structures",
          "スライス",
          "slice",
          "配列",
          "array",
          "スライス操作",
          "参照",
          "共有"
        ]
      },
      {
        "title": "データ構造: スライス (Slice) の要素へのアクセス",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tfruits := []string{\"Apple\", \"Banana\", \"Cherry\"}\n\tfmt.Printf(\"初期状態: %q (len=%d)\\n\", fruits, len(fruits))\n\n\t// 要素の読み取り\n\tfirst := fruits[0]\n\tsecond := fruits[1]\n\tfmt.Printf(\"最初:%s, 2番目:%s, Index2:%s\\n\", first, second, fruits[2])\n\n\t// 要素への書き込み (代入)\n\tfruits[1] = \"Blueberry\" // スライスは変更可能\n\tfmt.Printf(\"変更後: %q\\n\", fruits)\n\n\t// ループを使ったアクセス (for i)\n\tfmt.Println(\"--- for i ---\")\n\tfor i := 0; i < len(fruits); i++ {\n\t\tfmt.Printf(\" %d: %s\\n\", i, fruits[i])\n\t}\n\n\t// ループを使ったアクセス (for range)\n\tfmt.Println(\"--- for range ---\")\n\tfor index, value := range fruits {\n\t\tfmt.Printf(\" %d: %s\\n\", index, value)\n\t}\n\n\t// 範囲外アクセスは panic\n\t// fmt.Println(fruits[3]) // panic: runtime error: index out of range\n}",
        "tags": [
          "data-structures",
          "スライス",
          "slice",
          "インデックス",
          "アクセス",
          "代入",
          "範囲外アクセス",
          "panic"
        ]
      },
      {
        "title": "データ構造: スライス (Slice) への要素の追加 `append`",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar s []int // nil スライス\n\tfmt.Printf(\"初期: %v (len=%d, cap=%d)\\n\", s, len(s), cap(s))\n\n\t// 要素を1つ追加\n\ts = append(s, 0)\n\tfmt.Printf(\"append 0: %v (len=%d, cap=%d)\\n\", s, len(s), cap(s))\n\n\t// さらに要素を1つ追加\n\ts = append(s, 1)\n\tfmt.Printf(\"append 1: %v (len=%d, cap=%d)\\n\", s, len(s), cap(s))\n\n\t// 複数の要素を一度に追加\n\ts = append(s, 2, 3, 4)\n\tfmt.Printf(\"append 2,3,4: %v (len=%d, cap=%d)\\n\", s, len(s), cap(s))\n\n\t// 別のスライスの全要素を追加 (sB...)\n\tsA := []int{100, 200}\n\tsB := []int{300, 400}\n\tsA = append(sA, sB...)\n\tfmt.Printf(\"sA + sB...: %v (len=%d, cap=%d)\\n\", sA, len(sA), cap(sA))\n}",
        "tags": [
          "data-structures",
          "スライス",
          "slice",
          "append",
          "可変長",
          "容量",
          "内部配列"
        ]
      },
      {
        "title": "データ構造: スライス (Slice) の長さ (Length) と容量 (Capacity)",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\ts0 := []int{0, 1, 2, 3, 4} // len=5, cap=5\n\tfmt.Printf(\"s0: %v (len=%d, cap=%d)\\n\", s0, len(s0), cap(s0))\n\n\t// スライス操作 s0[1:3]\n\ts1 := s0[1:3] // 要素 {1, 2} を参照\n\t// len = 3 - 1 = 2\n\t// cap = 5 - 1 = 4 (元の配列の index 1 から最後まで)\n\tfmt.Printf(\"s1 = s0[1:3]: %v (len=%d, cap=%d)\\n\", s1, len(s1), cap(s1))\n\n\t// s1 からさらにスライス s3 = s1[:1]\n\ts3 := s1[:1] // 要素 {1} を参照\n\t// len = 1 - 0 = 1\n\t// cap = 4 (s1 と同じ内部配列、同じ開始位置)\n\tfmt.Printf(\"s3 = s1[:1]: %v (len=%d, cap=%d)\\n\", s3, len(s3), cap(s3))\n\n\t// append による変化 (容量内)\n\ts3 = append(s3, 99) // s3 は [1, 99] になる (len=2, cap=4)\n\tfmt.Printf(\"s3 append後: %v (len=%d, cap=%d)\\n\", s3, len(s3), cap(s3))\n\n\t// 内部配列共有の影響: s0 も変更される！\n\tfmt.Printf(\"s0 影響確認: %v\\n\", s0) // [0 1 99 3 4]\n}",
        "tags": [
          "data-structures",
          "スライス",
          "slice",
          "長さ",
          "len",
          "容量",
          "cap",
          "内部配列",
          "append"
        ]
      },
      {
        "title": "データ構造: スライス (Slice) のコピー `copy`",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tsrc := []int{1, 2, 3, 4, 5}\n\tfmt.Printf(\"src: %v (len=%d)\\n\", src, len(src))\n\n\t// コピー先を適切なサイズで確保\n\tdst1 := make([]int, len(src))\n\n\t// src から dst1 へコピー\n\tnumCopied := copy(dst1, src)\n\tfmt.Printf(\"dst1: %v (len=%d)\\n\", dst1, len(dst1))\n\tfmt.Printf(\"コピー要素数: %d\\n\", numCopied)\n\n\t// dst1 を変更しても src には影響しない (独立したコピー)\n\tdst1[0] = 99\n\tfmt.Printf(\"dst1変更後: %v\\n\", dst1)\n\tfmt.Printf(\"src影響なし: %v\\n\", src)\n\n\t// append を使ったコピー (簡潔な方法)\n\tdst2 := append([]int(nil), src...)\n\tfmt.Printf(\"dst2 (append): %v (len=%d)\\n\", dst2, len(dst2))\n}",
        "tags": [
          "data-structures",
          "スライス",
          "slice",
          "コピー",
          "copy",
          "参照",
          "内部配列"
        ]
      },
      {
        "title": "データ構造: スライス (Slice) からの要素の削除",
        "description": "スライスから特定の要素を**削除**するための\n専用の組み込み関数はありませんが、`append` 関数と\nスライス操作を組み合わせて実現できます。\n\n**特定インデックス `i` の要素削除イディオム:**\n`s = append(s[:i], s[i+1:]...)`\n\n1. `s[:i]`: 削除要素の**直前**までのスライス。\n2. `s[i+1:]`: 削除要素の**次**から最後までのスライス。\n3. `append` で 1. に 2. の要素を**展開 (`...`)** して追加する。\n   これにより、`i` 番目の要素が除かれた状態になる。\n\n**注意:**\n*   この操作は元の内部配列の内容を変更する可能性があります。\n*   `append` の結果を元のスライス変数 `s` に再代入します。\n\n**簡単なケース:**\n*   **先頭要素の削除:** `s = s[1:]`\n*   **末尾要素の削除:** `s = s[:len(s)-1]`\n\n**メモリリークの可能性:**\n`append` を使った削除では、削除された要素が内部配列に残り、\nガベージコレクションされない可能性があります。\n特にポインタや大きな構造体のスライスの場合、\nメモリリークに繋がることがあります。\n対策として、`copy` で要素をずらしてから末尾要素に `nil` を代入し、\n最後にスライスの長さを縮める方法があります。",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tfruits := []string{\"Apple\", \"Banana\", \"Cherry\", \"Date\", \"Elderberry\"}\n\tfmt.Printf(\"元: %q (len=%d)\\n\", fruits, len(fruits))\n\n\t// インデックス 2 (\"Cherry\") を削除\n\ti := 2\n\tfruits = append(fruits[:i], fruits[i+1:]...)\n\tfmt.Printf(\"削除後(idx %d): %q (len=%d)\\n\", i, fruits, len(fruits))\n\n\t// 先頭要素 (\"Apple\" 相当) を削除\n\tif len(fruits) > 0 {\n\t\tfruits = fruits[1:] // 簡単な方法\n\t\t// または fruits = append(fruits[:0], fruits[1:]...)\n\t}\n\tfmt.Printf(\"先頭削除後: %q (len=%d)\\n\", fruits, len(fruits))\n\n\t// 末尾要素 (\"Elderberry\" 相当) を削除\n\tif len(fruits) > 0 {\n\t\tfruits = fruits[:len(fruits)-1] // 簡単な方法\n\t}\n\tfmt.Printf(\"末尾削除後: %q (len=%d)\\n\", fruits, len(fruits))\n}",
        "tags": [
          "data-structures",
          "スライス",
          "slice",
          "削除",
          "append",
          "スライス操作"
        ]
      },
      {
        "title": "データ構造: スライス (Slice) への要素の挿入",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\ts := []int{10, 20, 40, 50}\n\tfmt.Printf(\"元: %v (len=%d)\\n\", s, len(s))\n\n\ti := 2 // 挿入位置インデックス\n\tx := 30 // 挿入する要素\n\n\t// 方法1: append を2回使うイディオム\n\t// s[:i] に、 {x} と s[i:] を連結したものを append する\n\ts = append(s[:i], append([]int{x}, s[i:]...)...)\n\n\tfmt.Printf(\"挿入後: %v (len=%d)\\n\", s, len(s))\n}",
        "tags": [
          "data-structures",
          "スライス",
          "slice",
          "挿入",
          "append",
          "copy",
          "スライス操作"
        ]
      },
      {
        "title": "データ構造: マップ (Map) の宣言",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\t// マップの宣言 (初期値なし)\n\tvar scores map[string]int\n\tvar isPrime map[int]bool\n\n\t// ゼロ値は nil\n\tfmt.Printf(\"scores: %v (%T)\\n\", scores, scores)\n\tfmt.Printf(\"isPrime: %v (%T)\\n\", isPrime, isPrime)\n\n\tif scores == nil {\n\t\tfmt.Println(\"scores は nil マップです。\")\n\t}\n\n\t// nil マップの len は 0\n\tfmt.Printf(\"len(scores): %d\\n\", len(scores))\n\n\t// nil マップからの読み取りはゼロ値が返る (panic しない)\n\tfmt.Printf(\"scores[\\\"Alice\\\"]: %d\\n\", scores[\"Alice\"])\n\n\t// nil マップへの書き込みは panic する！\n\t// scores[\"Bob\"] = 90 // panic: assignment to entry in nil map\n}",
        "tags": [
          "data-structures",
          "マップ",
          "map",
          "キーバリュー",
          "辞書",
          "連想配列",
          "nil"
        ]
      },
      {
        "title": "データ構造: `make` 関数によるマップ (Map) の作成",
        "description": "`var m map[K]V` で宣言したマップは `nil` であり、\n要素を追加しようとすると `panic` します。\nマップを使うには**初期化**が必要です。\nその主な方法が組み込み関数 **`make`** です。\n(`make` はスライス、マップ、チャネルの初期化に使う)\n\n**`make` によるマップ作成:**\n`make` で作成されたマップは `nil` ではなく、\n要素を追加できる状態になります (長さは 0)。\n\n**構文:**",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\t// make で空のマップを作成\n\tscores := make(map[string]int)\n\tfmt.Printf(\"scores (make): %v (len=%d)\\n\", scores, len(scores))\n\n\t// make で作成したマップは nil ではない\n\tif scores != nil {\n\t\tfmt.Println(\"scores は nil ではありません\")\n\t}\n\n\t// 要素を追加できる\n\tscores[\"Alice\"] = 95\n\tscores[\"Bob\"] = 88\n\tfmt.Printf(\"追加後 scores: %v (len=%d)\\n\", scores, len(scores))\n\n\t// 初期容量を指定して作成 (パフォーマンス最適化のヒント)\n\tages := make(map[string]int, 10)\n\tfmt.Printf(\"\\nages (cap hint): %v (len=%d)\\n\", ages, len(ages))\n\tages[\"Charlie\"] = 30\n\tfmt.Printf(\"追加後 ages: %v (len=%d)\\n\", ages, len(ages))\n}",
        "tags": [
          "data-structures",
          "マップ",
          "map",
          "make",
          "初期化",
          "容量"
        ]
      },
      {
        "title": "データ構造: マップリテラルによる作成と初期化",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\t// マップリテラルで初期化\n\tages := map[string]int{\n\t\t\"Alice\":   30,\n\t\t\"Bob\":     25,\n\t\t\"Charlie\": 35, // 最後のカンマ推奨\n\t}\n\tfmt.Printf(\"ages: %v (len=%d)\\n\", ages, len(ages))\n\n\t// 空のマップリテラル (nil ではない)\n\temptyMap := map[string]bool{}\n\tfmt.Printf(\"emptyMap: %v (len=%d)\\n\", emptyMap, len(emptyMap))\n\tif emptyMap != nil {\n\t\tfmt.Println(\"emptyMap は nil ではありません\")\n\t}\n\temptyMap[\"active\"] = true // 要素を追加できる\n\tfmt.Printf(\"追加後 emptyMap: %v\\n\", emptyMap)\n\n\t// var nilMap map[string]int // これは nil\n\t// nilMap[\"key\"] = 1 // panic\n}",
        "tags": [
          "data-structures",
          "マップ",
          "map",
          "初期化",
          "リテラル"
        ]
      },
      {
        "title": "データ構造: マップ (Map) の基本操作",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tscores := make(map[string]int)\n\n\t// 1. 要素の追加/更新: map[key] = value\n\tscores[\"Alice\"] = 95 // 追加\n\tscores[\"Bob\"] = 88   // 追加\n\tscores[\"Alice\"] = 98 // 更新\n\tfmt.Println(\"追加/更新後:\", scores)\n\n\t// 2. 要素の取得: value := map[key]\n\taliceScore := scores[\"Alice\"]\n\tfmt.Printf(\"Aliceの点数: %d\\n\", aliceScore)\n\t// charlieScore := scores[\"Charlie\"] // 存在しないキー -> 0 (intのゼロ値)\n\n\t// 3. キーの存在確認 (カンマOKイディオム)\n\tvalue, ok := scores[\"Bob\"] // ok に存在有無 (bool) が入る\n\tif ok {\n\t\tfmt.Printf(\"Bobは存在: %d\\n\", value)\n\t}\n\tvalue, ok = scores[\"David\"]\n\tif !ok {\n\t\tfmt.Printf(\"Davidは不在 (ok=%t, value=%d)\\n\", ok, value)\n\t}\n\n\t// 4. 要素の削除: delete(map, key)\n\tdelete(scores, \"Bob\")\n\tfmt.Println(\"Bob削除後:\", scores)\n\tdelete(scores, \"David\") // 存在しなくてもエラーにならない\n\tfmt.Println(\"David削除試行後:\", scores)\n\n\tfmt.Printf(\"現在の要素数: %d\\n\", len(scores))\n}",
        "tags": [
          "data-structures",
          "マップ",
          "map",
          "追加",
          "更新",
          "取得",
          "削除",
          "delete",
          "カンマOK"
        ]
      },
      {
        "title": "データ構造: マップ (Map) のキー存在確認 (カンマOKイディオム)",
        "description": "マップから値を取得する際 (`v := m[key]`)、\nキーが存在しないと値の型の**ゼロ値**が返ります。\nこれだけでは「キーがない」のか「値がゼロ値」なのか\n区別できません。\n\n**カンマOKイディオム:**\nマップアクセス時にキーの存在有無も確認できます。\n`value, ok := マップ名[キー]`\n\n*   `value`: キーに対応する値 (なければゼロ値)。\n*   `ok`: キーが存在したか (`bool`)。存在すれば `true`。\n\nこの `ok` 変数をチェックすれば、キーの存在を確実に判定できます。\n\nコード例では、`scores[\"Bob\"]` はキーが存在し値が `0` なので\n`okBob` は `true`、`scoreBob` は `0` になります。\n一方、`scores[\"Charlie\"]` はキーが存在しないので\n`okCharlie` は `false`、`scoreCharlie` はゼロ値の `0` になります。\n\n**`if` 文との組み合わせ:**\n`if` 文の初期化ステートメントで同時に行うのが一般的です。",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tscores := map[string]int{\n\t\t\"Alice\": 95,\n\t\t\"Bob\":   0, // 値が 0\n\t}\n\n\t// カンマOKイディオムで存在確認\n\tscoreBob, okBob := scores[\"Bob\"] // Bob は存在する\n\tif okBob {\n\t\tfmt.Printf(\"Bob は存在: %d\\n\", scoreBob) // 存在する (値 0)\n\t}\n\n\tscoreCharlie, okCharlie := scores[\"Charlie\"] // Charlie は存在しない\n\tif !okCharlie {\n\t\tfmt.Printf(\"Charlie は不在 (ok=%t, value=%d)\\n\", okCharlie, scoreCharlie) // ok=false, value=0\n\t}\n\n\t// if の初期化ステートメントと組み合わせるのが一般的\n\tif score, ok := scores[\"Alice\"]; ok {\n\t\tfmt.Printf(\"Alice の点数: %d\\n\", score)\n\t} else {\n\t\tfmt.Println(\"Alice は不在\")\n\t}\n\n\tif _, ok := scores[\"David\"]; !ok { // 値は不要な場合 _ で無視\n\t\tfmt.Println(\"David は不在\")\n\t}\n}",
        "tags": [
          "data-structures",
          "マップ",
          "map",
          "キー存在確認",
          "カンマOK",
          "if"
        ]
      },
      {
        "title": "データ構造: マップ (Map) の反復処理 `for range`",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tstock := map[string]int{\n\t\t\"apple\":  10,\n\t\t\"banana\": 25,\n\t\t\"orange\": 0,\n\t\t\"grape\":  15,\n\t}\n\n\tfmt.Println(\"--- 在庫一覧 (キーと値) ---\")\n\t// キー(fruit)と値(count)を取得\n\tfor fruit, count := range stock {\n\t\tfmt.Printf(\"%s: %d個\\n\", fruit, count)\n\t}\n\t// ★ 順序は保証されない！実行ごとに変わる可能性あり\n\n\tfmt.Println(\"\\n--- 在庫のあるフルーツ名 (キーのみ) ---\")\n\t// キー(fruit)のみを取得 (値の変数を省略)\n\tfor fruit := range stock {\n\t\tif stock[fruit] > 0 { // 値が必要なら別途アクセス\n\t\t\tfmt.Println(\"-\", fruit)\n\t\t}\n\t}\n\n\t// 値のみを取得する場合\n\t// for _, count := range stock { ... }\n}",
        "tags": [
          "data-structures",
          "マップ",
          "map",
          "for range",
          "ループ",
          "繰り返し",
          "順序不定"
        ]
      },
      {
        "title": "データ構造: マップ (Map) をキーでソートして反復処理",
        "description": "マップの `for range` は反復順序が保証されません。\nキーの順序（アルファベット順、数値順など）で\n処理したい場合は、以下の手順で行います。\n\n**手順:**\n1.  **キーの抽出:** マップの全キーをスライスに抽出します。",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sort\" // ソート用パッケージ\n)\n\nfunc main() {\n\tstock := map[string]int{\n\t\t\"orange\": 0, \"grape\": 15, \"apple\": 10, \"banana\": 25,\n\t}\n\n\t// 1. キーの抽出\n\tkeys := make([]string, 0, len(stock))\n\tfor k := range stock {\n\t\tkeys = append(keys, k)\n\t}\n\tfmt.Printf(\"キー (ソート前): %q\\n\", keys)\n\n\t// 2. キーのソート (文字列)\n\tsort.Strings(keys)\n\tfmt.Printf(\"キー (ソート後): %q\\n\", keys)\n\n\t// 3. ソート済みキーで反復処理\n\tfmt.Println(\"\\n--- キー順で表示 ---\")\n\tfor _, fruit := range keys {\n\t\tfmt.Printf(\"%s: %d\\n\", fruit, stock[fruit]) // キーを使ってマップの値を取得\n\t}\n}",
        "tags": [
          "data-structures",
          "マップ",
          "map",
          "for range",
          "ループ",
          "繰り返し",
          "ソート",
          "sort",
          "順序"
        ]
      },
      {
        "title": "データ構造: マップ (Map) は参照型",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\n// マップを受け取り変更する関数 (参照渡し)\nfunc modifyMap(m map[string]int) {\n\tfmt.Printf(\"  modifyMap 内 (変更前): %v\\n\", m)\n\tm[\"Carol\"] = 75 // 関数内でマップを変更\n\tdelete(m, \"Bob\")\n\tfmt.Printf(\"  modifyMap 内 (変更後): %v\\n\", m)\n}\n\nfunc main() {\n\t// マップの代入 (参照がコピーされる)\n\toriginalMap := map[string]int{\"Alice\": 85, \"Bob\": 92}\n\tcopiedMap := originalMap // 同じマップデータを指す\n\tcopiedMap[\"Bob\"] = 90    // copiedMap 経由で変更\n\n\tfmt.Printf(\"originalMap: %v\\n\", originalMap) // 元のマップも変更されている\n\tfmt.Printf(\"copiedMap:   %v\\n\", copiedMap)\n\n\t// 関数へのマップの引き渡し (参照が渡される)\n\tmapForFunc := map[string]int{\"Alice\": 100, \"Bob\": 200}\n\tfmt.Printf(\"\\n関数呼び出し前: %v\\n\", mapForFunc)\n\tmodifyMap(mapForFunc) // 関数内で mapForFunc が変更される\n\tfmt.Printf(\"関数呼び出し後: %v\\n\", mapForFunc)\n}",
        "tags": [
          "data-structures",
          "マップ",
          "map",
          "参照型",
          "ポインタ",
          "共有",
          "関数引数"
        ]
      },
      {
        "title": "データ構造: 構造体 (Struct) の定義",
        "description": "異なる型のデータをひとまとめにして新しい型を定義するには\n**構造体 (Struct)** を使います。関連データをグループ化します。\n\n**構造体とは？**\n*   **フィールド (Field)** と呼ばれる名前付き要素の集まり。\n*   各フィールドは異なる型を持てる。\n*   `type` キーワードで新しい構造体型を定義。\n\n**定義構文:**",
        "code": "package main\n\nimport \"fmt\"\n\n// Address 構造体\ntype Address struct {\n\tStreet string // 公開フィールド\n\tCity   string // 公開フィールド\n\tzip    string // 非公開フィールド\n}\n\n// Person 構造体\ntype Person struct {\n\tName    string\n\tAge     int\n\tEmail   string\n\taddress *Address // ポインタ型フィールド (非公開)\n\thobbies []string // スライス型フィールド (非公開)\n}\n\nfunc main() {\n\t// Person 型変数をゼロ値で宣言\n\tvar p1 Person\n\tfmt.Printf(\"p1 (ゼロ値): %+v\\n\", p1)\n\t// 出力例: {Name: Age:0 Email: address:<nil> hobbies:[]}\n\n\t// Address 型変数をゼロ値で宣言\n\tvar addr Address\n\tfmt.Printf(\"addr (ゼロ値): %+v\\n\", addr)\n\t// 出力例: {Street: City: zip:}\n}",
        "tags": [
          "data-structures",
          "構造体",
          "struct",
          "type",
          "フィールド",
          "値型"
        ]
      },
      {
        "title": "データ構造: 構造体 (Struct) の値（インスタンス）の作成",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\ntype Point struct{ X, Y int }\n\ntype Circle struct {\n\tCenter Point\n\tRadius int\n\tLabel  string\n}\n\nfunc main() {\n\t// フィールド名を指定して初期化 (推奨)\n\tp1 := Point{X: 10, Y: 20}\n\tfmt.Printf(\"p1: %+v\\n\", p1)\n\n\t// 順序は任意\n\tp2 := Point{Y: 50, X: 30}\n\tfmt.Printf(\"p2: %+v\\n\", p2)\n\n\t// 一部フィールドのみ初期化 (Y はゼロ値 0)\n\tp3 := Point{X: 100}\n\tfmt.Printf(\"p3: %+v\\n\", p3)\n\n\t// ネストした構造体の初期化\n\tc1 := Circle{\n\t\tCenter: Point{X: 5, Y: 5},\n\t\tRadius: 10,\n\t\tLabel:  \"My Circle\", // 最後のカンマ推奨\n\t}\n\tfmt.Printf(\"c1: %+v\\n\", c1)\n}",
        "tags": [
          "data-structures",
          "構造体",
          "struct",
          "初期化",
          "リテラル",
          "new",
          "ポインタ"
        ]
      },
      {
        "title": "データ構造: 構造体 (Struct) のフィールドへのアクセス",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\ntype User struct {\n\tID       int\n\tUsername string\n\tIsActive bool\n\tprofile  string // 非公開フィールド\n}\n\nfunc main() {\n\tu1 := User{ID: 1, Username: \"gopher\", IsActive: true, profile: \"Go dev\"}\n\tfmt.Printf(\"初期状態 u1: %+v\\n\", u1)\n\n\t// フィールド値の読み取り\n\tuserID := u1.ID\n\tusername := u1.Username\n\tfmt.Printf(\"ID: %d, Username: %s\\n\", userID, username)\n\t// fmt.Println(u1.profile) // 同パッケージ内ならアクセス可\n\n\t// フィールド値の書き込み (代入)\n\tu1.Username = \"gopher_new\"\n\tu1.IsActive = false\n\tfmt.Printf(\"変更後 u1: %+v\\n\", u1)\n\n\t// ゼロ値の構造体へのアクセス\n\tvar u2 User\n\tfmt.Printf(\"\\nゼロ値 u2.ID: %d\\n\", u2.ID) // 0\n\tu2.ID = 2\n\tfmt.Printf(\"変更後 u2: %+v\\n\", u2)\n}",
        "tags": [
          "data-structures",
          "構造体",
          "struct",
          "フィールド",
          "アクセス",
          "代入",
          "ドット演算子",
          "ポインタ"
        ]
      },
      {
        "title": "データ構造: ネストした構造体 (Nested Structs)",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\ntype Department struct {\n\tID   int\n\tName string\n}\n\ntype Employee struct {\n\tEmployeeID int\n\tFullName   string\n\tDept       Department // Department 構造体をフィールドとして持つ\n\tManager    *Employee  // Employee へのポインタ\n}\n\nfunc main() {\n\tmanager := Employee{\n\t\tEmployeeID: 101, FullName: \"Alice Smith\",\n\t\tDept: Department{ID: 10, Name: \"開発部\"},\n\t}\n\n\temp1 := Employee{\n\t\tEmployeeID: 205, FullName: \"Bob Johnson\",\n\t\tDept: Department{ID: 10, Name: \"開発部\"},\n\t\tManager: &manager, // manager のポインタを設定\n\t}\n\n\tfmt.Printf(\"従業員1: %+v\\n\", emp1)\n\n\t// ネストしたフィールドへのアクセス\n\tdepartmentName := emp1.Dept.Name\n\tfmt.Printf(\"部署名: %s\\n\", departmentName)\n\n\tif emp1.Manager != nil {\n\t\tmanagerName := emp1.Manager.FullName // ポインタでも . でアクセス\n\t\tfmt.Printf(\"マネージャー名: %s\\n\", managerName)\n\t}\n}",
        "tags": [
          "data-structures",
          "構造体",
          "struct",
          "ネスト",
          "埋め込み",
          "フィールド"
        ]
      },
      {
        "title": "データ構造: 匿名構造体 (Anonymous Struct)",
        "description": "通常、構造体は `type` で名前を付けて定義しますが、\nGoでは**名前を付けずに**その場で構造体を定義して使う\n**匿名構造体 (Anonymous Struct)** も可能です。\n\n**構文:**",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\t// 匿名構造体の作成と初期化\n\tpoint := struct {\n\t\tX int\n\t\tY int\n\t}{\n\t\tX: 10,\n\t\tY: 20,\n\t}\n\tfmt.Printf(\"point: %+v (%T)\\n\", point, point)\n\tfmt.Printf(\"point.X = %d\\n\", point.X)\n\n\t// 匿名構造体のスライス\n\tusers := []struct {\n\t\tID   int\n\t\tRole string\n\t}{\n\t\t{1, \"Admin\"},\n\t\t{2, \"Editor\"},\n\t}\n\tfmt.Println(\"\\n--- 匿名構造体スライス ---\")\n\tfor _, user := range users {\n\t\tfmt.Printf(\" ID:%d, Role:%s\\n\", user.ID, user.Role)\n\t}\n}",
        "tags": [
          "data-structures",
          "構造体",
          "struct",
          "匿名構造体",
          "リテラル"
        ]
      },
      {
        "title": "データ構造: 構造体の埋め込み (Embedding / Anonymous Fields)",
        "description": "Goには伝統的な「継承」はありませんが、\n**構造体の埋め込み (Embedding)** で似た効果を実現できます。\nフィールド定義で**フィールド名を省略し、型名だけを記述**します\n(**匿名フィールド**とも呼ばれます)。\n\n**構文:**",
        "code": "package main\n\nimport \"fmt\"\n\ntype Point struct {\n\tX, Y int\n}\n\nfunc (p Point) Display() {\n\tfmt.Printf(\"[%d, %d]\", p.X, p.Y)\n}\n\ntype Circle struct {\n\tPoint  // Point 型を匿名フィールドとして埋め込む\n\tRadius int\n}\n\nfunc (c Circle) Area() float64 {\n\treturn 3.14 * float64(c.Radius*c.Radius) // 簡略化\n}\n\nfunc main() {\n\tc1 := Circle{\n\t\tPoint:  Point{X: 10, Y: 20}, // 型名をフィールド名のように使う\n\t\tRadius: 5,\n\t}\n\tfmt.Printf(\"c1: %+v\\n\", c1)\n\n\t// 昇格したフィールドへのアクセス\n\tfmt.Printf(\"X座標 (c1.X): %d\\n\", c1.X) // c1.Point.X と書かずに済む\n\tfmt.Printf(\"半径 (c1.Radius): %d\\n\", c1.Radius)\n\n\t// 昇格したメソッドの呼び出し\n\tfmt.Print(\"座標表示 (c1.Display): \")\n\tc1.Display() // c1.Point.Display() と書かずに済む\n\tfmt.Println()\n\n\t// Circle 自身のメソッド\n\tfmt.Printf(\"面積 (c1.Area): %f\\n\", c1.Area())\n}",
        "tags": [
          "data-structures",
          "構造体",
          "struct",
          "埋め込み",
          "匿名フィールド",
          "継承",
          "is-a"
        ]
      },
      {
        "title": "データ構造: マップを使ったセット (Set) の実装 (map[T]bool)",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\t// セットを作成 (map[string]bool を使用)\n\tfruitSet := make(map[string]bool)\n\n\t// 要素の追加 (キーに要素、値に true)\n\tfruitSet[\"apple\"] = true\n\tfruitSet[\"banana\"] = true\n\tfruitSet[\"orange\"] = true\n\tfruitSet[\"apple\"] = true // 重複は無視される (上書き)\n\tfmt.Printf(\"追加後: %v (len=%d)\\n\", fruitSet, len(fruitSet))\n\n\t// 要素の存在確認 (カンマOKイディオム)\n\tkey := \"banana\"\n\t_, exists := fruitSet[key]\n\tif exists { fmt.Printf(\"'%s' は存在する\\n\", key) }\n\n\tkey = \"grape\"\n\t_, exists = fruitSet[key]\n\tif !exists { fmt.Printf(\"'%s' は存在しない\\n\", key) }\n\n\t// 要素の削除\n\tdelete(fruitSet, \"orange\")\n\tfmt.Printf(\"削除後: %v (len=%d)\\n\", fruitSet, len(fruitSet))\n\n\t// セットの反復処理 (for range でキーを取得)\n\t// for element := range fruitSet { fmt.Println(element) }\n}",
        "tags": [
          "data-structures",
          "マップ",
          "map",
          "セット",
          "set",
          "集合"
        ]
      },
      {
        "title": "データ構造: マップを使ったセットの実装 (map[T]struct{})",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\t// セットを作成 (map[int]struct{} を使用)\n\tnumberSet := make(map[int]struct{})\n\n\t// 要素の追加 (値は空の構造体リテラル)\n\tnumberSet[1] = struct{}{}\n\tnumberSet[3] = struct{}{}\n\tnumberSet[5] = struct{}{}\n\tfmt.Printf(\"追加後: %v (len=%d)\\n\", numberSet, len(numberSet))\n\n\t// 要素の存在確認 (カンマOKイディオム)\n\tkey := 3\n\t_, exists := numberSet[key]\n\tif exists { fmt.Printf(\"'%d' は存在する\\n\", key) }\n\n\tkey = 4\n\t_, exists = numberSet[key]\n\tif !exists { fmt.Printf(\"'%d' は存在しない\\n\", key) }\n\n\t// 要素の削除\n\tdelete(numberSet, 5)\n\tfmt.Printf(\"削除後: %v (len=%d)\\n\", numberSet, len(numberSet))\n\n\t// 反復処理 (キーのみ取得)\n\t// for element := range numberSet { fmt.Println(element) }\n}",
        "tags": [
          "data-structures",
          "マップ",
          "map",
          "セット",
          "set",
          "集合",
          "struct{}",
          "空の構造体",
          "メモリ効率"
        ]
      },
      {
        "title": "データ構造: マップを使ったセットの集合演算",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\n// セットの型定義 (map[string]struct{})\ntype StringSet map[string]struct{}\n\n// 和集合 (A ∪ B)\nfunc union(set1, set2 StringSet) StringSet {\n\tresult := make(StringSet)\n\tfor element := range set1 { // set1 の要素を追加\n\t\tresult[element] = struct{}{}\n\t}\n\tfor element := range set2 { // set2 の要素を追加 (重複は無視される)\n\t\tresult[element] = struct{}{}\n\t}\n\treturn result\n}\n\n// (積集合、差集合の実装は解説参照)\n\nfunc main() {\n\tsetA := StringSet{\"apple\": {}, \"banana\": {}, \"cherry\": {}}\n\tsetB := StringSet{\"banana\": {}, \"cherry\": {}, \"date\": {}}\n\n\tfmt.Printf(\"Set A: %v\\n\", setA)\n\tfmt.Printf(\"Set B: %v\\n\", setB)\n\n\t// 和集合の実行例\n\tunionSet := union(setA, setB)\n\tfmt.Printf(\"A ∪ B: %v\\n\", unionSet)\n}",
        "tags": [
          "data-structures",
          "マップ",
          "map",
          "セット",
          "set",
          "集合",
          "集合演算",
          "和集合",
          "積集合",
          "差集合"
        ]
      },
      {
        "title": "データ構造: 連結リスト (Linked List) - `container/list`",
        "description": "",
        "code": "package main\n\nimport (\n\t\"container/list\" // list パッケージ\n\t\"fmt\"\n)\n\nfunc main() {\n\t// 新しい空のリストを作成\n\tl := list.New()\n\n\t// 要素の追加\n\tl.PushBack(\"Banana\") // 末尾に追加\n\tl.PushBack(123)\n\tl.PushFront(\"Apple\") // 先頭に追加\n\n\t// リストの走査 (先頭から)\n\tfmt.Println(\"--- リスト要素 ---\")\n\tfor e := l.Front(); e != nil; e = e.Next() {\n\t\t// e.Value で値を取得 (any 型)\n\t\tfmt.Printf(\"値: %v (型: %T)\\n\", e.Value, e.Value)\n\t}\n\n\t// リストの長さ\n\tfmt.Printf(\"\\n長さ: %d\\n\", l.Len())\n}",
        "tags": [
          "data-structures",
          "連結リスト",
          "linked list",
          "container/list",
          "双方向連結リスト"
        ]
      },
      {
        "title": "データ構造: 連結リスト (Linked List) の自作",
        "description": "標準ライブラリ `container/list` 以外に、連結リストを\n自分で実装することも可能です。ここでは基本的な\n**単方向連結リスト**の例を示します。\n\n**構造:**\n各要素（**ノード Node**）が以下を持ちます。\n1.  **値 (Value):** ノードが持つデータ。\n2.  **次へのポインタ (Next):** 次のノードを指すポインタ。\n    最後のノードの `Next` は `nil`。\n\nリスト全体は先頭ノード（**ヘッド Head**）へのポインタで参照します。\n\n**実装例 (`Node` 構造体):**",
        "code": "package main\n\nimport \"fmt\"\n\n// 連結リストのノード\ntype Node struct {\n\tValue int\n\tNext  *Node // 次のノードへのポインタ\n}\n\nfunc main() {\n\t// リストの構築: 10 -> 20 -> 30\n\tnode1 := &Node{Value: 10}\n\tnode2 := &Node{Value: 20}\n\tnode3 := &Node{Value: 30}\n\tnode1.Next = node2\n\tnode2.Next = node3\n\thead := node1 // 先頭ノード\n\n\t// リストの走査と表示\n\tfmt.Print(\"List: [ \")\n\tsum := 0\n\tfor current := head; current != nil; current = current.Next {\n\t\tfmt.Printf(\"%d \", current.Value)\n\t\tsum += current.Value\n\t}\n\tfmt.Println(\"]\")\n\tfmt.Printf(\"合計: %d\\n\", sum)\n}",
        "tags": [
          "data-structures",
          "連結リスト",
          "linked list",
          "構造体",
          "struct",
          "ポインタ"
        ]
      }
    ]
  },
  {
    "title": "Methods",
    "codeExamples": [
      {
        "title": "メソッド: 構造体 (Struct) に振る舞いを追加する",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\ntype Rectangle struct {\n\tWidth, Height float64\n}\n\n// Area メソッド (値レシーバ)\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\n// Scale メソッド (ポインタレシーバ)\nfunc (r *Rectangle) Scale(factor float64) {\n\tif r == nil { return }\n\tr.Width *= factor  // 元の値を変更\n\tr.Height *= factor // 元の値を変更\n\tfmt.Printf(\"  (Scale内: W=%.1f, H=%.1f)\\n\", r.Width, r.Height)\n}\n\nfunc main() {\n\trect := Rectangle{Width: 10, Height: 5}\n\tfmt.Printf(\"初期状態: %+v\\n\", rect)\n\n\t// メソッド呼び出し (変数.メソッド名())\n\tarea := rect.Area() // rect がレシーバ (値渡し)\n\tfmt.Printf(\"面積: %.1f\\n\", area)\n\n\tfmt.Println(\"Scale(2) 呼び出し...\")\n\trect.Scale(2) // rect のアドレスがレシーバに渡される\n\tfmt.Printf(\"Scale後: %+v\\n\", rect) // rect の値が変更されている\n}",
        "tags": [
          "methods",
          "struct",
          "レシーバ",
          "func"
        ]
      },
      {
        "title": "メソッド: 構造体以外の型へのメソッド定義",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\n// int を基にした新しい型 MyInt\ntype MyInt int\n\n// MyInt 型に対する IsEven メソッド (値レシーバ)\nfunc (m MyInt) IsEven() bool {\n\treturn m%2 == 0\n}\n\n// MyInt 型に対する Add メソッド (ポインタレシーバ)\nfunc (m *MyInt) Add(n MyInt) {\n\tif m == nil { return }\n\t*m += n // 元の値を変更\n}\n\nfunc main() {\n\tvar num1 MyInt = 10\n\tnum2 := MyInt(25)\n\n\t// IsEven メソッド呼び出し\n\tfmt.Printf(\"%d は偶数か？ %t\\n\", num1, num1.IsEven())\n\tfmt.Printf(\"%d は偶数か？ %t\\n\", num2, num2.IsEven())\n\n\t// Add メソッド呼び出し (ポインタレシーバ)\n\tfmt.Printf(\"Add(5) 前: %d\\n\", num1)\n\t(&num1).Add(5) // アドレスを渡して呼び出す\n\tfmt.Printf(\"Add(5) 後: %d\\n\", num1) // num1 の値が変更される\n\n\t// numPtr := &num2\n\t// numPtr.Add(10) // ポインタ変数経由でも呼び出せる\n}",
        "tags": [
          "methods",
          "type",
          "レシーバ",
          "func"
        ]
      },
      {
        "title": "メソッド: 値レシーバ (Value Receiver)",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\ntype Point struct{ X, Y int }\n\n// Display メソッド (値レシーバ)\nfunc (p Point) Display() {\n\tfmt.Printf(\"[%d, %d]\", p.X, p.Y)\n\t// p.X = 999 // ここで変更しても呼び出し元には影響しない\n}\n\n// Shift メソッド (値レシーバ) - 呼び出し元の値は変更できない\nfunc (p Point) Shift(dx, dy int) {\n\tfmt.Printf(\"  (Shift内 変更前: %+v)\\n\", p)\n\tp.X += dx // コピーを変更\n\tp.Y += dy // コピーを変更\n\tfmt.Printf(\"  (Shift内 変更後: %+v)\\n\", p)\n}\n\nfunc main() {\n\tpt := Point{X: 10, Y: 20}\n\tfmt.Printf(\"初期状態: %+v\\n\", pt)\n\n\tfmt.Print(\"Display() 呼び出し: \")\n\tpt.Display() // pt のコピーが渡される\n\tfmt.Println()\n\tfmt.Printf(\"Display() 後: %+v (変更なし)\\n\", pt)\n\n\tfmt.Println(\"\\nShift(5, 5) 呼び出し...\")\n\tpt.Shift(5, 5) // pt のコピーが渡される\n\tfmt.Printf(\"Shift() 後: %+v (変更なし！)\\n\", pt)\n}",
        "tags": [
          "methods",
          "レシーバ",
          "値レシーバ",
          "値渡し",
          "コピー",
          "不変"
        ]
      },
      {
        "title": "メソッド: ポインタレシーバ (Pointer Receiver)",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\ntype Point struct{ X, Y int }\n\n// Shift メソッド (ポインタレシーバ *Point)\nfunc (p *Point) Shift(dx, dy int) {\n\tif p == nil { // nil チェック推奨\n\t\tfmt.Println(\"nil レシーバです\")\n\t\treturn\n\t}\n\tfmt.Printf(\"  (Shift内 変更前: %+v)\\n\", *p)\n\tp.X += dx // ポインタ経由で元の値を変更\n\tp.Y += dy\n\tfmt.Printf(\"  (Shift内 変更後: %+v)\\n\", *p)\n}\n\nfunc main() {\n\tpt1 := Point{X: 10, Y: 20}\n\tfmt.Printf(\"初期状態 pt1: %+v\\n\", pt1)\n\n\tfmt.Println(\"\\nShift(5, 5) 呼び出し...\")\n\t// 値変数 pt1 でポインタレシーバメソッドを呼ぶ\n\t// Go が暗黙的にアドレス (&pt1) を渡す\n\tpt1.Shift(5, 5)\n\tfmt.Printf(\"Shift() 後の pt1: %+v (変更された！)\\n\", pt1)\n\n\t// var nilPtr *Point = nil\n\t// nilPtr.Shift(1, 1) // メソッド内で nil チェックがあれば panic しない\n}",
        "tags": [
          "methods",
          "レシーバ",
          "ポインタレシーバ",
          "ポインタ",
          "参照渡し",
          "変更"
        ]
      },
      {
        "title": "メソッド: レシーバ型の自動変換",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\ntype Counter struct{ count int }\n\n// 値レシーバメソッド\nfunc (c Counter) Value() int {\n\tfmt.Println(\"  (Value() called)\")\n\treturn c.count\n}\n\n// ポインタレシーバメソッド\nfunc (c *Counter) Increment() {\n\tfmt.Println(\"  (Increment() called)\")\n\tif c == nil { return }\n\tc.count++\n}\n\nfunc main() {\n\tvar c1 Counter        // 値変数\n\tc2 := &Counter{count: 10} // ポインタ変数\n\n\tfmt.Println(\"--- 値変数 c1 で呼び出し ---\")\n\tfmt.Printf(\"c1.Value(): %d\\n\", c1.Value())     // 値 -> 値レシーバ (OK)\n\tc1.Increment()                             // 値 -> ポインタレシーバ (OK: &c1 が渡る)\n\tfmt.Printf(\"Increment() 後 c1.count: %d\\n\", c1.count)\n\n\tfmt.Println(\"\\n--- ポインタ変数 c2 で呼び出し ---\")\n\tfmt.Printf(\"c2.Value(): %d\\n\", c2.Value())     // ポインタ -> 値レシーバ (OK: *c2 が渡る)\n\tc2.Increment()                             // ポインタ -> ポインタレシーバ (OK)\n\tfmt.Printf(\"Increment() 後の c2.count: %d\\n\", c2.count)\n}",
        "tags": [
          "methods",
          "レシーバ",
          "値レシーバ",
          "ポインタレシーバ",
          "ポインタ",
          "アドレス",
          "デリファレンス"
        ]
      },
      {
        "title": "メソッド: メソッド式 (Method Expression)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Point struct{ X, Y float64 }\n\n// Distance メソッド (値レシーバ)\nfunc (p Point) Distance(q Point) float64 {\n\tfmt.Printf(\"  (Distance: p=%+v, q=%+v)\\n\", p, q)\n\tdx := q.X - p.X\n\tdy := q.Y - p.Y\n\treturn math.Sqrt(dx*dx + dy*dy)\n}\n\nfunc main() {\n\tp := Point{1, 2}\n\tq := Point{4, 6}\n\n\t// メソッド式: 型名.メソッド名\n\t// Point.Distance は func(Point, Point) float64 型の関数値\n\tdistanceFunc := Point.Distance\n\tfmt.Printf(\"メソッド式の型: %T\\n\", distanceFunc)\n\n\t// メソッド式を関数として呼び出す\n\t// 第1引数にレシーバ (p)、第2引数以降にメソッド引数 (q)\n\tdist := distanceFunc(p, q)\n\tfmt.Printf(\"distanceFunc(p, q) = %f\\n\", dist) // 5.0\n\n\t// 通常のメソッド呼び出し: p.Distance(q)\n}",
        "tags": [
          "methods",
          "メソッド式",
          "関数型",
          "レシーバ"
        ]
      },
      {
        "title": "メソッド: メソッド式 (ポインタレシーバ)",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\ntype Counter struct{ count int }\n\n// ポインタレシーバメソッド\nfunc (c *Counter) Increment() {\n\tif c == nil { return }\n\tc.count++\n}\n\nfunc main() {\n\tc := Counter{count: 5}\n\tcPtr := &c\n\n\t// ポインタレシーバメソッドのメソッド式を取得\n\t// (*Counter).Increment または Counter.Increment\n\tincrementFunc := (*Counter).Increment\n\tfmt.Printf(\"メソッド式の型: %T\\n\", incrementFunc) // func(*main.Counter)\n\n\t// メソッド式を関数として呼び出す\n\t// 第1引数にはレシーバのポインタ (*Counter) を渡す\n\tincrementFunc(&c) // 値 c のアドレスを渡す\n\tfmt.Printf(\"incrementFunc(&c) 後: c.count = %d\\n\", c.count) // 6\n\n\tincrementFunc(cPtr) // ポインタ変数 cPtr を渡す\n\tfmt.Printf(\"incrementFunc(cPtr) 後: c.count = %d\\n\", c.count) // 7\n\n\t// incrementFunc(c) // コンパイルエラー: 型が違う\n}",
        "tags": [
          "methods",
          "メソッド式",
          "関数型",
          "レシーバ",
          "ポインタレシーバ",
          "ポインタ"
        ]
      },
      {
        "title": "メソッド: メソッド値 (Method Value)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Point struct{ X, Y float64 }\n\n// Distance メソッド (値レシーバ)\nfunc (p Point) Distance(q Point) float64 {\n\tdx := q.X - p.X\n\tdy := q.Y - p.Y\n\treturn math.Sqrt(dx*dx + dy*dy)\n}\n\nfunc main() {\n\tp := Point{1, 2}\n\tq := Point{4, 6}\n\n\t// メソッド値: 変数 p にバインドされた Distance メソッド\n\t// 型は func(Point) float64 (レシーバ引数なし)\n\tdistanceFromP := p.Distance\n\tfmt.Printf(\"メソッド値の型: %T\\n\", distanceFromP)\n\n\t// メソッド値を関数として呼び出す (引数は q のみ)\n\tdist := distanceFromP(q) // 実質的に p.Distance(q) が実行される\n\tfmt.Printf(\"distanceFromP(q) = %f\\n\", dist)\n}",
        "tags": [
          "methods",
          "メソッド値",
          "関数型",
          "レシーバ",
          "クロージャ"
        ]
      },
      {
        "title": "メソッド: メソッドチェーン (Method Chaining)",
        "description": "メソッド呼び出しを `.` で繋げて流れるように記述するスタイルを\n**メソッドチェーン (Method Chaining)** または\n**流暢なインターフェース (Fluent Interface)** と呼びます。\n一連の操作を直感的かつ簡潔に表現できます。\n\n**実現方法:**\nメソッドが処理後、**レシーバ自身（通常はそのポインタ）を\n戻り値として返す**ように設計します。",
        "code": "package main\n\nimport \"fmt\"\n\ntype StringBuilder struct {\n\tbuffer []byte\n}\n\n// Append は *StringBuilder を返し、チェーンを可能にする\nfunc (sb *StringBuilder) Append(s string) *StringBuilder {\n\tif sb == nil { return nil }\n\tsb.buffer = append(sb.buffer, s...)\n\treturn sb // レシーバ自身を返す\n}\n\n// String は最終結果を返す (チェーンの最後)\nfunc (sb *StringBuilder) String() string {\n\tif sb == nil { return \"\" }\n\treturn string(sb.buffer)\n}\n\nfunc main() {\n\tbuilder := &StringBuilder{} // ポインタで作成\n\n\t// メソッド呼び出しを . で繋げる\n\tresult := builder.Append(\"Hello\").Append(\", \").Append(\"World!\").String()\n\n\tfmt.Println(result) // Hello, World!\n}",
        "tags": [
          "methods",
          "メソッドチェーン",
          "流暢なインターフェース",
          "ビルダーパターン",
          "ポインタレシーバ"
        ]
      },
      {
        "title": "メソッド: メソッドチェーンとビルダーパターン",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\n// HTTPリクエストビルダー\ntype RequestBuilder struct {\n\tmethod  string\n\turl     string\n\theaders map[string]string\n}\n\n// Method設定 (レシーバを返しチェーン可能)\nfunc (rb *RequestBuilder) Method(method string) *RequestBuilder {\n\tif rb == nil { return nil }\n\trb.method = method\n\treturn rb\n}\n\n// URL設定 (レシーバを返しチェーン可能)\nfunc (rb *RequestBuilder) URL(url string) *RequestBuilder {\n\tif rb == nil { return nil }\n\trb.url = url\n\treturn rb\n}\n// Header設定メソッド (同様に *RequestBuilder を返す)\nfunc (rb *RequestBuilder) Header(key, value string) *RequestBuilder {\n\tif rb == nil { return nil }\n\tif rb.headers == nil { rb.headers = make(map[string]string) }\n\trb.headers[key] = value\n\treturn rb\n}\n\n\n// Buildメソッド (最終オブジェクト生成)\nfunc (rb *RequestBuilder) Build() (*http.Request, error) {\n\tif rb == nil { return nil, fmt.Errorf(\"nil builder\") }\n\treq, err := http.NewRequest(rb.method, rb.url, nil) // Body は nil\n\tif err != nil { return nil, fmt.Errorf(\"request error: %w\", err) }\n\tfor key, value := range rb.headers {\n\t\treq.Header.Add(key, value)\n\t}\n\treturn req, nil\n}\n\nfunc main() {\n\t// メソッドチェーンでリクエスト構築\n\treq, err := (&RequestBuilder{}). // 初期化 (または New 関数を使う)\n\t\t\t\tMethod(\"GET\").\n\t\t\t\tURL(\"https://example.com/api\").\n\t\t\t\tHeader(\"Accept\", \"application/json\").\n\t\t\t\tBuild()\n\n\tif err != nil { fmt.Printf(\"エラー: %v\\n\", err); return }\n\n\tfmt.Printf(\"Method: %s, URL: %s\\n\", req.Method, req.URL)\n\tfmt.Printf(\"Header: %v\\n\", req.Header)\n}",
        "tags": [
          "methods",
          "メソッドチェーン",
          "流暢なインターフェース",
          "ビルダーパターン",
          "デザインパターン",
          "net/http"
        ]
      },
      {
        "title": "メソッド vs 関数: まとめと比較",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\ntype Rectangle struct {\n\tWidth, Height float64\n}\n\n// Rectangle 型に Area メソッドを定義\nfunc (r Rectangle) Area() float64 {\n\treturn r.Width * r.Height\n}\n\nfunc main() {\n\trect := Rectangle{Width: 10, Height: 5}\n\tfmt.Printf(\"長方形: %+v\\n\", rect)\n\n\t// メソッド呼び出し\n\tarea := rect.Area()\n\tfmt.Printf(\"メソッド呼び出し (rect.Area()): %.1f\\n\", area)\n\n\t// 関数ならこう呼び出す (関数定義は省略)\n\t// areaFunc := CalculateAreaFunc(rect)\n}",
        "tags": [
          "methods",
          "functions",
          "レシーバ",
          "比較"
        ]
      }
    ]
  },
  {
    "title": "Interfaces",
    "codeExamples": [
      {
        "title": "インターフェース: 振る舞いの契約を定義する",
        "description": "Goの**インターフェース (Interface)** は、具体的な実装を持たず、\n**どのようなメソッドを持っているべきか**という\n**メソッドシグネチャの集まり**だけを定義します。\n型が満たすべき**契約 (Contract)** や**仕様**のようなものです。\n\n**インターフェースとは？**\n*   メソッドシグネチャの集まり (名前, 引数, 戻り値)。\n*   型が「何ができるか」(振る舞い) を定義する。\n*   具体的なデータを持たない**抽象型**。\n*   同じインターフェースを満たす異なる型を統一的に扱う\n    **ポリモーフィズム**を実現する。\n\n**定義構文:**",
        "code": "package main\n\nimport \"fmt\"\n\n// Shape インターフェース: 振る舞いを定義\ntype Shape interface {\n\tArea() float64      // 面積を返すメソッド\n\tPerimeter() float64 // 周長を返すメソッド\n}\n\n// Shape インターフェース型の引数を受け取る関数\n// 具体的な型 (Rectangle, Circle 等) を知らなくても動作する\nfunc printShapeInfo(s Shape) {\n\tif s == nil {\n\t\tfmt.Println(\"図形が nil です\")\n\t\treturn\n\t}\n\tfmt.Printf(\"図形情報: %T\\n\", s) // 実行時の具体的な型が表示される\n\tfmt.Printf(\"  面積: %.2f\\n\", s.Area())      // インターフェースのメソッドを呼び出す\n\tfmt.Printf(\"  周長: %.2f\\n\", s.Perimeter()) // インターフェースのメソッドを呼び出す\n}\n\nfunc main() {\n\t// インターフェース型のゼロ値は nil\n\tvar s Shape\n\tfmt.Printf(\"初期状態 s: %v (%T)\\n\", s, s) // <nil> (<nil>)\n\t// printShapeInfo(s) // s が nil なので Area() 呼び出しで panic する\n\n\t// (次のセクションで具体的な型を Shape として使う例を示す)\n}",
        "tags": [
          "interfaces",
          "interface",
          "メソッドシグネチャ",
          "契約",
          "ポリモーフィズム"
        ]
      },
      {
        "title": "インターフェース: インターフェースの実装 (暗黙的)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\n// インターフェース定義\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\n// 具体的な型: Rectangle\ntype Rectangle struct {\n\tWidth, Height float64\n}\n\n// Rectangle が Shape のメソッドを実装\nfunc (r Rectangle) Area() float64      { return r.Width * r.Height }\nfunc (r Rectangle) Perimeter() float64 { return 2 * (r.Width + r.Height) }\n\n// 具体的な型: Circle\ntype Circle struct {\n\tRadius float64\n}\n\n// Circle が Shape のメソッドを実装\nfunc (c Circle) Area() float64      { return math.Pi * c.Radius * c.Radius }\nfunc (c Circle) Perimeter() float64 { return 2 * math.Pi * c.Radius }\n\nfunc main() {\n\t// Rectangle と Circle は Shape のメソッドを全て持つので、\n\t// 暗黙的に Shape インターフェースを実装している\n\tvar s1 Shape = Rectangle{Width: 10, Height: 5}\n\tvar s2 Shape = Circle{Radius: 3}\n\n\tfmt.Printf(\"s1 (%T): Area=%.2f\\n\", s1, s1.Area())\n\tfmt.Printf(\"s2 (%T): Area=%.2f\\n\", s2, s2.Area())\n}",
        "tags": [
          "interfaces",
          "interface",
          "メソッド",
          "実装",
          "暗黙的",
          "ダックタイピング"
        ]
      },
      {
        "title": "インターフェース: インターフェースを使ったポリモーフィズム",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\n// インターフェース定義\ntype Shape interface {\n\tArea() float64\n\tPerimeter() float64\n}\n\n// 具体的な型 Rectangle\ntype Rectangle struct{ Width, Height float64 }\nfunc (r Rectangle) Area() float64      { return r.Width * r.Height }\nfunc (r Rectangle) Perimeter() float64 { return 2 * (r.Width + r.Height) }\n\n// 具体的な型 Circle\ntype Circle struct{ Radius float64 }\nfunc (c Circle) Area() float64      { return math.Pi * c.Radius * c.Radius }\nfunc (c Circle) Perimeter() float64 { return 2 * math.Pi * c.Radius }\n\n// インターフェースを利用する関数\nfunc printShapeInfo(s Shape) {\n\tfmt.Printf(\"  図形:%T, 面積:%.2f, 周長:%.2f\\n\", s, s.Area(), s.Perimeter())\n}\n\nfunc main() {\n\trect := Rectangle{Width: 10, Height: 5}\n\tcirc := Circle{Radius: 3}\n\n\tfmt.Println(\"--- printShapeInfo 呼び出し ---\")\n\t// Shape を実装する具体的な型 (Rectangle, Circle) を渡せる\n\tprintShapeInfo(rect)\n\tprintShapeInfo(circ)\n\n\t// var s Shape = rect // インターフェース型変数にも代入可\n\t// s = circ\n\t// fmt.Println(s.Area())\n\n\t// shapes := []Shape{rect, circ} // インターフェース型スライスも可\n\t// fmt.Println(totalArea(shapes))\n}\n\n// func totalArea(shapes []Shape) float64 { ... } // (実装略)",
        "tags": [
          "interfaces",
          "interface",
          "メソッド",
          "ポリモーフィズム",
          "多態性",
          "疎結合"
        ]
      },
      {
        "title": "インターフェース: `nil` インターフェースと `nil` 値を持つインターフェース",
        "description": "インターフェース変数が `nil` である状態には2つの意味合いがあり、\n注意が必要です。\n\n**インターフェース変数の内部:**\nインターフェース変数は内部的に2つ持ちます。\n1. **型 (Type):** 格納された具体的な値の型情報。\n2. **値 (Value):** 格納された具体的な値へのポインタ等。\n\n**1. `nil` インターフェース:**\n`var err error` のように宣言しただけの状態。\n内部の**型も値も両方 `nil`** です。\n`err == nil` の比較は **`true`** になります。\n\n**2. `nil` 値を持つインターフェース (非 `nil` インターフェース):**\nインターフェース変数に、**具体的な型**を持つが\nその**値が `nil`** である値 (nilポインタ等) を代入した場合。",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\n// nil ポインタ (*os.File) を error として返す関数\nfunc getNilPointerAsError() error {\n\tvar ptr *os.File = nil\n\t// 戻り値 error は (型=*os.File, 値=nil) となる\n\treturn ptr\n}\n\nfunc main() {\n\t// nil インターフェース (型=nil, 値=nil)\n\tvar err1 error\n\tfmt.Printf(\"err1: 型=%T, 値=%v\\n\", err1, err1)\n\tif err1 == nil { fmt.Println(\"err1 == nil は true\") }\n\n\tfmt.Println()\n\n\t// nil 値を持つインターフェース (型=*os.File, 値=nil)\n\terr2 := getNilPointerAsError()\n\tfmt.Printf(\"err2: 型=%T, 値=%v\\n\", err2, err2) // 型情報が表示される\n\tif err2 == nil {\n\t\tfmt.Println(\"err2 == nil は true\")\n\t} else {\n\t\t// 型情報を持つため、インターフェースとしては nil ではない\n\t\tfmt.Println(\"err2 == nil は false\")\n\t}\n\n\t// err2 は nil ではないが、値は nil なのでメソッド呼び出しは panic\n\t// err2.Error() // panic: runtime error: invalid memory address or nil pointer dereference\n}",
        "tags": [
          "interfaces",
          "interface",
          "nil",
          "型情報",
          "値",
          "ポインタ"
        ]
      },
      {
        "title": "インターフェース: 型アサーション (Type Assertion)",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar i any // interface{} と同じ\n\n\ti = \"Hello\"\n\n\t// カンマOKイディオム (安全な方法)\n\tfmt.Println(\"--- カンマOKイディオム ---\")\n\ts2, ok1 := i.(string) // string かチェック\n\tif ok1 {\n\t\tfmt.Printf(\"i は string: \\\"%s\\\"\\n\", s2)\n\t} else {\n\t\tfmt.Println(\"i は string ではない\")\n\t}\n\n\tnum2, ok2 := i.(int) // int かチェック\n\tif ok2 {\n\t\tfmt.Printf(\"i は int: %d\\n\", num2)\n\t} else {\n\t\t// ok2 は false, num2 は int のゼロ値 0\n\t\tfmt.Printf(\"i は int ではない (ok=%t, value=%d)\\n\", ok2, num2)\n\t}\n\n\t// if 文の初期化と組み合わせるのが一般的\n\tfmt.Println(\"\\n--- if 文との組み合わせ ---\")\n\ti = 123 // i に int を代入\n\tif num, ok := i.(int); ok {\n\t\t// アサーション成功時のみ実行\n\t\tfmt.Printf(\"i は int で値は %d\\n\", num)\n\t} else {\n\t\tfmt.Println(\"i は int ではない\")\n\t}\n}",
        "tags": [
          "interfaces",
          "interface",
          "型アサーション",
          "type assertion",
          "カンマOK",
          "panic"
        ]
      },
      {
        "title": "インターフェース: 型スイッチ (Type Switch)",
        "description": "インターフェース変数に格納された値の**具体的な型**に\n基づいて処理を分岐させたい場合、**型スイッチ**を使います。\nこれは `switch` 文の特殊な形式です。\n\n**構文:**",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Shape interface{ Area() float64 }\ntype Rectangle struct{ Width, Height float64 }\nfunc (r Rectangle) Area() float64 { return r.Width * r.Height }\ntype Circle struct{ Radius float64 }\nfunc (c Circle) Area() float64 { return math.Pi * c.Radius * c.Radius }\n\n// 型スイッチを使う関数\nfunc describeShape(s Shape) {\n\tfmt.Printf(\"入力: %v, \", s)\n\tswitch v := s.(type) { // 型スイッチ構文\n\tcase Rectangle:\n\t\t// v は Rectangle 型\n\t\tfmt.Printf(\"長方形 (W:%.1f, H:%.1f), 面積:%.2f\\n\", v.Width, v.Height, v.Area())\n\tcase Circle:\n\t\t// v は Circle 型\n\t\tfmt.Printf(\"円 (R:%.1f), 面積:%.2f\\n\", v.Radius, v.Area())\n\tcase nil:\n\t\tfmt.Println(\"nil\")\n\tdefault:\n\t\t// v は元の Shape 型\n\t\tfmt.Printf(\"未知の図形 (%T), 面積:%.2f\\n\", v, v.Area())\n\t}\n}\n\nfunc main() {\n\tvar s Shape // nil\n\tdescribeShape(s)\n\n\ts = Rectangle{5, 4}\n\tdescribeShape(s)\n\n\ts = Circle{2.5}\n\tdescribeShape(s)\n}",
        "tags": [
          "interfaces",
          "interface",
          "型スイッチ",
          "type switch",
          "switch"
        ]
      },
      {
        "title": "インターフェース: 空インターフェース (`interface{}` / `any`)",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\t// any 型 (interface{} と同じ) の変数\n\tvar value any\n\n\t// 様々な型の値を代入可能\n\tvalue = 42\n\tfmt.Printf(\"値: %v (%T)\\n\", value, value)\n\n\tvalue = \"Hello\"\n\tfmt.Printf(\"値: %v (%T)\\n\", value, value)\n\n\tvalue = 3.14\n\tfmt.Printf(\"値: %v (%T)\\n\", value, value)\n\n\tvalue = true\n\tfmt.Printf(\"値: %v (%T)\\n\", value, value)\n\n\tvalue = []int{1, 2}\n\tfmt.Printf(\"値: %v (%T)\\n\", value, value)\n\n\tvalue = nil\n\tfmt.Printf(\"値: %v (%T)\\n\", value, value)\n}",
        "tags": [
          "interfaces",
          "interface",
          "any",
          "空インターフェース",
          "型アサーション",
          "型スイッチ"
        ]
      },
      {
        "title": "インターフェース: 空インターフェースと型アサーション",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar data any // 空インターフェース\n\n\tdata = \"Hello\"\n\n\t// カンマOKイディオムで string 型かチェック\n\tstrValue, ok := data.(string)\n\tif ok {\n\t\tfmt.Printf(\"string として取得成功: \\\"%s\\\"\\n\", strValue)\n\t} else {\n\t\tfmt.Println(\"string ではない\")\n\t}\n\n\t// カンマOKイディオムで int 型かチェック\n\tintValue, ok := data.(int)\n\tif ok {\n\t\tfmt.Printf(\"int として取得成功: %d\\n\", intValue)\n\t} else {\n\t\t// data は string なので失敗 (ok=false, intValue=0)\n\t\tfmt.Printf(\"int ではない (ok=%t, zeroValue=%d)\\n\", ok, intValue)\n\t}\n\n\t// パニックする可能性のある形式 (非推奨)\n\t// s := data.(string) // もし data が string でなければ panic\n}",
        "tags": [
          "interfaces",
          "interface",
          "any",
          "空インターフェース",
          "型アサーション",
          "type assertion",
          "カンマOK"
        ]
      },
      {
        "title": "インターフェース: 空インターフェースと型スイッチ",
        "description": "空インターフェース (`any`/`interface{}`) は\n任意の型の値を保持できるため、その具体的な型に\n応じて処理を分岐させたい場合に\n**型スイッチ (Type Switch)** が役立ちます。\n(`switch` 文の特殊形式)\n\n型スイッチを使うと、複数の型アサーションを\n`if-else if` で繋げるよりも安全かつ簡潔に書けます。\n\n**構文:**",
        "code": "package main\n\nimport \"fmt\"\n\n// any 型の値を受け取り、型に応じて処理\nfunc processAnything(value any) {\n\tfmt.Printf(\"入力: %v, \", value)\n\tswitch v := value.(type) { // 型スイッチ\n\tcase int:\n\t\tfmt.Printf(\"整数: %d\\n\", v)\n\tcase string:\n\t\tfmt.Printf(\"文字列: %s\\n\", v)\n\tcase bool:\n\t\tfmt.Printf(\"真偽値: %t\\n\", v)\n\tcase nil:\n\t\tfmt.Println(\"nil\")\n\tdefault:\n\t\tfmt.Printf(\"その他 (%T)\\n\", v)\n\t}\n}\n\nfunc main() {\n\tprocessAnything(100)\n\tprocessAnything(\"Go\")\n\tprocessAnything(true)\n\tprocessAnything(nil)\n\tprocessAnything(1.23) // default\n}",
        "tags": [
          "interfaces",
          "interface",
          "any",
          "空インターフェース",
          "型スイッチ",
          "type switch",
          "switch"
        ]
      },
      {
        "title": "インターフェース: 空インターフェース (`any`) の一般的な使い道",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\t// any 型のスライス (異なる型を混在可能)\n\tmixedSlice := []any{\n\t\t42,\n\t\t\"world\",\n\t\tfalse,\n\t\tstruct{ Name string }{\"Gopher\"},\n\t\tnil,\n\t}\n\n\t// 型スイッチで実際の型を判別して処理\n\tfor i, item := range mixedSlice {\n\t\tfmt.Printf(\"Index %d: \", i)\n\t\tswitch v := item.(type) {\n\t\tcase int:\n\t\t\tfmt.Printf(\"整数 %d\\n\", v)\n\t\tcase string:\n\t\t\tfmt.Printf(\"文字列 \\\"%s\\\"\\n\", v)\n\t\tcase bool:\n\t\t\tfmt.Printf(\"真偽値 %t\\n\", v)\n\t\tdefault:\n\t\t\tfmt.Printf(\"その他 %T (%v)\\n\", v, v)\n\t\t}\n\t}\n}",
        "tags": [
          "interfaces",
          "interface",
          "any",
          "空インターフェース",
          "fmt.Println",
          "JSON",
          "コンテナ"
        ]
      },
      {
        "title": "インターフェース: インターフェースの組み合わせ (コンポジション)",
        "description": "既存のインターフェースを**埋め込む (Embed)** ことで、\n新しいインターフェースを**組み合わせ (Compose)** て定義できます。\n(構造体の埋め込みと似ている)\n\n**インターフェースコンポジション:**\n複数の小さなインターフェースが持つメソッドセットを\nすべて含んだ、より大きなインターフェースを作成できます。\n\n**構文:**",
        "code": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\" // Reader, Writer, ReadWriter など\n)\n\n// io パッケージのインターフェース定義 (例)\n// type Reader interface { Read(p []byte) (n int, err error) }\n// type Writer interface { Write(p []byte) (n int, err error) }\n// type ReadWriter interface {\n//     Reader // Reader インターフェースを埋め込み\n//     Writer // Writer インターフェースを埋め込み\n// }\n\nfunc main() {\n\tvar buffer bytes.Buffer // Read と Write メソッドを持つ\n\n\t// buffer は Writer を満たす\n\tvar writer io.Writer = &buffer\n\twriter.Write([]byte(\"Data \"))\n\tfmt.Printf(\"Writer (%T): OK\\n\", writer)\n\n\t// buffer は Reader を満たす\n\tvar reader io.Reader = &buffer\n\t// reader.Write(...) // エラー: Reader に Write はない\n\tfmt.Printf(\"Reader (%T): OK\\n\", reader)\n\n\t// buffer は Reader と Writer を両方満たすので、\n\t// それらを埋め込んだ ReadWriter も満たす\n\tvar readWriter io.ReadWriter = &buffer\n\treadWriter.Write([]byte(\"More\"))\n\tbuf := make([]byte, 10)\n\tn, _ := readWriter.Read(buf)\n\tfmt.Printf(\"ReadWriter (%T): Read '%s'\\n\", readWriter, string(buf[:n]))\n}",
        "tags": [
          "interfaces",
          "interface",
          "埋め込み",
          "コンポジション",
          "io.Reader",
          "io.Writer",
          "io.ReadWriter"
        ]
      },
      {
        "title": "インターフェースのベストプラクティス: 小さく保つ (単一責任)",
        "description": "",
        "code": "// 良い例: io.Reader (読み取り責務のみ)\ntype Reader interface {\n\tRead(p []byte) (n int, err error)\n}\n\n// 良い例: io.Writer (書き込み責務のみ)\ntype Writer interface {\n\tWrite(p []byte) (n int, err error)\n}\n\n// 良い例: io.Closer (クローズ責務のみ)\ntype Closer interface {\n\tClose() error\n}\n\n// 組み合わせ例: io.ReadWriter (Reader と Writer を埋め込み)\n// type ReadWriter interface {\n//     Reader\n//     Writer\n// }",
        "tags": [
          "interfaces",
          "interface",
          "ベストプラクティス",
          "設計原則",
          "単一責任の原則"
        ]
      },
      {
        "title": "インターフェースのベストプラクティス: インターフェースを受け入れ、構造体を返す",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\n// User 構造体 (返す型: 具体的な構造体)\ntype User struct {\n\tID   int\n\tName string\n}\n\n// UserGetter インターフェース (受け入れる型: 振る舞いを定義)\ntype UserGetter interface {\n\tGetUserByID(id int) (*User, error) // 具体的な *User を返す\n}\n\n// --- 実装例 (Database や MockUserGetter などが UserGetter を実装) ---\n// (実装詳細は省略、解説参照)\ntype Database struct { users map[int]*User } // 例\nfunc (db *Database) GetUserByID(id int) (*User, error) { /* ... */ return db.users[id], nil }\n\n// --- インターフェースを利用する関数 ---\n// 引数に UserGetter インターフェースを受け取る\nfunc ProcessUser(getter UserGetter, userID int) {\n\tfmt.Printf(\"\\nProcessUser(%d) 呼び出し\\n\", userID)\n\tuser, err := getter.GetUserByID(userID) // インターフェース経由で呼び出し\n\tif err != nil {\n\t\tfmt.Printf(\"エラー: %v\\n\", err)\n\t\treturn\n\t}\n\t// 戻り値は *User なのでフィールドに直接アクセス可\n\tfmt.Printf(\"取得成功: ID=%d, Name=%s\\n\", user.ID, strings.ToUpper(user.Name))\n}\n\nfunc main() {\n\tdb := &Database{users: map[int]*User{1: {1, \"Alice\"}}} // 実装例\n\n\t// ProcessUser に具体的な実装 (db) をインターフェースとして渡す\n\tProcessUser(db, 1)\n\tProcessUser(db, 3) // エラー例\n}",
        "tags": [
          "interfaces",
          "interface",
          "ベストプラクティス",
          "設計原則",
          "疎結合",
          "struct"
        ]
      },
      {
        "title": "インターフェースのベストプラクティス: 利用する側でインターフェースを定義する",
        "description": "",
        "code": "package userservice // インターフェースを利用する側のパッケージ\n\nimport \"fmt\"\n\n// User 構造体 (例)\ntype User struct{ ID int; Name string }\n\n// ★★★ インターフェースを利用側で定義 ★★★\n// UserStorer: ユーザーの取得・保存に必要な振る舞いを定義\ntype UserStorer interface {\n\tGetUser(id int) (*User, error)\n\tSaveUser(user *User) error\n}\n\n// Service: UserStorer インターフェースに依存する\ntype Service struct {\n\tStore UserStorer // 具体的な実装ではなくインターフェースを持つ\n}\n\n// GetUserName メソッド (UserStorer を利用)\nfunc (s *Service) GetUserName(id int) (string, error) {\n\tuser, err := s.Store.GetUser(id) // インターフェース経由で呼び出し\n\tif err != nil { return \"\", fmt.Errorf(\"取得失敗: %w\", err) }\n\treturn user.Name, nil\n}\n\n// (NewService や SaveNewUser など他のメソッドは省略)",
        "tags": [
          "interfaces",
          "interface",
          "ベストプラクティス",
          "設計原則",
          "依存関係",
          "疎結合",
          "パッケージ"
        ]
      },
      {
        "title": "インターフェースのベストプラクティス: 命名規則 (`-er` サフィックス)",
        "description": "",
        "code": "// 例: 標準ライブラリのインターフェース\n\n// 読み取るもの\ntype Reader interface {\n\tRead(p []byte) (n int, err error)\n}\n\n// 書き込むもの\ntype Writer interface {\n\tWrite(p []byte) (n int, err error)\n}\n\n// 文字列化するもの\ntype Stringer interface {\n\tString() string\n}\n\n// 閉じるもの\ntype Closer interface {\n\tClose() error\n}\n\n// HTTPリクエストを処理するもの\n// type Handler interface { ServeHTTP(...) } // net/http",
        "tags": [
          "interfaces",
          "interface",
          "ベストプラクティス",
          "命名規則",
          "-er"
        ]
      },
      {
        "title": "インターフェースのベストプラクティス: 空インターフェース (`any`) の乱用を避ける",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\n// 良い例: 具体的な型を使う\ntype UserData struct {\n\tName  string\n\tEmail string\n\tTags  []string\n}\n\n// 具体的な UserData 型を受け取る関数\nfunc processUserDataGood(data UserData) {\n\tfmt.Println(\"\\n--- processUserDataGood ---\")\n\tfmt.Printf(\"ユーザー名: %s\\n\", data.Name)\n\tfmt.Printf(\"メール: %s\\n\", data.Email)\n\tfmt.Printf(\"タグ: %s\\n\", strings.Join(data.Tags, \", \"))\n\t// 型が明確なのでフィールドに安全にアクセスできる\n}\n\nfunc main() {\n\tuserData := UserData{\n\t\tName: \"Gopher\", Email: \"gopher@example.com\", Tags: []string{\"go\", \"dev\"},\n\t}\n\tprocessUserDataGood(userData) // 具体的な型を渡す\n}",
        "tags": [
          "interfaces",
          "interface",
          "any",
          "空インターフェース",
          "ベストプラクティス",
          "型安全性",
          "ジェネリクス"
        ]
      },
      {
        "title": "インターフェースのベストプラクティス: `nil` インターフェースを正しく返す",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n)\n\ntype MyError struct{ Message string }\nfunc (e *MyError) Error() string { return e.Message }\n\n// 悪い例: 成功時に *MyError 型の nil ポインタを返す\nfunc processDataBad(fail bool) error {\n\tif fail { return &MyError{\"失敗\"} }\n\tvar errPtr *MyError = nil\n\treturn errPtr // (型=*main.MyError, 値=nil) の error が返る\n}\n\n// 良い例: 成功時に明示的に nil を返す\nfunc processDataGood(fail bool) error {\n\tif fail { return &MyError{\"失敗\"} }\n\treturn nil // (型=nil, 値=nil) の error が返る\n}\n\nfunc main() {\n\tfmt.Println(\"--- 悪い例 ---\")\n\terrBad := processDataBad(false) // 成功のはずが...\n\tfmt.Printf(\"errBad: (%T, %v)\\n\", errBad, errBad)\n\tif errBad != nil {\n\t\t// 型情報を持つため nil ではないと判定される！\n\t\tfmt.Println(\" エラー発生と誤判定:\", errBad)\n\t}\n\n\tfmt.Println(\"\\n--- 良い例 ---\")\n\terrGood := processDataGood(false) // 成功\n\tfmt.Printf(\"errGood: (%T, %v)\\n\", errGood, errGood)\n\tif errGood != nil {\n\t\tfmt.Println(\" エラー発生:\", errGood)\n\t} else {\n\t\t// 正しく nil と判定される\n\t\tfmt.Println(\" 処理成功\")\n\t}\n}",
        "tags": [
          "interfaces",
          "interface",
          "nil",
          "エラー処理",
          "ベストプラクティス",
          "ポインタ"
        ]
      },
      {
        "title": "インターフェース: ジェネリクスの型制約としての利用",
        "description": "Go 1.18 で導入された**ジェネリクス**では、\n**型パラメータ** (`[T any]`) が受け入れ可能な型を\n指定する**型制約 (Type Constraint)** として\n**インターフェース**を使います。\n\n**なぜ制約が必要か？**\nジェネリック関数内で型パラメータ `T` の値に対し、\n特定の操作（メソッド呼び出し、演算子 `+` `<` `==` など）を\n行いたい場合、`T` がその操作をサポートすることを\nコンパイラに伝える必要があるためです。\n\n**インターフェースによる型制約:**\n1.  **メソッドセットによる制約:**\n    従来通り、特定のメソッドを持つ型に制約します。",
        "code": "package main\n\nimport \"fmt\"\n\n// 型リストによる制約: int または float64 を許容\ntype Number interface {\n\tint | float64\n\t// ~int | ~float64 のように ~ を付けると基底型が int/float64 の型も許容\n}\n\n// ジェネリック関数: Number 制約を持つ型 T を受け取る\nfunc Double[T Number](value T) T {\n\t// T は int か float64 なので * 2 が可能\n\treturn value * 2\n}\n\n// 比較可能な型を制約する組み込みの comparable\nfunc AreEqual[T comparable](a, b T) bool {\n\treturn a == b\n}\n\nfunc main() {\n\tfmt.Println(\"Double(5):\", Double(5))       // T=int\n\tfmt.Println(\"Double(3.14):\", Double(3.14)) // T=float64\n\t// Double(\"hello\") // エラー: string は Number 制約を満たさない\n\n\tfmt.Println(\"AreEqual(1, 1):\", AreEqual(1, 1)) // T=int\n\t// AreEqual([]int{1}, []int{1}) // エラー: スライスは比較不可\n}",
        "tags": [
          "interfaces",
          "interface",
          "ジェネリクス",
          "generics",
          "型パラメータ",
          "型制約",
          "constraint"
        ]
      },
      {
        "title": "インターフェース: 制約付きジェネリック関数",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\n// 型制約インターフェース: int または float64\ntype Number interface {\n\tint | float64\n}\n\n// ジェネリック関数: Number 制約を持つ型 T のスライスの合計を計算\nfunc SumNumbers[T Number](values []T) T {\n\tvar sum T // T のゼロ値で初期化\n\tfor _, v := range values {\n\t\tsum += v // + 演算子が使えることが保証される\n\t}\n\treturn sum\n}\n\nfunc main() {\n\tintSlice := []int{1, 2, 3}\n\tfloatSlice := []float64{1.1, 2.2}\n\n\t// T が int と推論される\n\tintSum := SumNumbers(intSlice)\n\tfmt.Printf(\"Sum(%v) = %v (%T)\\n\", intSlice, intSum, intSum)\n\n\t// T が float64 と推論される\n\tfloatSum := SumNumbers(floatSlice)\n\tfmt.Printf(\"Sum(%v) = %v (%T)\\n\", floatSlice, floatSum, floatSum)\n\n\t// SumNumbers([]string{\"a\"}) // エラー: string は Number 制約を満たさない\n}",
        "tags": [
          "interfaces",
          "interface",
          "ジェネリクス",
          "generics",
          "型パラメータ",
          "型制約",
          "constraint",
          "関数"
        ]
      },
      {
        "title": "インターフェース: ジェネリクスのメソッド制約",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// 制約インターフェース: String() メソッドを持つ\ntype Stringer interface {\n\tString() string\n}\n\n// ジェネリック関数: Stringer 制約を持つ T のスライスを連結\nfunc JoinToStrings[T Stringer](values []T, sep string) string {\n\tvar builder strings.Builder\n\tfor i, v := range values {\n\t\tif i > 0 { builder.WriteString(sep) }\n\t\tbuilder.WriteString(v.String()) // v は String() を持つことが保証される\n\t}\n\treturn builder.String()\n}\n\n// Stringer を実装する型 (例)\ntype MyInt int\nfunc (i MyInt) String() string { return \"MyInt:\" + strconv.Itoa(int(i)) }\n\nfunc main() {\n\tmyInts := []MyInt{1, 2, 3}\n\n\t// ジェネリック関数呼び出し (T は MyInt と推論される)\n\tresult := JoinToStrings(myInts, \", \")\n\tfmt.Println(result) // MyInt:1, MyInt:2, MyInt:3\n\n\t// plainInts := []int{4, 5}\n\t// JoinToStrings(plainInts, \"-\") // エラー: int は Stringer ではない\n}",
        "tags": [
          "interfaces",
          "interface",
          "ジェネリクス",
          "generics",
          "型パラメータ",
          "型制約",
          "constraint",
          "メソッドセット"
        ]
      },
      {
        "title": "インターフェース: ジェネリックデータ構造",
        "description": "ジェネリクスは関数だけでなく、**データ構造**\n(構造体やインターフェース) にも適用でき、\n型安全で汎用的なコンテナ等を作成できます。\n\n**ジェネリック型の定義:**\n型名の直後に `[]` で型パラメータと制約を指定します。",
        "code": "package main\n\nimport \"fmt\"\n\n// ジェネリック型 Stack[T any]: 任意の型 T のスタック\ntype Stack[T any] struct {\n\titems []T\n}\n\n// Push メソッド (レシーバにも型パラメータ [T] が必要)\nfunc (s *Stack[T]) Push(item T) {\n\tif s == nil { return }\n\ts.items = append(s.items, item)\n}\n\n// Pop メソッド\nfunc (s *Stack[T]) Pop() (T, bool) {\n\tif s == nil || len(s.items) == 0 {\n\t\tvar zero T // T のゼロ値を返す\n\t\treturn zero, false\n\t}\n\tlastIndex := len(s.items) - 1\n\titem := s.items[lastIndex]\n\ts.items = s.items[:lastIndex]\n\treturn item, true\n}\n\nfunc main() {\n\t// int 型のスタックをインスタンス化\n\tintStack := Stack[int]{}\n\n\tintStack.Push(10)\n\tintStack.Push(20)\n\tfmt.Printf(\"Push 後 Size: %d\\n\", len(intStack.items)) // (Size() メソッドは省略)\n\n\tval, ok := intStack.Pop()\n\tif ok { fmt.Printf(\"Pop: %d\\n\", val) } // 20\n}",
        "tags": [
          "interfaces",
          "interface",
          "ジェネリクス",
          "generics",
          "型パラメータ",
          "型制約",
          "constraint",
          "構造体",
          "データ構造"
        ]
      }
    ]
  },
  {
    "title": "Packages",
    "codeExamples": [
      {
        "title": "パッケージ: コードの構成単位 `package` 宣言",
        "description": "",
        "code": "// ファイルの先頭で package main を宣言\npackage main\n\nimport \"fmt\"\n// import \"myutils\" // 他のパッケージもインポート可\n\n// main 関数 (プログラムのエントリーポイント)\nfunc main() {\n\tfmt.Println(\"This is the main package.\")\n\t// msg := myutils.GetMessage() // ライブラリ関数呼び出し例\n\t// fmt.Println(msg)\n}\n\n// このファイルは go run や go build で実行可能",
        "tags": [
          "packages",
          "package",
          "main"
        ]
      },
      {
        "title": "パッケージ: エクスポートされる識別子 vs エクスポートされない識別子",
        "description": "",
        "code": "// calculator パッケージ\npackage calculator\n\nimport \"fmt\"\n\n// 公開される定数 (大文字始まり)\nconst MaxValue = 1000\n\n// 公開される関数\nfunc Add(a, b int) int {\n\tlogOperation(\"Add\", a, b) // 非公開関数を呼ぶ\n\treturn a + b\n}\n\n// 公開される構造体\ntype Result struct {\n\tOperation string // 公開フィールド\n\tValue     int    // 公開フィールド\n\tcomment   string // 非公開フィールド\n}\n\n// 非公開の関数 (小文字始まり)\nfunc logOperation(opName string, a, b int) {\n\tfmt.Printf(\"  [internal log] %s(%d, %d)\\n\", opName, a, b)\n}\n\n// 公開される関数 (非公開フィールドを扱う)\nfunc NewResult(op string, val int) *Result {\n\treturn &Result{\n\t\tOperation: op,\n\t\tValue:     val,\n\t\tcomment:   \"完了\", // パッケージ内から非公開フィールドにアクセス\n\t}\n}\n\n// (main パッケージからの呼び出し例は解説参照)",
        "tags": [
          "packages",
          "package",
          "エクスポート",
          "公開",
          "非公開",
          "命名規則",
          "大文字",
          "小文字"
        ]
      },
      {
        "title": "パッケージ: ドキュメンテーションコメント",
        "description": "Goではコードに**ドキュメンテーションコメント**を記述することが\n強く推奨されます。`godoc` コマンド等で整形され、\nパッケージ利用者の助けになります。\n\n**パッケージコメント:**\nパッケージ全体の概要説明。\n**`package` 宣言の直前**に `//` で記述します。\n通常 `// Package パッケージ名 ...` で始めます。",
        "code": "// Package mypackage は、文字列操作ユーティリティを提供します。(パッケージコメント例)\npackage mypackage\n\nimport (\n\t\"fmt\"\n\t\"unicode/utf8\"\n)\n\n// DefaultSeparator はデフォルトの区切り文字を表します。\nconst DefaultSeparator = \",\"\n\n// ErrorCount は処理中に発生したエラーの数を記録します。\nvar ErrorCount int\n\n// Processor は文字列を処理するインターフェースです。\ntype Processor interface {\n\tProcess(s string) (string, error)\n}\n\n// Reverse は与えられた文字列を逆順にして返します。\n// マルチバイト文字にも対応しています。\nfunc Reverse(s string) string {\n\trunes := []rune(s)\n\tn := len(runes)\n\tfor i := 0; i < n/2; i++ {\n\t\trunes[i], runes[n-1-i] = runes[n-1-i], runes[i]\n\t}\n\treturn string(runes)\n}\n\n// CountRunes は文字列の文字数 (Rune の数) を返します。\nfunc CountRunes(s string) int {\n\treturn countRunesInternal(s) // 非公開関数を呼ぶ\n}\n\n// countRunesInternal は非公開関数 (コメントは必須ではない)\nfunc countRunesInternal(s string) int {\n\treturn utf8.RuneCountInString(s)\n}",
        "tags": [
          "packages",
          "package",
          "ドキュメント",
          "コメント",
          "godoc"
        ]
      },
      {
        "title": "\"パッケージ: 単一および複数のインポート\"",
        "description": "Goのプログラムで他のパッケージの機能を利用するには `import` 文を使います。パッケージを一つだけインポートする場合と、複数まとめてインポートする場合があります。\n\nこれらの基本的な使い方については、**「基本」**セクションの**「パッケージのインポート `import`」** (`000_basics/160_import-statements.md`) を参照してください。\n\n**基本的な構文:**\n\n*   **単一インポート:**",
        "code": "import \"fmt\"",
        "tags": [
          "packages",
          "package",
          "import"
        ]
      },
      {
        "title": "パッケージ: インポート時のエイリアス (別名)",
        "description": "",
        "code": "package main\n\n// fmt パッケージを f というエイリアスでインポート\nimport f \"fmt\"\nimport \"strings\" // 比較用\n\nfunc main() {\n\t// エイリアス f を使って fmt の関数を呼び出す\n\tf.Println(\"エイリアスを使って出力\")\n\n\ts := strings.ToUpper(\"hello\")\n\tf.Println(s) // ここでも f を使う\n}",
        "tags": [
          "packages",
          "package",
          "import",
          "エイリアス"
        ]
      },
      {
        "title": "パッケージ: ドットインポート (`.`) - 非推奨",
        "description": "",
        "code": "package main\n\n// fmt と math をドットインポート (非推奨)\nimport (\n\t. \"fmt\"\n\t. \"math\"\n)\n\nfunc main() {\n\t// fmt.Println ではなく Println で呼び出せる\n\t// しかし、これが fmt.Println なのか、\n\t// main パッケージの Println なのか不明瞭になる\n\tPrintln(\"Hello\") // fmt.Println が呼ばれる\n\n\t// math.Pi ではなく Pi で参照できる\n\tPrintf(\"円周率: %f\\n\", Pi) // fmt.Printf も同様\n\n\t// math.Sqrt ではなく Sqrt で参照できる\n\tPrintf(\"平方根: %f\\n\", Sqrt(2))\n\n\t// もし main にも Pi があったら衝突する\n\t// var Pi = 999 // エラーになる可能性\n}",
        "tags": [
          "packages",
          "package",
          "import",
          "ドットインポート",
          "非推奨",
          "可読性"
        ]
      },
      {
        "title": "パッケージ: ブランクインポート (`_`) と副作用",
        "description": "`import` 文でエイリアスとして**ブランク識別子 (`_`)** を使う\n特殊な形式を**ブランクインポート**と呼びます。\n\n**構文:** `import _ \"パッケージパス\"`\n\n**動作と目的:**\nブランクインポートされたパッケージの**識別子は参照できません**。\n主な目的は、パッケージインポートによる**副作用**、\n特にパッケージ内の **`init` 関数の実行**を利用することです。\n`init` 関数はパッケージ初期化時に自動実行されます。\n\nつまり、パッケージの関数などを直接使わないが、\nそのパッケージが初期化時に行う処理（登録処理など）だけを\n実行させたい場合にブランクインポートを使います。\n\n**一般的な使用例:**\n1.  **データベースドライバ登録:**",
        "code": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"image\"\n\t// ★ PNG フォーマットを扱えるようにブランクインポート\n\t// この行がないと image.Decode は PNG を認識できない\n\t_ \"image/png\"\n\t\"os\"\n)\n\n// 簡単な PNG データ (1x1 透明ピクセル)\nvar pngData = []byte{ /* ... (バイトデータは省略) ... */\n\t0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d,\n\t0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,\n\t0x08, 0x06, 0x00, 0x00, 0x00, 0x1f, 0x15, 0xc4, 0x89, 0x00, 0x00, 0x00,\n\t0x0a, 0x49, 0x44, 0x41, 0x54, 0x78, 0x9c, 0x63, 0x00, 0x01, 0x00, 0x00,\n\t0x05, 0x00, 0x01, 0x0d, 0x0a, 0x2d, 0xb4, 0x00, 0x00, 0x00, 0x00, 0x49,\n\t0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82,\n}\n\nfunc main() {\n\t// _ \"image/png\" がインポートされているため PNG を認識可能\n\timg, formatName, err := image.Decode(bytes.NewReader(pngData))\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"デコードエラー: %v\\n\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"フォーマット: %s, サイズ: %dx%d\\n\", formatName, img.Bounds().Dx(), img.Bounds().Dy())\n}",
        "tags": [
          "packages",
          "package",
          "import",
          "ブランクインポート",
          "_",
          "副作用",
          "init"
        ]
      },
      {
        "title": "パッケージ: インポートパスと Go Modules",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t// 正しいインポートパス (モジュールパスからの絶対パス)\n\t\"mycompany.com/myproject/internal/helper\"\n\n\t// 間違ったインポートパス (相対パスは不可)\n\t// \"./internal/helper\"\n\t// \"../myproject/internal/helper\"\n)\n\nfunc main() {\n\tfmt.Println(\"Main started.\")\n\tmessage := helper.GetHelperMessage() // 正しくインポートされた関数を呼び出す\n\tfmt.Println(message)\n}\n\n// --- internal/helper/helper.go ---\n// package helper\n// func GetHelperMessage() string { return \"Helper message\" }\n\n// --- go.mod ---\n// module mycompany.com/myproject\n// go 1.20",
        "tags": [
          "packages",
          "package",
          "import",
          "go modules",
          "モジュールパス",
          "相対パス"
        ]
      },
      {
        "title": "パッケージ: パッケージ変数 (Package Variables)",
        "description": "",
        "code": "// config パッケージ (例)\npackage config\n\nimport \"fmt\"\n\n// --- パッケージ変数 ---\n\n// 公開されるパッケージ変数\nvar DefaultPort int = 8080\n\n// 非公開パッケージ変数\nvar apiKey string = \"initial-key\"\nvar accessCount int // ゼロ値 0\n\n// --- 関数 ---\n\n// 非公開 apiKey を取得する公開関数\nfunc GetAPIKey() string {\n\taccessCount++\n\tfmt.Printf(\"  (GetAPIKey: アクセス %d 回目)\\n\", accessCount)\n\treturn apiKey\n}\n\n// 非公開 apiKey を設定する公開関数\nfunc SetAPIKey(newKey string) {\n\tfmt.Printf(\"  (SetAPIKey: '%s' に変更)\\n\", newKey)\n\tapiKey = newKey\n}\n\n// アクセスカウントを取得する公開関数\nfunc GetAccessCount() int {\n\treturn accessCount\n}\n\n// --- main パッケージからの利用例 (解説参照) ---\n// import \"myproject/config\"\n// func main() {\n//     fmt.Println(config.DefaultPort) // OK\n//     key := config.GetAPIKey()      // OK\n//     config.SetAPIKey(\"new\")      // OK\n//     // fmt.Println(config.apiKey) // エラー (非公開)\n// }",
        "tags": [
          "packages",
          "package",
          "変数",
          "var",
          "スコープ",
          "グローバル変数",
          "副作用"
        ]
      },
      {
        "title": "パッケージ: 初期化関数 `init()`",
        "description": "",
        "code": "// --- パッケージ a (例: a/a.go) ---\npackage a\n\nimport \"fmt\"\n\nvar VarA = \"Var A initialized\"\n\nfunc init() {\n\tfmt.Println(\"Package a: init()\")\n\tVarA = \"Var A modified in init\"\n}\nfunc FuncA() { fmt.Println(\"Package a: FuncA()\") }\n\n// --- main パッケージ (例: main.go) ---\npackage main\n\nimport (\n\t\"fmt\"\n\t\"myproject/a\" // パスは例\n)\n\nvar VarMain = \"Var Main initialized\"\n\nfunc init() {\n\tfmt.Println(\"Package main: init()\")\n}\n\nfunc main() {\n\tfmt.Println(\"--- main() started ---\")\n\tfmt.Println(\"main: VarA:\", a.VarA) // a の init() 実行後の値\n\ta.FuncA()\n\tfmt.Println(\"main: VarMain:\", VarMain)\n\tfmt.Println(\"--- main() finished ---\")\n}\n\n/* 実行結果 (おおよその順序):\nPackage a: init()\nPackage main: init()\n--- main() started ---\nmain: VarA: Var A modified in init\nPackage a: FuncA()\nmain: VarMain: Var Main initialized\n--- main() finished ---\n*/",
        "tags": [
          "packages",
          "package",
          "init",
          "初期化",
          "副作用"
        ]
      },
      {
        "title": "パッケージ: 複数の `init()` 関数",
        "description": "",
        "code": "// --- パッケージ mypkg (例: mypkg/a.go) ---\npackage mypkg\nimport \"fmt\"\nfunc init() { fmt.Println(\"mypkg/a.go: init()\") }\nfunc FuncA() { fmt.Println(\"mypkg/a.go: FuncA()\") }\n\n// --- パッケージ mypkg (例: mypkg/b.go) ---\n// (同じパッケージ内に別のファイル)\npackage mypkg\nimport \"fmt\"\nvar VarB = initializeVarB() // 変数初期化は init より先\nfunc initializeVarB() string { fmt.Println(\"mypkg/b.go: VarB init\"); return \"VarB\" }\nfunc init() { fmt.Println(\"mypkg/b.go: init()\") }\nfunc FuncB() { fmt.Println(\"mypkg/b.go: FuncB()\") }\n\n// --- main パッケージ (例: main.go) ---\npackage main\nimport (\n\t\"fmt\"\n\t\"myproject/mypkg\" // パスは例\n)\nfunc main() {\n\tfmt.Println(\"main() 開始\")\n\tmypkg.FuncA()\n\tmypkg.FuncB()\n\tfmt.Println(\"main() 終了\")\n}\n\n/* 実行結果例 (mypkg 内の init 順序は不定):\nmypkg/b.go: VarB init\nmypkg/a.go: init()\nmypkg/b.go: init()\nmain() 開始\nmypkg/a.go: FuncA()\nmypkg/b.go: FuncB()\nmain() 終了\n*/",
        "tags": [
          "packages",
          "package",
          "init",
          "初期化",
          "実行順序"
        ]
      },
      {
        "title": "パッケージ: Go Modules によるプロジェクト初期化 (`go mod init`)",
        "description": "現在のGo開発では **Go Modules** で依存関係を管理します。\n新しいプロジェクト開始時には Go Modules の初期化が必要です。\n\n**Go Modules とは？**\n*   Go プロジェクトの依存関係管理システム。\n*   プロジェクトごとに利用する外部パッケージのバージョンを記録。\n*   プロジェクトルートの `go.mod` ファイルで管理。\n*   Go 1.16 以降デフォルトで有効。\n\n**プロジェクト初期化: `go mod init`**\nプロジェクトのルートディレクトリでコマンドを実行します。\n**コマンド:** `go mod init モジュールパス`\n\n*   `モジュールパス`: プロジェクトを識別する**一意な名前**。\n    これがプロジェクト内パッケージのインポート基準パスになる。\n    通常はリポジトリパス (`github.com/user/repo`) や\n    組織ドメイン (`mycompany.com/service`) を使う。\n    **他と衝突しない一意なパス**が重要。\n\n実行すると、コード例のような `go.mod` ファイルが生成されます。\n*   `module`: 設定したモジュールパス。\n*   `go`: 使用する Go のバージョン。\n\nこの後、コード (`main.go` など) を記述し、\n`go run` や `go build` で実行します。\n外部パッケージを `import` してビルド等を行うと、\nGo Modules が自動で依存関係を `go.mod` に追加・管理します\n(`go get` で明示的追加も可)。\n\n`go mod init` は Go Modules 開発の最初のステップです。\n\n**参考コード (Bash & go.mod):**",
        "code": "// 4. main.go などを作成して開発開始\npackage main\nimport \"fmt\"\nfunc main() { fmt.Println(\"Hello Modules!\") }\n\n// 5. go run main.go や go build で実行",
        "tags": [
          "packages",
          "package",
          "go modules",
          "go mod init",
          "モジュールパス",
          "依存関係管理"
        ]
      },
      {
        "title": "パッケージ: `go.mod` ファイルの構造 (Go Modules)",
        "description": "Go Modules の中心がプロジェクトルートの **`go.mod`** ファイルです。\nモジュールの定義、Goバージョン、依存関係などを記述します。\n通常は `go mod init` で生成され、`go get` 等で自動更新されます。\n\n**主要なディレクティブ:**\n*   **`module` (必須):** モジュールパスを定義。\n    例: `module github.com/user/repo`\n    これがインポートパスの基準になります。\n*   **`go` (必須):** 期待する Go の最小バージョンを指定。\n    例: `go 1.21`\n*   **`require`:** 直接依存するモジュールとバージョンを指定。\n    `go get` 等で自動管理されます。\n    `// indirect` は間接的な依存を示します。",
        "code": ".mod\n// モジュールパス (必須、通常はリポジトリパス)\nmodule example.com/mymodule\n\n// Go の最小バージョン (必須)\ngo 1.20\n\n// 依存モジュールとそのバージョン (go get などで自動管理)\nrequire (\n\tgithub.com/google/uuid v1.3.0\n\tgolang.org/x/exp v0.0.0-20230310184433-ae3f4189d583\n\tgopkg.in/yaml.v2 v2.4.0 // indirect (間接的な依存)\n)\n\n// 特定バージョンの除外 (オプション)\nexclude github.com/unstable/dependency v0.5.1\n\n// 依存の置き換え (オプション、ローカル開発などで使用)\nreplace example.com/mylibrary => ../mylibrary\n\n// 公開済みバージョンの取り消し (オプション、モジュール作者が使用)\nretract (\n\tv0.1.0 // バグがあったバージョンなど\n\t[v0.1.5, v0.1.9]\n)",
        "tags": [
          "packages",
          "package",
          "go modules",
          "go.mod",
          "依存関係管理",
          "module",
          "go",
          "require",
          "replace",
          "exclude",
          "retract"
        ]
      },
      {
        "title": "パッケージ: 依存関係の管理 (Go Modules コマンド)",
        "description": "Go Modules は `go` コマンドで依存関係を管理します。\n\n**依存関係の追加・更新: `go get`**\n依存関係を追加・更新します。`go.mod` が更新されます。\n*   `go get <パッケージパス>`: 最新安定版を追加/更新。\n*   `go get <パッケージパス>@<バージョン>`: 特定バージョンを指定\n    (例: `v1.3.0`, コミットハッシュ, `latest`)。\n*   `go get -u ./...` または `go get -u`:\n    全ての依存関係を互換性のある最新版に更新。\n*   `go get <パッケージパス>@none`: 依存関係を削除\n    (通常は `go mod tidy` を推奨)。\n\n**依存関係の整理: `go mod tidy`**\nコードを分析し `go.mod` を整理します。\n*   コード内で `import` されているが `go.mod` にない依存を追加。\n*   `go.mod` にあるがコード内で使われていない依存を削除。\nコード変更後や依存を手動編集した後に実行すると良いです。\n\n**依存関係のベンダー化: `go mod vendor`**\n依存パッケージのソースコードをプロジェクト内の\n`vendor/` ディレクトリにコピーします。\nオフラインビルドや依存コードの同梱管理に使われます。\n`vendor/` があると `go build` は通常ここを使います。\n\n**依存関係の調査:**\n*   `go mod why <パッケージパス>`: なぜそのパッケージが必要か表示。\n*   `go list -m all`: 全ての依存関係リストを表示。\n*   `go list -m -json <パッケージパス>`: 詳細情報を JSON で表示。\n\nこれらのコマンドで Go Modules の依存関係を管理します。\n\n**参考コマンド (Bash):**",
        "code": "// このセクションにはGoのコード例はありません。\n// 依存関係管理コマンドはターミナル (bashなど) で実行します。",
        "tags": [
          "packages",
          "package",
          "go modules",
          "依存関係管理",
          "go get",
          "go mod tidy",
          "go mod vendor",
          "go mod why",
          "go list"
        ]
      },
      {
        "title": "標準ライブラリ: `fmt` パッケージ (フォーマット付き I/O)",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\ntype Point struct{ X, Y int }\n\nfunc main() {\n\tname := \"Gopher\"\n\tage := 13\n\tpi := 3.14159\n\tp := Point{10, 20}\n\n\t// Println: 引数をスペース区切りで出力し、最後に改行\n\tfmt.Println(\"--- Println ---\")\n\tfmt.Println(\"Hello,\", name, \"Age:\", age)\n\n\t// Printf: 書式指定文字列に従って出力 (改行なし)\n\tfmt.Println(\"\\n--- Printf ---\")\n\tfmt.Printf(\"Name: %s, Age: %d\\n\", name, age)\n\tfmt.Printf(\"Pi (approx): %.2f\\n\", pi)       // 小数点以下2桁\n\tfmt.Printf(\"Point: %v, Type: %T\\n\", p, p)   // デフォルト形式と型\n\n\t// Sprintf: フォーマット結果を文字列として返す\n\tfmt.Println(\"\\n--- Sprintf ---\")\n\tmessage := fmt.Sprintf(\"User: %s (ID: %d)\", name, 1)\n\tfmt.Println(message)\n}",
        "tags": [
          "packages",
          "standard library",
          "fmt",
          "Println",
          "Printf",
          "Sprintf",
          "フォーマット",
          "入出力"
        ]
      },
      {
        "title": "標準ライブラリ: `io` / `os` パッケージ (基本的な入出力とOS機能)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\nfunc main() {\n\tfileName := \"example.txt\"\n\n\t// --- ファイル書き込み ---\n\twriteFile, err := os.Create(fileName) // ファイル作成/オープン\n\tif err != nil { /* エラー処理 */ return }\n\tdefer writeFile.Close() // ★ 関数終了時に必ず閉じる\n\n\t_, err = io.WriteString(writeFile, \"ファイル書き込みテスト。\\n\")\n\tif err != nil { /* エラー処理 */ return }\n\tfmt.Printf(\"'%s' に書き込み完了\\n\", fileName)\n\n\t// --- ファイル読み込み ---\n\treadFile, err := os.Open(fileName) // ファイルを開く\n\tif err != nil { /* エラー処理 */ return }\n\tdefer readFile.Close() // ★ 関数終了時に必ず閉じる\n\n\tcontent, err := io.ReadAll(readFile) // 全内容読み込み\n\tif err != nil { /* エラー処理 */ return }\n\tfmt.Printf(\"'%s' の内容:\\n%s\", fileName, string(content))\n\n\tos.Remove(fileName) // 後片付け\n}",
        "tags": [
          "packages",
          "standard library",
          "io",
          "os",
          "ファイル操作",
          "入出力",
          "Reader",
          "Writer",
          "defer"
        ]
      },
      {
        "title": "標準ライブラリ: `strings` パッケージ (文字列操作)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\" // strings パッケージ\n)\n\nfunc main() {\n\ts := \" Hello, World! Go is fun! \"\n\tfmt.Printf(\"元: \\\"%s\\\"\\n\", s)\n\n\t// 検索・判定\n\tfmt.Println(\"Contains(\\\"Go\\\"):\", strings.Contains(s, \"Go\")) // true\n\t// fmt.Println(\"HasPrefix:\", strings.HasPrefix(s, \" Hello\")) // true\n\t// fmt.Println(\"Index:\", strings.Index(s, \"Go\")) // 15\n\n\t// 分割・結合\n\tcsv := \"a,b,c\"\n\tparts := strings.Split(csv, \",\")\n\tfmt.Printf(\"Split: %q\\n\", parts) // [\"a\" \"b\" \"c\"]\n\tjoined := strings.Join(parts, \"-\")\n\tfmt.Printf(\"Join: \\\"%s\\\"\\n\", joined) // \"a-b-c\"\n\n\t// 変換・トリム\n\tfmt.Println(\"ToLower:\", strings.ToLower(s))\n\tfmt.Println(\"ToUpper:\", strings.ToUpper(s))\n\tfmt.Println(\"TrimSpace:\", strings.TrimSpace(s))\n\n\t// 置換\n\tfmt.Println(\"Replace:\", strings.Replace(s, \" \", \"_\", -1)) // 全置換\n}",
        "tags": [
          "packages",
          "standard library",
          "strings",
          "文字列操作",
          "Contains",
          "HasPrefix",
          "Index",
          "Join",
          "Split",
          "ToLower",
          "ToUpper",
          "TrimSpace"
        ]
      },
      {
        "title": "標準ライブラリ: `time` パッケージ (時間と日付)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\t// 現在時刻\n\tnow := time.Now()\n\tfmt.Println(\"Now:\", now)\n\n\t// フォーマット (Go独自レイアウト: 2006-01-02 15:04:05)\n\tformatted := now.Format(\"2006-01-02 15:04:05\")\n\tfmt.Println(\"Formatted:\", formatted)\n\n\t// 解析 (文字列 -> time.Time)\n\tlayout := \"2006-01-02\"\n\tparsed, _ := time.Parse(layout, \"2023-10-27\")\n\tfmt.Println(\"Parsed:\", parsed)\n\n\t// 時間の加算・差\n\toneHourLater := now.Add(1 * time.Hour)\n\tdiff := oneHourLater.Sub(now)\n\tfmt.Printf(\"1 hour later: %v, Diff: %v\\n\", oneHourLater, diff)\n\n\t// スリープ\n\tfmt.Println(\"Sleeping 1 sec...\")\n\tstart := time.Now()\n\ttime.Sleep(1 * time.Second)\n\n\t// 経過時間\n\telapsed := time.Since(start)\n\tfmt.Printf(\"Elapsed: %v\\n\", elapsed)\n}",
        "tags": [
          "packages",
          "standard library",
          "time",
          "日付",
          "時刻",
          "Duration",
          "Format",
          "Parse",
          "Sleep",
          "Since"
        ]
      },
      {
        "title": "標準ライブラリ: `encoding/json` パッケージ (JSONの処理)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n)\n\ntype Person struct {\n\tName string `json:\"name\"`            // JSONキーは \"name\"\n\tAge  int    `json:\"age,omitempty\"` // キーは \"age\", ゼロ値なら省略\n\tCity string `json:\"city\"`\n\t// secret string `json:\"-\"` // JSONに含めない\n}\n\nfunc main() {\n\t// 構造体を JSON にマーシャリング\n\tp1 := Person{Name: \"Alice\", Age: 30, City: \"New York\"}\n\tp2 := Person{Name: \"Bob\", City: \"London\"} // Age=0 なので省略される\n\n\tjsonData1, err := json.Marshal(p1)\n\tif err != nil { log.Fatal(err) }\n\tfmt.Printf(\"p1 JSON: %s\\n\", jsonData1) // {\"name\":\"Alice\",\"age\":30,\"city\":\"New York\"}\n\n\tjsonData2, err := json.Marshal(p2)\n\tif err != nil { log.Fatal(err) }\n\tfmt.Printf(\"p2 JSON: %s\\n\", jsonData2) // {\"name\":\"Bob\",\"city\":\"London\"}\n\n\t// マップを JSON にマーシャリング\n\tmapData := map[string]any{\"id\": 123, \"active\": true}\n\tjsonDataMap, err := json.Marshal(mapData)\n\tif err != nil { log.Fatal(err) }\n\tfmt.Printf(\"Map JSON: %s\\n\", jsonDataMap) // {\"active\":true,\"id\":123}\n}",
        "tags": [
          "packages",
          "standard library",
          "encoding/json",
          "json",
          "マーシャリング",
          "アンマーシャリング",
          "エンコード",
          "デコード",
          "構造体タグ"
        ]
      },
      {
        "title": "標準ライブラリ: `net/http` パッケージ (HTTPクライアント & サーバー)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\" // HTTP パッケージ\n)\n\n// ルート (\"/\") ハンドラ関数\nfunc rootHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.URL.Path != \"/\" {\n\t\thttp.NotFound(w, r)\n\t\treturn\n\t}\n\tfmt.Fprint(w, \"Welcome!\") // レスポンス書き込み\n}\n\n// /hello ハンドラ関数\nfunc helloHandler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprint(w, \"Hello!\")\n}\n\nfunc main() {\n\t// ハンドラの登録\n\thttp.HandleFunc(\"/\", rootHandler)\n\thttp.HandleFunc(\"/hello\", helloHandler)\n\n\t// サーバーの起動\n\tport := \":8080\"\n\tfmt.Printf(\"Server listening on port %s\\n\", port)\n\tlog.Fatal(http.ListenAndServe(port, nil)) // エラーなら Fatal\n}",
        "tags": [
          "packages",
          "standard library",
          "net/http",
          "http",
          "web",
          "サーバー",
          "クライアント",
          "HandleFunc",
          "ListenAndServe",
          "ResponseWriter",
          "Request",
          "Get",
          "Post"
        ]
      },
      {
        "title": "パッケージ: `internal` パッケージによる内部実装の隠蔽",
        "description": "Go 1.4 から導入された **`internal`** ディレクトリは、\nパッケージの可視性を制御する特別な仕組みです。\n`internal` 以下に置かれたパッケージはインポート可能な範囲が\nコンパイラによって制限されます。\n\n**ルール:**\n`internal` ディレクトリ、またはそのサブディレクトリ内のパッケージは、\nその `internal` ディレクトリの**直上の親ディレクトリ**を\nルートとするサブツリー内のコードから**のみ**インポートできます。\nそれ以外の場所（別のプロジェクトや、親の外のディレクトリ）からは\nインポートできず、コンパイルエラーになります。\n\n**例:**",
        "code": "// --- internal/config/config.go ---\npackage config\n\n// internal 以下にあるパッケージ\n\n// Load は設定をロードする (エクスポートされている)\nfunc Load() string {\n\treturn \"Loaded Config from internal/config\"\n}\n\n// --- cmd/myapp/main.go (internal の親のサブツリー内) ---\npackage main\n\nimport (\n\t\"example.com/myproject/internal/config\" // OK: インポート可\n\t\"fmt\"\n)\n\nfunc main() {\n\tcfg := config.Load() // internal の関数を呼び出し\n\tfmt.Println(cfg)\n}\n\n// --- anotherproject/main.go (外部プロジェクト) ---\n/*\npackage main\n\nimport (\n\t\"fmt\"\n\t// \"example.com/myproject/internal/config\" // コンパイルエラー!\n)\n\nfunc main() {\n\t// cfg := config.Load() // エラー\n\tfmt.Println(\"Cannot import internal package\")\n}\n// エラー例: use of internal package example.com/myproject/internal/config not allowed\n*/",
        "tags": [
          "packages",
          "package",
          "internal",
          "可視性",
          "カプセル化",
          "依存関係"
        ]
      }
    ]
  },
  {
    "title": "Error Handling",
    "codeExamples": [
      {
        "title": "エラー処理: `error` インターフェース",
        "description": "Goには `try-catch` のような例外処理はなく、\n**エラーを通常の戻り値として**扱います。\nエラー発生可能性のある関数は `error` 型の値を返します。\n\n**`error` インターフェース:**\nGoのエラー処理の中心となる組み込みインターフェースです。",
        "code": "package main\n\nimport \"fmt\"\n\n// 独自のエラー型\ntype MyError struct {\n\tOperation string\n\tCode      int\n\tMessage   string\n}\n\n// Error() メソッドを実装し、error インターフェースを満たす\nfunc (e *MyError) Error() string {\n\treturn fmt.Sprintf(\"Op:'%s' Code:%d Msg:'%s'\", e.Operation, e.Code, e.Message)\n}\n\n// エラーを返す可能性のある関数\nfunc performOperation(fail bool) error { // 戻り値は error\n\tif fail {\n\t\t// *MyError は error を満たすので返せる\n\t\treturn &MyError{\"データ処理\", 500, \"内部エラー\"}\n\t}\n\treturn nil // 成功時は nil を返す\n}\n\nfunc main() {\n\t// 成功ケース\n\terr1 := performOperation(false)\n\tif err1 != nil {\n\t\tfmt.Println(\"エラー:\", err1.Error()) // Error() でメッセージ取得\n\t} else {\n\t\tfmt.Println(\"成功\")\n\t}\n\n\t// 失敗ケース\n\terr2 := performOperation(true)\n\tif err2 != nil {\n\t\tfmt.Println(\"エラー:\", err2.Error()) // 実装した Error() が呼ばれる\n\t\tfmt.Printf(\"エラーの型: %T\\n\", err2) // *main.MyError\n\t} else {\n\t\tfmt.Println(\"成功\")\n\t}\n}",
        "tags": [
          "error-handling",
          "error",
          "interface",
          "エラー",
          "Error()"
        ]
      },
      {
        "title": "エラー処理: 簡単なエラーの作成 `errors.New`",
        "description": "",
        "code": "package main\n\nimport (\n\t\"errors\" // errors パッケージ\n\t\"fmt\"\n)\n\n// 失敗したら errors.New でエラーを返す関数\nfunc checkValue(value int) error {\n\tif value < 0 {\n\t\treturn errors.New(\"値が負数です\") // エラーメッセージを指定\n\t}\n\t// 成功時は nil\n\treturn nil\n}\n\nfunc main() {\n\t// 成功ケース\n\terr1 := checkValue(10)\n\tif err1 == nil {\n\t\tfmt.Println(\"checkValue(10): 成功\")\n\t}\n\n\t// 失敗ケース\n\terr2 := checkValue(-5)\n\tif err2 != nil {\n\t\tfmt.Println(\"エラー:\", err2) // err2.Error() と同じ\n\t\tfmt.Printf(\"エラー型: %T\\n\", err2) // *errors.errorString\n\t}\n}",
        "tags": [
          "error-handling",
          "error",
          "errors",
          "errors.New"
        ]
      },
      {
        "title": "エラー処理: フォーマットされたエラーの作成 `fmt.Errorf`",
        "description": "",
        "code": "package main\n\nimport (\n\t\"errors\" // errors.Is を使う\n\t\"fmt\"\n\t\"os\"\n)\n\n// ファイルを開く処理をラップし、エラー時に %w を使う関数\nfunc openFileWrapped(filename string) error {\n\tfile, err := os.Open(filename)\n\tif err != nil {\n\t\t// %w で元のエラー err をラップする\n\t\treturn fmt.Errorf(\"ファイル '%s' オープン失敗: %w\", filename, err)\n\t}\n\tfile.Close()\n\treturn nil\n}\n\nfunc main() {\n\terr := openFileWrapped(\"non_existent.txt\")\n\tif err != nil {\n\t\tfmt.Println(\"エラー:\", err) // ラップされたメッセージ\n\n\t\t// errors.Is でラップされたエラーを確認できる\n\t\tif errors.Is(err, os.ErrNotExist) {\n\t\t\tfmt.Println(\"-> 原因: ファイルが存在しない\")\n\t\t}\n\t}\n}",
        "tags": [
          "error-handling",
          "error",
          "fmt",
          "fmt.Errorf",
          "エラーラッピング",
          "%w"
        ]
      },
      {
        "title": "エラー処理: エラーを返す関数",
        "description": "",
        "code": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\n// ゼロ除算をチェックし、エラーを返す関数\nfunc divide(a, b int) (int, error) { // 戻り値に error を含める\n\tif b == 0 {\n\t\t// 失敗: ゼロ値とエラーを返す\n\t\treturn 0, errors.New(\"ゼロによる除算\")\n\t}\n\t// 成功: 結果と nil を返す\n\treturn a / b, nil\n}\n\nfunc main() {\n\t// 呼び出し側でエラーをチェック\n\tresult1, err1 := divide(10, 2)\n\tif err1 != nil {\n\t\tfmt.Println(\"エラー:\", err1)\n\t} else {\n\t\tfmt.Println(\"10 / 2 =\", result1)\n\t}\n\n\tresult2, err2 := divide(10, 0)\n\tif err2 != nil {\n\t\tfmt.Println(\"エラー:\", err2) // エラー発生\n\t} else {\n\t\tfmt.Println(\"10 / 0 =\", result2)\n\t}\n}",
        "tags": [
          "error-handling",
          "error",
          "functions",
          "return",
          "nil"
        ]
      },
      {
        "title": "エラー処理: 基本的なエラーハンドリング (`if err != nil`)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"strconv\"\n)\n\n// 文字列を整数に変換。失敗したらエラーをラップして返す。\nfunc parseAndDescribe(s string) (string, error) {\n\tvalue, err := strconv.Atoi(s)\n\tif err != nil {\n\t\t// ★ エラーチェックと早期リターン\n\t\treturn \"\", fmt.Errorf(\"変換失敗 '%s': %w\", s, err)\n\t}\n\n\t// --- 正常系の処理 ---\n\tdesc := fmt.Sprintf(\"数値 %d は\", value)\n\tif value%2 == 0 { desc += \"偶数\" } else { desc += \"奇数\" }\n\treturn desc, nil // 成功時は nil を返す\n}\n\nfunc main() {\n\tinputs := []string{\"123\", \"abc\", \"-4\"}\n\tfor _, input := range inputs {\n\t\tfmt.Printf(\"入力 '%s':\\n\", input)\n\t\tdesc, err := parseAndDescribe(input)\n\n\t\t// ★ 呼び出し側でのエラーチェック\n\t\tif err != nil {\n\t\t\tlog.Printf(\"  エラー: %v\\n\", err)\n\t\t\tcontinue // エラーなら次の入力へ\n\t\t}\n\n\t\t// --- 正常系の処理 ---\n\t\tfmt.Printf(\"  -> 結果: %s\\n\", desc)\n\t}\n}",
        "tags": [
          "error-handling",
          "error",
          "if",
          "nil",
          "早期リターン"
        ]
      },
      {
        "title": "エラー処理: エラーラッピング (`%w`)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n)\n\n// 下位の処理 (エラーを返す可能性)\nfunc openDataFile(filename string) (*os.File, error) {\n\treturn os.Open(filename) // 元のエラーを返す\n}\n\n// 上位の処理 (エラーをラップする)\nfunc processFile(filename string) error {\n\tfile, err := openDataFile(filename)\n\tif err != nil {\n\t\t// ★ %w で元のエラー err をラップする\n\t\treturn fmt.Errorf(\"ファイル処理失敗 (%s): %w\", filename, err)\n\t}\n\tdefer file.Close()\n\tfmt.Printf(\"ファイル '%s' 処理成功\\n\", filename)\n\treturn nil\n}\n\nfunc main() {\n\terr := processFile(\"non_existent.txt\")\n\tif err != nil {\n\t\tfmt.Println(\"エラー:\", err) // ラップされたメッセージ\n\n\t\t// errors.Is でラップされた根本原因をチェック\n\t\tif errors.Is(err, os.ErrNotExist) {\n\t\t\tfmt.Println(\"-> 原因: ファイルが存在しない\")\n\t\t}\n\t}\n}",
        "tags": [
          "error-handling",
          "error",
          "fmt.Errorf",
          "エラーラッピング",
          "%w",
          "errors.Is",
          "errors.As"
        ]
      },
      {
        "title": "エラー処理: エラーは値 (`errors.Is`)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\" // os.ErrNotExist\n)\n\n// センチネルエラー (パッケージレベルで定義される特定のエラー値)\nvar ErrItemNotFound = errors.New(\"アイテムが見つかりません\")\nvar ErrPermissionDenied = errors.New(\"権限がありません\")\n\n// エラーを返す関数 (センチネルエラーまたはラップされたエラー)\nfunc getItem(id int) (string, error) {\n\tif id == 1 { return \"Apple\", nil }\n\tif id == 2 { return \"\", ErrItemNotFound } // センチネルエラーを返す\n\tif id == 3 { return \"\", ErrPermissionDenied }\n\toriginalErr := errors.New(\"DB接続エラー\")\n\treturn \"\", fmt.Errorf(\"ID %d 取得失敗: %w\", id, originalErr) // ラップされたエラー\n}\n\nfunc main() {\n\tfor _, id := range []int{2, 3, 4} {\n\t\tfmt.Printf(\"\\nアイテム %d 取得:\\n\", id)\n\t\t_, err := getItem(id)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\" エラー: %v\\n\", err)\n\t\t\t// errors.Is でエラーの種類を判定\n\t\t\tif errors.Is(err, ErrItemNotFound) {\n\t\t\t\tfmt.Println(\"  -> 原因: アイテムなし\")\n\t\t\t} else if errors.Is(err, ErrPermissionDenied) {\n\t\t\t\tfmt.Println(\"  -> 原因: 権限なし\")\n\t\t\t} else {\n\t\t\t\tfmt.Println(\"  -> 原因: その他\")\n\t\t\t}\n\t\t}\n\t}\n\t// _, errOpen := os.Open(\"no.txt\")\n\t// if errors.Is(errOpen, os.ErrNotExist) { /* ... */ }\n}",
        "tags": [
          "error-handling",
          "error",
          "errors",
          "errors.Is",
          "エラーラッピング",
          "%w",
          "センチネルエラー"
        ]
      },
      {
        "title": "エラー処理: カスタムエラー型の定義",
        "description": "`errors.New` や `fmt.Errorf` では不十分な、\nより詳細なエラー情報（エラーコード、発生時刻など）を\n保持したり、エラーの種類を**型**として区別したい場合は、\n**カスタムエラー型**を定義します。\n\n通常は**構造体 (struct)** を使い、`error` インターフェースを\n満たすようにします。\n\n**定義方法:**\n1. エラー情報を保持するフィールドを持つ**構造体**を定義する。\n   (例: `OperationError` 構造体)\n2. その構造体（通常はポインタレシーバ `*MyError`）に対して\n   **`Error() string` メソッドを実装**する。\n   このメソッド内で、構造体のフィールドを使って\n   人間が読めるエラーメッセージ文字列を生成して返す。\n\nコード例では `OperationError` 構造体を定義し、\n`Error()` メソッドを実装しています。これにより\n`*OperationError` は `error` インターフェースを満たします。\n\n**(オプション) エラーラッピング:**\nGo 1.13以降、`Unwrap() error` メソッドを実装すると、\n`errors.Is` や `errors.As` がラップされたエラー (`Err` フィールド等) を\n辿れるようになります。",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\n// カスタムエラー型 (構造体)\ntype OperationError struct {\n\tTimestamp time.Time\n\tOp        string\n\tCode      int\n\tMessage   string\n\tErr       error // ラップされたエラー (オプション)\n}\n\n// Error() メソッドを実装し、error インターフェースを満たす\nfunc (e *OperationError) Error() string {\n\t// フィールドを使って詳細なメッセージを生成\n\tmsg := fmt.Sprintf(\"[%s] Op:%s Code:%d Msg:%s\",\n\t\te.Timestamp.Format(time.RFC3339), e.Op, e.Code, e.Message)\n\tif e.Err != nil {\n\t\tmsg += fmt.Sprintf(\" (Cause: %v)\", e.Err)\n\t}\n\treturn msg\n}\n\n// (Unwrap() error メソッドを実装するとエラーラッピングをサポート)\n\nfunc main() {\n\t// カスタムエラーを生成 (例)\n\terr := &OperationError{\n\t\tTimestamp: time.Now(), Op: \"Update\", Code: 501, Message: \"Failed\",\n\t}\n\n\tif err != nil {\n\t\tfmt.Println(\"エラー:\", err) // 実装した Error() が呼ばれる\n\t\tfmt.Printf(\"型: %T\\n\", err) // *main.OperationError\n\t\t// if opErr, ok := err.(*OperationError); ok { /* フィールドアクセス */ }\n\t}\n}",
        "tags": [
          "error-handling",
          "error",
          "struct",
          "interface",
          "カスタムエラー"
        ]
      },
      {
        "title": "エラー処理: カスタムエラーを返す",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\n// カスタムエラー型 (前のセクションで定義)\ntype OperationError struct {\n\tTimestamp time.Time; Op string; Code int; Message string\n}\nfunc (e *OperationError) Error() string { /* ... 実装 ... */\n\treturn fmt.Sprintf(\"[%s] Op:%s Code:%d Msg:%s\",\n\t\te.Timestamp.Format(time.RFC3339), e.Op, e.Code, e.Message)\n}\n\n\n// カスタムエラーを返す関数\nfunc performAction(action string, shouldFail bool) error { // 戻り値は error\n\tfmt.Printf(\"アクション '%s' 実行...\\n\", action)\n\tif shouldFail {\n\t\t// 失敗時: *OperationError を error として返す\n\t\treturn &OperationError{\n\t\t\tTimestamp: time.Now(), Op: action, Code: 400, Message: \"無効な入力\",\n\t\t}\n\t}\n\t// 成功時: nil を返す\n\treturn nil\n}\n\nfunc main() {\n\t// 成功ケース\n\terr1 := performAction(\"登録\", false)\n\tif err1 == nil { fmt.Println(\"-> 成功\") }\n\n\t// 失敗ケース\n\terr2 := performAction(\"削除\", true)\n\tif err2 != nil {\n\t\tfmt.Println(\"エラー:\", err2) // 実装した Error() が呼ばれる\n\t\tfmt.Printf(\"型: %T\\n\", err2) // *main.OperationError\n\t}\n}",
        "tags": [
          "error-handling",
          "error",
          "struct",
          "interface",
          "カスタムエラー",
          "return"
        ]
      },
      {
        "title": "エラー処理: カスタムエラーの判定 (型アサーション)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\n// カスタムエラー型 (例)\ntype OperationError struct {\n\tTimestamp time.Time; Op string; Code int; Message string\n}\nfunc (e *OperationError) Error() string { /* ... 実装 ... */\n\treturn fmt.Sprintf(\"[%s] Op:%s Code:%d Msg:%s\",\n\t\te.Timestamp.Format(time.RFC3339), e.Op, e.Code, e.Message)\n}\n\n// カスタムエラーを返す関数 (例)\nfunc performAction(action string, failCode int) error {\n\tif failCode != 0 {\n\t\treturn &OperationError{ time.Now(), action, failCode, \"問題発生\" }\n\t}\n\treturn nil\n}\n\nfunc main() {\n\terr := performAction(\"読込\", 404) // エラーを発生させる\n\n\tif err != nil {\n\t\tfmt.Println(\"エラー:\", err)\n\n\t\t// ★ 型アサーションで *OperationError かチェック ★\n\t\topErr, ok := err.(*OperationError)\n\t\tif ok {\n\t\t\t// 成功: opErr は *OperationError 型\n\t\t\tfmt.Println(\"-> OperationError です\")\n\t\t\tfmt.Printf(\"   コード: %d\\n\", opErr.Code) // フィールドにアクセス\n\t\t\tif opErr.Code == 404 { fmt.Println(\"   -> Not Found\") }\n\t\t} else {\n\t\t\tfmt.Println(\"-> OperationError ではありません\")\n\t\t}\n\t}\n}",
        "tags": [
          "error-handling",
          "error",
          "カスタムエラー",
          "型アサーション",
          "type assertion",
          "カンマOK"
        ]
      },
      {
        "title": "エラー処理: 特定の型のエラーの取得 (`errors.As`)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"time\"\n)\n\n// カスタムエラー型\ntype OperationError struct {\n\tTimestamp time.Time; Op string; Code int; Message string; Err error\n}\nfunc (e *OperationError) Error() string { /* ... 実装 ... */\n\tmsg := fmt.Sprintf(\"[%s] Op:%s Code:%d Msg:%s\",\n\t\te.Timestamp.Format(time.RFC3339), e.Op, e.Code, e.Message)\n\tif e.Err != nil { msg += fmt.Sprintf(\" (Cause: %v)\", e.Err) }\n\treturn msg\n}\n// エラーラッピングのために Unwrap を実装\nfunc (e *OperationError) Unwrap() error { return e.Err }\n\n// エラーをラップして返す関数\nfunc openFileWrapped(filename string) error {\n\t_, err := os.Open(filename)\n\tif err != nil {\n\t\t// os.Open のエラー err を OperationError でラップ\n\t\treturn &OperationError{ time.Now(), \"open\", 500, \"失敗\", err }\n\t}\n\treturn nil\n}\n\nfunc main() {\n\terr := openFileWrapped(\"non_existent.txt\")\n\tif err != nil {\n\t\tfmt.Println(\"エラー:\", err)\n\n\t\t// errors.As で *OperationError 型を探す\n\t\tvar opErr *OperationError // 対象の型のポインタ変数を用意\n\t\t// 第2引数に opErr のアドレス (&opErr) を渡す\n\t\tif errors.As(err, &opErr) {\n\t\t\t// 見つかった場合、opErr に値が設定される\n\t\t\tfmt.Println(\"-> OperationError です\")\n\t\t\tfmt.Printf(\"   コード: %d\\n\", opErr.Code) // フィールドにアクセス\n\t\t\tif opErr.Err != nil {\n\t\t\t\tfmt.Printf(\"   ラップされたエラー: %v\\n\", opErr.Err)\n\t\t\t\t// if errors.Is(opErr.Err, os.ErrNotExist) { ... }\n\t\t\t}\n\t\t} else {\n\t\t\tfmt.Println(\"-> OperationError ではありません\")\n\t\t}\n\t}\n}",
        "tags": [
          "error-handling",
          "error",
          "errors",
          "errors.As",
          "エラーラッピング",
          "%w",
          "カスタムエラー",
          "型アサーション"
        ]
      },
      {
        "title": "エラー処理: ラップされたエラーの判定 (`errors.Is`)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n)\n\n// 下位の処理 (os.Open のエラーをラップ)\nfunc loadConfig(path string) error {\n\t_, err := os.Open(path)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"設定読込失敗 '%s': %w\", path, err) // %w でラップ\n\t}\n\treturn nil\n}\n\n// 上位の処理 (loadConfig のエラーをさらにラップ)\nfunc setup(configPath string) error {\n\terr := loadConfig(configPath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"初期設定失敗: %w\", err) // %w でラップ\n\t}\n\treturn nil\n}\n\nfunc main() {\n\terr := setup(\"config.yaml\") // 存在しないファイル\n\tif err != nil {\n\t\tfmt.Println(\"エラー:\", err)\n\n\t\t// errors.Is でラップされた根本原因 (os.ErrNotExist) をチェック\n\t\tif errors.Is(err, os.ErrNotExist) {\n\t\t\tfmt.Println(\"-> 原因: 設定ファイルが存在しない\")\n\t\t} else {\n\t\t\tfmt.Println(\"-> その他のエラー\")\n\t\t}\n\n\t\t// if err == os.ErrNotExist { ... } // これは false になる\n\t}\n}",
        "tags": [
          "error-handling",
          "error",
          "errors",
          "errors.Is",
          "エラーラッピング",
          "%w",
          "センチネルエラー"
        ]
      },
      {
        "title": "エラー処理: センチネルエラー (Sentinel Errors)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\n// パッケージレベルでセンチネルエラーを定義\nvar ErrResourceNotFound = errors.New(\"リソースが見つかりません\")\nvar ErrInvalidInput = errors.New(\"入力が無効です\")\n\n// センチネルエラーを返す可能性のある関数\nfunc fetchData(id int) (string, error) {\n\tif id <= 0 { return \"\", ErrInvalidInput }\n\tif id == 404 { return \"\", ErrResourceNotFound }\n\treturn fmt.Sprintf(\"データ %d\", id), nil\n}\n\nfunc main() {\n\tid := 404\n\tfmt.Printf(\"ID %d 取得:\\n\", id)\n\t_, err := fetchData(id)\n\n\tif err != nil {\n\t\tfmt.Printf(\" エラー: %v\\n\", err)\n\t\t// errors.Is でセンチネルエラーを判定\n\t\tif errors.Is(err, ErrResourceNotFound) {\n\t\t\tfmt.Println(\"  -> 原因: リソースなし\")\n\t\t} else if errors.Is(err, ErrInvalidInput) {\n\t\t\tfmt.Println(\"  -> 原因: 無効入力\")\n\t\t} else {\n\t\t\tfmt.Println(\"  -> 原因: その他\")\n\t\t}\n\t}\n}",
        "tags": [
          "error-handling",
          "error",
          "errors",
          "errors.New",
          "errors.Is",
          "センチネルエラー"
        ]
      },
      {
        "title": "エラー処理: 早期リターンパターン (Early Return)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\n// ダミーの処理ステップ関数 (エラーを返す可能性あり)\nfunc step1() error { fmt.Println(\"Step 1\"); return nil }\nfunc step2(s string) error { fmt.Println(\"Step 2\", s); if s == \"\" { return errors.New(\"step 2 error\") }; return nil }\nfunc step3() error { fmt.Println(\"Step 3\"); return nil }\n\n\n// 複数のステップを実行し、エラーがあれば早期リターン\nfunc processSequence() error {\n\tfmt.Println(\"Process Start\")\n\n\terr := step1()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"step 1 failed: %w\", err) // 早期リターン\n\t}\n\n\tintermediate := \"step1 ok\" // step1 の結果を使う例\n\n\terr = step2(intermediate)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"step 2 failed: %w\", err) // 早期リターン\n\t}\n\n\terr = step3()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"step 3 failed: %w\", err) // 早期リターン\n\t}\n\n\tfmt.Println(\"Process Success\")\n\treturn nil // すべて成功\n}\n\nfunc main() {\n\terr := processSequence()\n\tif err != nil {\n\t\tfmt.Println(\"\\n最終エラー:\", err)\n\t} else {\n\t\tfmt.Println(\"\\n最終結果: 成功\")\n\t}\n}",
        "tags": [
          "error-handling",
          "error",
          "if",
          "return",
          "早期リターン",
          "ガード節",
          "コーディングスタイル"
        ]
      },
      {
        "title": "エラー処理: HTTPミドルウェアによるエラーハンドリング",
        "description": "",
        "code": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n)\n\n// エラーを返すカスタムハンドラ型\ntype AppHandler func(http.ResponseWriter, *http.Request) error\n\n// ServeHTTP でエラー処理ミドルウェアを実装\nfunc (fn AppHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\t// Panic Recovery\n\tdefer func() {\n\t\tif rcv := recover(); rcv != nil {\n\t\t\tlog.Printf(\"Panic: %v\", rcv)\n\t\t\thttp.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n\t\t}\n\t}()\n\n\t// ハンドラ実行とエラー処理\n\terr := fn(w, r)\n\tif err != nil {\n\t\tlog.Printf(\"Error: %v\", err)\n\t\t// errors.Is や errors.As でエラーの種類を判別し、\n\t\t// 適切な statusCode を設定する (例はデフォルト 500)\n\t\tstatusCode := http.StatusInternalServerError\n\t\thttp.Error(w, err.Error(), statusCode)\n\t}\n}\n\n// ハンドラ関数の例 (error を返す)\nfunc handleExample(w http.ResponseWriter, r *http.Request) error {\n\tif r.URL.Query().Get(\"fail\") == \"true\" {\n\t\treturn errors.New(\"処理失敗\") // エラーを返す\n\t}\n\tif r.URL.Query().Get(\"panic\") == \"true\" {\n\t\tpanic(\"パニック発生\") // パニックを起こす\n\t}\n\tfmt.Fprintln(w, \"成功\")\n\treturn nil // 成功時は nil\n}\n\nfunc main() {\n\tmux := http.NewServeMux()\n\t// AppHandler 型にキャストして登録\n\tmux.Handle(\"/example\", AppHandler(handleExample))\n\n\tfmt.Println(\"Listening on :8080...\")\n\tlog.Fatal(http.ListenAndServe(\":8080\", mux))\n}",
        "tags": [
          "error-handling",
          "error",
          "http",
          "middleware",
          "panic",
          "recover",
          "defer"
        ]
      },
      {
        "title": "エラー処理: 構造化エラー (Structured Errors)",
        "description": "エラーメッセージ文字列だけでなく、エラーに関する**追加情報**\n(エラーコード、発生箇所、関連データ等) をプログラムで扱える形で\n保持したい場合、**構造化エラー (Structured Error)** を使います。\n\nGoでは**カスタムエラー型**（通常は構造体）を定義することで実装します。\n\n**定義と利点:**\n1. エラー情報を保持するフィールドを持つ**構造体**を定義。\n2. その構造体に **`Error() string` メソッドを実装**し、\n   `error` インターフェースを満たす。\n   `Error()` メソッド内でフィールドを使いメッセージを生成。",
        "code": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n)\n\n// 構造化エラー型 (例: バリデーションエラー)\ntype ValidationError struct {\n\tFieldName string; ErrValue any; Message string\n}\nfunc (e *ValidationError) Error() string {\n\treturn fmt.Sprintf(\"Validation Error (Field: %s, Value: '%v'): %s\",\n\t\te.FieldName, e.ErrValue, e.Message)\n}\n\n// バリデーション関数 (構造化エラーを返す)\nfunc validateUsername(username string) error {\n\tif len(username) < 3 {\n\t\treturn &ValidationError{\"username\", username, \"短すぎ\"}\n\t}\n\tif strings.Contains(username, \" \") {\n\t\treturn &ValidationError{\"username\", username, \"空白不可\"}\n\t}\n\treturn nil\n}\n\nfunc main() {\n\tnames := []string{\"gopher\", \"go\", \"user name\"}\n\tfor _, name := range names {\n\t\tfmt.Printf(\"\\n検証 '%s':\\n\", name)\n\t\terr := validateUsername(name)\n\t\tif err != nil {\n\t\t\tfmt.Println(\" エラー:\", err)\n\t\t\t// errors.As で ValidationError 型かチェック\n\t\t\tvar valErr *ValidationError\n\t\t\tif errors.As(err, &valErr) {\n\t\t\t\t// 型が一致すればフィールドにアクセスできる\n\t\t\t\tfmt.Printf(\"  -> Field: %s, Detail: %s\\n\", valErr.FieldName, valErr.Message)\n\t\t\t}\n\t\t} else {\n\t\t\tfmt.Println(\" -> OK\")\n\t\t}\n\t}\n}",
        "tags": [
          "error-handling",
          "error",
          "struct",
          "カスタムエラー",
          "errors.As"
        ]
      },
      {
        "title": "エラー処理: 複数のエラーの結合 `errors.Join` (Go 1.20+)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n)\n\nvar ErrValueRequired = errors.New(\"値が必要\")\nvar ErrValueTooShort = errors.New(\"短すぎ\")\n\nfunc validateName(name string) error {\n\tif name == \"\" { return fmt.Errorf(\"名前: %w\", ErrValueRequired) }\n\tif len(name) < 3 { return fmt.Errorf(\"名前 '%s': %w\", name, ErrValueTooShort) }\n\treturn nil\n}\nfunc validateEmail(email string) error {\n\tif email == \"\" { return fmt.Errorf(\"メール: %w\", ErrValueRequired) }\n\tif !strings.Contains(email, \"@\") { return fmt.Errorf(\"メール '%s': 無効\", email) }\n\treturn nil\n}\n\n// 複数のバリデーションを行い、エラーを errors.Join で結合\nfunc validateForm(name, email string) error {\n\t// 各バリデーション結果 (error または nil) を Join に渡す\n\treturn errors.Join(\n\t\tvalidateName(name),\n\t\tvalidateEmail(email),\n\t) // nil は無視され、エラーがあれば結合される\n}\n\nfunc main() {\n\t// 複数のエラーが発生するケース\n\terr := validateForm(\"Go\", \"invalid-email\")\n\tif err != nil {\n\t\t// Error() は結合されたメッセージを改行区切りで返す\n\t\tfmt.Printf(\"エラー:\\n%v\\n\", err)\n\n\t\t// errors.Is で特定のエラーが含まれるか確認できる\n\t\tif errors.Is(err, ErrValueTooShort) {\n\t\t\tfmt.Println(\"-> 短すぎるエラーあり\")\n\t\t}\n\t\tif errors.Is(err, ErrValueRequired) {\n\t\t\tfmt.Println(\"-> 必須エラーあり\") // これは含まれない\n\t\t}\n\t}\n}",
        "tags": [
          "error-handling",
          "error",
          "errors",
          "errors.Join",
          "エラーラッピング",
          "Go1.20"
        ]
      },
      {
        "title": "エラー処理: 結合されたエラーの検査 (Go 1.20+)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t// \"strings\" // strings.Split を使う場合\n)\n\n// --- エラー定義やエラーを返す関数は省略 (前のセクション参照) ---\nvar ErrValueRequired = errors.New(\"値が必要\")\nvar ErrValueTooShort = errors.New(\"短すぎ\")\ntype ConfigError struct { FileName string; Err error }\nfunc (e *ConfigError) Error() string { return fmt.Sprintf(\"設定 '%s': %v\", e.FileName, e.Err) }\nfunc (e *ConfigError) Unwrap() error { return e.Err }\nfunc validateName(name string) error { if len(name) < 3 { return fmt.Errorf(\"名前 '%s': %w\", name, ErrValueTooShort) }; return nil }\nfunc validateEmail(email string) error { if email == \"\" { return fmt.Errorf(\"メール: %w\", ErrValueRequired) }; return nil }\nfunc loadConfigFile(filename string) error { _, err := os.Open(filename); if err != nil { return &ConfigError{filename, err} }; return nil }\n// --- ここまで省略 ---\n\n\nfunc main() {\n\t// 複数のエラーを結合 (例)\n\tjoinedErr := errors.Join(\n\t\tvalidateName(\"Go\"),             // ErrValueTooShort をラップ\n\t\tvalidateEmail(\"\"),              // ErrValueRequired をラップ\n\t\tloadConfigFile(\"config.txt\"), // ConfigError (os.ErrNotExist をラップ)\n\t)\n\n\tif joinedErr != nil {\n\t\tfmt.Printf(\"結合エラー:\\n%v\\n\", joinedErr)\n\n\t\t// errors.Is で特定のエラー値が含まれるか検査\n\t\tif errors.Is(joinedErr, ErrValueTooShort) { fmt.Println(\"-> 短すぎエラーあり\") }\n\t\tif errors.Is(joinedErr, os.ErrNotExist) { fmt.Println(\"-> ファイルなしエラーあり\") }\n\n\t\t// errors.As で特定の型のエラーが含まれるか検査\n\t\tvar configErr *ConfigError\n\t\tif errors.As(joinedErr, &configErr) {\n\t\t\tfmt.Println(\"-> ConfigError あり (ファイル:\", configErr.FileName, \")\")\n\t\t}\n\n\t\t// 個々のエラーメッセージ取得 (参考: Error() を分割)\n\t\t// for _, line := range strings.Split(joinedErr.Error(), \"\\n\") { ... }\n\t}\n}",
        "tags": [
          "error-handling",
          "error",
          "errors",
          "errors.Join",
          "errors.Is",
          "errors.As",
          "エラーラッピング",
          "Go1.20"
        ]
      },
      {
        "title": "エラー処理: `defer` と組み合わせたエラーハンドリング",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\n// ファイル処理関数 (defer 内で Close のエラーも考慮)\n// ★ 戻り値 error に名前 'err' を付ける\nfunc processFile(filename string) (err error) {\n\tfmt.Printf(\"\\n処理開始: %s\\n\", filename)\n\tf, openErr := os.Open(filename)\n\tif openErr != nil {\n\t\terr = fmt.Errorf(\"オープン失敗: %w\", openErr)\n\t\treturn // err が返る\n\t}\n\n\t// ★ defer でクローズ処理とエラーハンドリング\n\tdefer func() {\n\t\tfmt.Println(\" defer: クローズ処理...\")\n\t\tcloseErr := f.Close()\n\t\tif closeErr != nil {\n\t\t\tfmt.Printf(\" defer: クローズエラー: %v\\n\", closeErr)\n\t\t\t// ★ 関数本体でエラーが発生していなければ (err == nil)、\n\t\t\t//    クローズエラーを関数の最終エラーとする\n\t\t\tif err == nil {\n\t\t\t\terr = fmt.Errorf(\"クローズ失敗: %w\", closeErr)\n\t\t\t}\n\t\t\t// (本体エラーがあればそちらを優先)\n\t\t} else {\n\t\t\tfmt.Println(\" defer: クローズ成功\")\n\t\t}\n\t}() // defer func() { ... }()\n\n\t// --- ファイル処理 (例) ---\n\tfmt.Println(\" ファイル処理中...\")\n\t// if someCondition {\n\t//     err = errors.New(\"処理中エラー\")\n\t//     return // この場合でも defer は実行される\n\t// }\n\n\tfmt.Println(\" 処理正常終了\")\n\treturn nil // 成功時は nil (defer で closeErr も nil なら)\n}\n\nfunc main() {\n\t// 正常ケース (ファイル作成・削除は省略)\n\t// os.WriteFile(\"test.txt\", []byte(\"data\"), 0644)\n\tprocessFile(\"test.txt\") // 存在しないファイルでオープンエラーを試す\n\n\t// os.Remove(\"test.txt\")\n}",
        "tags": [
          "error-handling",
          "error",
          "defer",
          "クリーンアップ",
          "名前付き戻り値"
        ]
      }
    ]
  },
  {
    "title": "Concurrency",
    "codeExamples": [
      {
        "title": "並行処理: Goroutine (ゴルーチン) の開始",
        "description": "Goの**並行処理 (Concurrency)** の中心が **Goroutine** です。\n\n**Goroutine とは？**\n*   **軽量な実行単位:** OSスレッドより遥かに軽量で多数実行可能。\n*   **並行実行:** 複数の処理が見かけ上同時に進行する。\n    (物理的な同時実行は**並列 Parallel**)\n*   **簡単な起動:** `go` キーワードで関数呼び出しを起動。\n\n**Goroutine の起動: `go` キーワード**\n関数呼び出しの前に `go` を付けると、その関数は新しい\nGoroutine として起動され、呼び出し元とは**並行**に実行されます。\n**構文:**",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\n// Goroutine で実行する関数\nfunc say(s string) {\n\tfor i := 0; i < 3; i++ {\n\t\tfmt.Printf(\"%s: %d\\n\", s, i)\n\t\ttime.Sleep(100 * time.Millisecond)\n\t}\n\tfmt.Printf(\"%s: 完了\\n\", s)\n}\n\nfunc main() {\n\tfmt.Println(\"main: 開始\")\n\n\t// say 関数を新しい Goroutine として起動\n\tgo say(\"Hello\")\n\tfmt.Println(\"main: say(\\\"Hello\\\") Goroutine 起動\")\n\n\t// 匿名関数も Goroutine で起動可能\n\t// go func(msg string) { ... }(\"メッセージ\")\n\n\tfmt.Println(\"main: 他の処理...\")\n\ttime.Sleep(50 * time.Millisecond)\n\n\t// ★ 注意: main がここで終了すると say Goroutine も終了してしまう\n\t//          完了を待つ必要がある (次のセクションで解説)\n\t//          time.Sleep は不確実なため、実際のコードでは使わない！\n\tfmt.Println(\"main: 少し待機 (悪い例)...\")\n\ttime.Sleep(500 * time.Millisecond)\n\n\tfmt.Println(\"main: 終了\")\n}",
        "tags": [
          "concurrency",
          "goroutine",
          "go",
          "並行処理",
          "軽量スレッド"
        ]
      },
      {
        "title": "並行処理: Goroutine の終了を待つ (`sync.WaitGroup`)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\" // sync パッケージ\n\t\"time\"\n)\n\n// Goroutine で実行するワーカー関数\nfunc worker(id int, wg *sync.WaitGroup) {\n\t// ★ 最初に defer で Done() を登録\n\tdefer wg.Done() // Goroutine 完了時にカウンターを減らす\n\n\tfmt.Printf(\"Worker %d: Start\\n\", id)\n\ttime.Sleep(time.Duration(id) * 100 * time.Millisecond) // 処理のシミュレート\n\tfmt.Printf(\"Worker %d: End\\n\", id)\n}\n\nfunc main() {\n\tvar wg sync.WaitGroup // WaitGroup を宣言\n\n\tnumWorkers := 3\n\tfmt.Printf(\"Starting %d workers...\\n\", numWorkers)\n\n\t// ★ 起動する Goroutine の数を Add で設定\n\twg.Add(numWorkers)\n\n\t// Goroutine を起動\n\tfor i := 1; i <= numWorkers; i++ {\n\t\tgo worker(i, &wg) // wg のポインタを渡す\n\t}\n\n\tfmt.Println(\"Waiting for workers to finish...\")\n\t// ★ Wait でカウンターが 0 になるのを待つ\n\twg.Wait() // 全ての worker が Done() を呼ぶまでブロック\n\n\tfmt.Println(\"All workers finished.\")\n}",
        "tags": [
          "concurrency",
          "goroutine",
          "sync",
          "WaitGroup",
          "同期",
          "Add",
          "Done",
          "Wait"
        ]
      },
      {
        "title": "並行処理: 複数の Goroutine と WaitGroup",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\tnumWorkers := 5\n\n\tfmt.Printf(\"%d 個のワーカー起動...\\n\", numWorkers)\n\n\t// ループで複数の Goroutine を起動\n\tfor i := 1; i <= numWorkers; i++ {\n\t\twg.Add(1) // Goroutine 起動前にカウンターを増やす\n\t\t// ループ変数 i を Goroutine に引数として渡す\n\t\tgo func(workerID int) {\n\t\t\tdefer wg.Done() // Goroutine 完了時にカウンターを減らす\n\n\t\t\tfmt.Printf(\"Worker %d: Start\\n\", workerID)\n\t\t\ttime.Sleep(time.Duration(workerID) * 50 * time.Millisecond)\n\t\t\tfmt.Printf(\"Worker %d: End\\n\", workerID)\n\t\t}(i) // ★ 現在の i の値を引数として渡す\n\t}\n\n\tfmt.Println(\"全ワーカーの終了待機...\")\n\twg.Wait() // カウンターが 0 になるまで待つ\n\n\tfmt.Println(\"全ワーカー終了\")\n}",
        "tags": [
          "concurrency",
          "goroutine",
          "sync",
          "WaitGroup",
          "同期",
          "ループ",
          "クロージャ"
        ]
      },
      {
        "title": "並行処理: チャネル (Channel) の基本",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\t// バッファなしチャネル作成\n\tch1 := make(chan string)\n\n\tgo func() {\n\t\tfmt.Println(\"Goroutine: 送信開始\")\n\t\tch1 <- \"Hello\" // 送信 (受信側が待つまでブロックする可能性)\n\t\tfmt.Println(\"Goroutine: 送信完了\")\n\t\ttime.Sleep(50 * time.Millisecond)\n\t\tch1 <- \"World\"\n\t\tfmt.Println(\"Goroutine: 送信完了、クローズ\")\n\t\tclose(ch1) // ★ 送信側がクローズ\n\t}()\n\n\tfmt.Println(\"main: 受信待機...\")\n\tmsg1 := <-ch1 // 受信 (送信されるまでブロックする可能性)\n\tfmt.Printf(\"main: 受信1: %s\\n\", msg1)\n\tmsg2 := <-ch1 // 再度受信\n\tfmt.Printf(\"main: 受信2: %s\\n\", msg2)\n\n\t// クローズ後の受信確認\n\tmsg3, ok := <-ch1\n\tif !ok {\n\t\tfmt.Printf(\"main: 受信3: クローズ済み (値:%q, ok:%t)\\n\", msg3, ok)\n\t}\n\t// close(ch1) // 再クローズは panic\n\t// ch1 <- \"Bye\" // クローズ後送信は panic\n}",
        "tags": [
          "concurrency",
          "channel",
          "goroutine",
          "make",
          "<-",
          "close",
          "同期",
          "通信",
          "バッファ"
        ]
      },
      {
        "title": "並行処理: `for range` によるチャネルからの受信",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\n// メッセージを送信し、最後にチャネルをクローズする関数\nfunc produceMessages(count int, ch chan<- string) {\n\tfmt.Println(\"Producer: 開始\")\n\tfor i := 1; i <= count; i++ {\n\t\tmsg := fmt.Sprintf(\"Msg %d\", i)\n\t\tfmt.Printf(\"Producer: 送信 '%s'\\n\", msg)\n\t\tch <- msg\n\t\ttime.Sleep(50 * time.Millisecond)\n\t}\n\tfmt.Println(\"Producer: クローズ\")\n\tclose(ch) // ★ 送信完了後にクローズ\n}\n\nfunc main() {\n\tmessageChannel := make(chan string)\n\tgo produceMessages(3, messageChannel) // Goroutine で送信\n\n\tfmt.Println(\"Consumer: 受信開始 (for range)...\")\n\t// ★ for range でチャネルから受信\n\t// チャネルがクローズされるまでループが続く\n\tfor msg := range messageChannel {\n\t\tfmt.Printf(\"Consumer: 受信 '%s'\\n\", msg)\n\t}\n\tfmt.Println(\"Consumer: ループ終了 (チャネルクローズ)\")\n}",
        "tags": [
          "concurrency",
          "channel",
          "goroutine",
          "for range",
          "close",
          "ループ"
        ]
      },
      {
        "title": "並行処理: 方向付きチャネル (Directional Channels)",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\n// 送信専用チャネル (chan<- string) を受け取る関数\nfunc producer(out chan<- string) {\n\tfmt.Println(\"Producer: 送信開始\")\n\tout <- \"データ\" // 送信のみ可能\n\t// <-out // 受信はコンパイルエラー\n\tfmt.Println(\"Producer: 送信完了\")\n\t// close(out) // 送信専用はクローズ不可\n}\n\n// 受信専用チャネル (<-chan string) を受け取る関数\nfunc consumer(in <-chan string) {\n\tfmt.Println(\"Consumer: 受信開始\")\n\tmsg := <-in // 受信のみ可能\n\tfmt.Printf(\"Consumer: 受信: %s\\n\", msg)\n\t// in <- \"x\" // 送信はコンパイルエラー\n\tfmt.Println(\"Consumer: 受信完了\")\n}\n\nfunc main() {\n\t// 通常の双方向チャネルを作成\n\tch := make(chan string, 1)\n\n\t// 双方向チャネルを方向付きチャネルとして渡せる\n\tgo producer(ch) // producer は chan<- string を期待\n\tconsumer(ch)    // consumer は <-chan string を期待\n\n\tclose(ch) // クローズは元の双方向チャネルで行う\n}",
        "tags": [
          "concurrency",
          "channel",
          "goroutine",
          "方向付きチャネル",
          "送信専用",
          "受信専用",
          "型安全性"
        ]
      },
      {
        "title": "並行処理: ワーカープール (Worker Pool) パターン",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\n// ワーカー: jobs から受信し、処理して results へ送信\nfunc worker(id int, jobs <-chan int, results chan<- int, wg *sync.WaitGroup) {\n\tdefer wg.Done() // 完了を通知\n\tfor job := range jobs { // jobs が close されるまで受信\n\t\tfmt.Printf(\"Worker %d: Job %d 開始\\n\", id, job)\n\t\ttime.Sleep(100 * time.Millisecond) // 処理シミュレート\n\t\tresult := job * 2\n\t\tfmt.Printf(\"Worker %d: Job %d 完了, Result %d\\n\", id, job, result)\n\t\tresults <- result // 結果を送信\n\t}\n\tfmt.Printf(\"Worker %d: 終了\\n\", id)\n}\n\nfunc main() {\n\tconst numJobs = 5\n\tconst numWorkers = 3\n\n\tjobs := make(chan int, numJobs)\n\tresults := make(chan int, numJobs)\n\tvar wg sync.WaitGroup\n\n\t// ワーカー Goroutine 起動\n\tfmt.Printf(\"%d ワーカー起動...\\n\", numWorkers)\n\tfor w := 1; w <= numWorkers; w++ {\n\t\twg.Add(1)\n\t\tgo worker(w, jobs, results, &wg)\n\t}\n\n\t// ジョブ送信\n\tfmt.Printf(\"%d ジョブ送信...\\n\", numJobs)\n\tfor j := 1; j <= numJobs; j++ {\n\t\tjobs <- j\n\t}\n\tclose(jobs) // ★ 全ジョブ送信後、jobs をクローズ\n\tfmt.Println(\"全ジョブ送信完了、jobs クローズ\")\n\n\t// 全ワーカーの終了待機\n\tfmt.Println(\"ワーカー終了待機...\")\n\twg.Wait()\n\tfmt.Println(\"全ワーカー終了\")\n\n\t// ★ 全ワーカー終了後、results をクローズ\n\tclose(results)\n\n\t// 結果収集\n\tfmt.Println(\"結果収集...\")\n\ttotal := 0\n\tfor result := range results { // results が close されるまで受信\n\t\tfmt.Printf(\"結果受信: %d\\n\", result)\n\t\ttotal += result\n\t}\n\tfmt.Printf(\"結果合計: %d\\n\", total)\n}",
        "tags": [
          "concurrency",
          "goroutine",
          "channel",
          "worker pool",
          "並行処理パターン",
          "sync",
          "WaitGroup"
        ]
      },
      {
        "title": "並行処理: `select` 文による複数チャネル操作の待機",
        "description": "複数のチャネル送受信操作を**同時に待ち受け**、\n最初に準備ができたものを実行するのが **`select`** 文です。\n`switch` に似ていますが、`case` はチャネル操作を評価します。\n\n**構文と動作:**",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tch1 := make(chan string)\n\tch2 := make(chan string)\n\n\t// Goroutine 1: 1秒後に ch1 へ送信\n\tgo func() { time.Sleep(1 * time.Second); ch1 <- \"from 1\" }()\n\t// Goroutine 2: 500ミリ秒後に ch2 へ送信\n\tgo func() { time.Sleep(500 * time.Millisecond); ch2 <- \"from 2\" }()\n\n\tfmt.Println(\"受信待機中...\")\n\n\t// select で ch1 または ch2 から受信可能な方を待つ\n\tselect {\n\tcase msg1 := <-ch1:\n\t\tfmt.Printf(\"ch1 受信: %s\\n\", msg1)\n\tcase msg2 := <-ch2:\n\t\tfmt.Printf(\"ch2 受信: %s\\n\", msg2) // ch2 が先に準備できる\n\t}\n\n\tfmt.Println(\"最初のメッセージ受信完了\")\n\n\t// (もう一方を受信するには再度 select や受信操作が必要)\n\t// msg := <-ch1 // 例\n\t// fmt.Println(\"残りを別途受信:\", msg)\n}",
        "tags": [
          "concurrency",
          "channel",
          "goroutine",
          "select",
          "case",
          "同期",
          "通信"
        ]
      },
      {
        "title": "並行処理: `select` によるタイムアウト処理",
        "description": "チャネル操作は相手の準備ができるまでブロックする可能性がありますが、\n無期限に待たずに一定時間で中断（タイムアウト）したい場合があります。\n`select` 文と `time.After` で実現できます。\n\n**`time.After` によるタイムアウト:**\n`time.After(d time.Duration)` は、指定期間 `d` 経過後に\n現在時刻を一度だけ送信する**受信専用チャネル** (`<-chan Time`) を返します。\n\n**`select` での利用パターン:**",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\n// 時間のかかる処理 (シミュレーション)\nfunc longOperation(duration time.Duration, resultChan chan<- string) {\n\tfmt.Printf(\" Goroutine: %v 処理開始...\\n\", duration)\n\ttime.Sleep(duration)\n\tresult := fmt.Sprintf(\"完了 (%v)\", duration)\n\tfmt.Printf(\" Goroutine: 結果 '%s' 送信\\n\", result)\n\t// 注意: タイムアウト後も送信しようとする可能性がある\n\tresultChan <- result\n}\n\nfunc main() {\n\tch1 := make(chan string, 1)\n\tgo longOperation(2*time.Second, ch1) // 2秒かかる処理\n\n\tfmt.Println(\"1秒間のタイムアウトを設定して待機...\")\n\n\tselect {\n\tcase res := <-ch1: // 処理結果の受信を待つ\n\t\tfmt.Printf(\"受信成功: %s\\n\", res)\n\tcase <-time.After(1 * time.Second): // 1秒待つ\n\t\t// 1秒以内に ch1 から受信できなければ、こちらが実行される\n\t\tfmt.Println(\"タイムアウトしました！\")\n\t}\n\n\t// (タイムアウトしなかった場合の例は解説参照)\n\t// time.Sleep(2 * time.Second) // Goroutine が完了するのを待つ (デモ用)\n}",
        "tags": [
          "concurrency",
          "channel",
          "goroutine",
          "select",
          "timeout",
          "time.After",
          "同期"
        ]
      },
      {
        "title": "並行処理: `select` と終了チャネル (Quit Channel)",
        "description": "実行中の Goroutine に外部から安全に終了を通知する古典的な\nパターンが**終了チャネル (Quit Channel)** です。\n\n**パターン:**\n1. **終了チャネル作成:** 通常 `make(chan struct{})` を使う\n   (空構造体はメモリ消費ゼロ)。\n2. **Goroutine へ渡す:** 終了させたい Goroutine に引数\n   (通常 `<-chan struct{}`) として渡す。\n3. **`select` で待機:** Goroutine 内のループで `select` を使い、\n   通常の処理用チャネルと**終了チャネルからの受信**を待つ。",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\n// 終了通知を受け取るまで処理を続けるワーカー\nfunc worker(id int, dataChan <-chan string, quitChan <-chan struct{}) {\n\tfmt.Printf(\"Worker %d: 開始\\n\", id)\n\tfor {\n\t\tselect {\n\t\tcase data := <-dataChan:\n\t\t\tfmt.Printf(\"Worker %d: 処理 '%s'\\n\", id, data)\n\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\tcase <-quitChan: // ★ 終了チャネルから受信 (またはクローズ検知)\n\t\t\tfmt.Printf(\"Worker %d: 終了シグナル受信\\n\", id)\n\t\t\treturn // Goroutine 終了\n\t\t}\n\t}\n}\n\nfunc main() {\n\tdataChan := make(chan string)\n\tquitChan := make(chan struct{}) // 終了通知用チャネル\n\n\tgo worker(1, dataChan, quitChan) // ワーカー起動\n\n\tdataChan <- \"データ A\"\n\tdataChan <- \"データ B\"\n\ttime.Sleep(200 * time.Millisecond)\n\n\tfmt.Println(\"main: 終了シグナル送信 (close)\")\n\tclose(quitChan) // ★ チャネルをクローズして終了を通知\n\n\ttime.Sleep(100 * time.Millisecond) // 終了を待つ (WaitGroup推奨)\n\tfmt.Println(\"main: 終了\")\n}",
        "tags": [
          "concurrency",
          "channel",
          "goroutine",
          "select",
          "quit channel",
          "終了通知",
          "同期",
          "context"
        ]
      },
      {
        "title": "並行処理: ノンブロッキング `select` (`default` ケース)",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tmessages := make(chan string) // バッファなし\n\tmsgToSend := \"Hi\"\n\n\t// ノンブロッキング受信\n\t// messages は空なので受信はブロックするはず\n\tselect {\n\tcase msg := <-messages:\n\t\tfmt.Println(\"受信:\", msg)\n\tdefault: // ★ 他の case がブロックするので default が実行される\n\t\tfmt.Println(\"受信メッセージなし\")\n\t}\n\n\t// ノンブロッキング送信\n\t// messages に受信側がいないので送信はブロックするはず\n\tselect {\n\tcase messages <- msgToSend:\n\t\tfmt.Println(\"送信成功:\", msgToSend)\n\tdefault: // ★ 他の case がブロックするので default が実行される\n\t\tfmt.Println(\"送信失敗 (ブロックするため)\")\n\t}\n\n\t// 受信を試みる (ノンブロッキング)\n\t// この時点でも受信できないので default が実行される\n\tselect {\n\tcase msg := <-messages:\n\t\tfmt.Println(\"受信:\", msg)\n\tdefault:\n\t\tfmt.Println(\"再度受信試行: 受信メッセージなし\")\n\t}\n}",
        "tags": [
          "concurrency",
          "channel",
          "goroutine",
          "select",
          "default",
          "ノンブロッキング"
        ]
      },
      {
        "title": "並行処理: 共有メモリの保護 (`sync.Mutex`)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nvar mu sync.Mutex // 共有カウンターを保護する Mutex\n\n// Mutex を使って安全にカウンターをインクリメント\nfunc safeIncrement(wg *sync.WaitGroup, counter *int) {\n\tdefer wg.Done()\n\n\tmu.Lock() // ロック獲得\n\t// ★ defer で必ず Unlock する\n\tdefer mu.Unlock()\n\n\t// Lock と Unlock の間は一度に1つの Goroutine のみ実行可能\n\t*counter = *counter + 1\n}\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\titerations := 1000\n\tsafeCounter := 0\n\n\tfmt.Println(\"--- Mutex あり ---\")\n\twg.Add(iterations)\n\tfor i := 0; i < iterations; i++ {\n\t\tgo safeIncrement(&wg, &safeCounter)\n\t}\n\twg.Wait()\n\t// 常に期待値になる\n\tfmt.Printf(\"最終カウンター: %d (期待値: %d)\\n\", safeCounter, iterations)\n\n\t// 競合検出: go run -race main.go\n}",
        "tags": [
          "concurrency",
          "goroutine",
          "sync",
          "Mutex",
          "相互排他ロック",
          "競合状態",
          "Race Condition",
          "Lock",
          "Unlock",
          "defer"
        ]
      },
      {
        "title": "並行処理: 読み取り/書き込みロック (`sync.RWMutex`)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\nvar config = make(map[string]string)\nvar rwmu sync.RWMutex // 読み取り/書き込みロック\n\n// 読み取り (RLock/RUnlock)\nfunc getConfig(key string, wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\trwmu.RLock() // 読み取りロック獲得\n\tdefer rwmu.RUnlock() // 必ず解放\n\n\tvalue := config[key]\n\tfmt.Printf(\"Reader: Read '%s' -> '%s'\\n\", key, value)\n\ttime.Sleep(50 * time.Millisecond)\n}\n\n// 書き込み (Lock/Unlock)\nfunc setConfig(key, value string, wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\trwmu.Lock() // 書き込みロック獲得 (排他的)\n\tdefer rwmu.Unlock() // 必ず解放\n\n\tfmt.Printf(\"Writer: Set '%s' = '%s'\\n\", key, value)\n\tconfig[key] = value\n\ttime.Sleep(100 * time.Millisecond)\n}\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\n\t// 初期設定 (書き込み)\n\twg.Add(1); go setConfig(\"key1\", \"val1\", &wg); wg.Wait()\n\n\t// 複数リーダーと1ライター起動\n\tfor i := 0; i < 3; i++ { wg.Add(1); go getConfig(\"key1\", &wg) }\n\ttime.Sleep(10 * time.Millisecond)\n\twg.Add(1); go setConfig(\"key1\", \"val2\", &wg)\n\tfor i := 0; i < 2; i++ { wg.Add(1); go getConfig(\"key1\", &wg) }\n\n\twg.Wait() // 全て完了を待つ\n\tfmt.Println(\"Final key1:\", config[\"key1\"]) // val2\n}",
        "tags": [
          "concurrency",
          "goroutine",
          "sync",
          "RWMutex",
          "Mutex",
          "読み取りロック",
          "書き込みロック",
          "競合状態",
          "パフォーマンス"
        ]
      },
      {
        "title": "並行処理: 一度だけの実行 (`sync.Once`)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\nvar config map[string]string\nvar loadConfigOnce sync.Once // ★ sync.Once 変数\n\n// 設定読み込み関数 (一度だけ実行される)\nfunc loadConfig() {\n\tfmt.Println(\"--- 設定読み込み実行 ---\")\n\ttime.Sleep(100 * time.Millisecond) // 時間がかかる処理を模倣\n\tconfig = map[string]string{\"apiKey\": \"xyz\"}\n\tfmt.Println(\"--- 設定読み込み完了 ---\")\n}\n\n// 設定取得関数 (必要なら初期化)\nfunc getConfig(key string, wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\t// ★ Do メソッドで loadConfig を呼び出す\n\t//   最初の呼び出し時のみ loadConfig が実行される\n\tloadConfigOnce.Do(loadConfig)\n\n\t// Do の後では config は初期化済み\n\tvalue := config[key]\n\tfmt.Printf(\"Goroutine: Get '%s' -> '%s'\\n\", key, value)\n}\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\tnumGoroutines := 3\n\twg.Add(numGoroutines)\n\tfor i := 0; i < numGoroutines; i++ {\n\t\tgo getConfig(\"apiKey\", &wg) // 複数 Goroutine から呼び出し\n\t}\n\twg.Wait()\n\tfmt.Println(\"初回取得完了\")\n\n\t// 再度呼び出しても loadConfig は実行されない\n\twg.Add(1); go getConfig(\"apiKey\", &wg); wg.Wait()\n}",
        "tags": [
          "concurrency",
          "goroutine",
          "sync",
          "Once",
          "初期化",
          "シングルトン",
          "Do"
        ]
      },
      {
        "title": "\"並行処理: sync.WaitGroup (再確認)\"",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc task(id int, wg *sync.WaitGroup) {\n\tdefer wg.Done() // タスク完了時にカウンターを減らす\n\tfmt.Printf(\"タスク %d: 開始\\n\", id)\n\ttime.Sleep(time.Duration(id) * 100 * time.Millisecond) // 処理をシミュレート\n\tfmt.Printf(\"タスク %d: 完了\\n\", id)\n}\n\nfunc main() {\n\tvar wg sync.WaitGroup // WaitGroup を宣言\n\n\tnumTasks := 3\n\tfmt.Printf(\"%d 個のタスクを Goroutine で実行します...\\n\", numTasks)\n\n\twg.Add(numTasks) // 待機する Goroutine の数を設定\n\n\t// Goroutine を起動\n\tgo task(1, &wg)\n\tgo task(2, &wg)\n\tgo task(3, &wg)\n\n\tfmt.Println(\"すべてのタスクの完了を待機します...\")\n\twg.Wait() // カウンターが 0 になるまで待機\n\n\tfmt.Println(\"すべてのタスクが完了しました。\")\n}\n\n/* 実行結果の例 (Goroutine の実行順序により多少前後する可能性あり):\n3 個のタスクを Goroutine で実行します...\nすべてのタスクの完了を待機します...\nタスク 1: 開始\nタスク 2: 開始\nタスク 3: 開始\nタスク 1: 完了\nタスク 2: 完了\nタスク 3: 完了\nすべてのタスクが完了しました。\n*/",
        "tags": [
          "concurrency",
          "goroutine",
          "sync",
          "WaitGroup",
          "同期",
          "Add",
          "Done",
          "Wait"
        ]
      },
      {
        "title": "並行処理: 条件変数 (`sync.Cond`)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\nvar (\n\tdata      string\n\tdataMutex sync.Mutex\n\tdataCond  = sync.NewCond(&dataMutex) // Mutex に関連付け\n\twg        sync.WaitGroup\n)\n\n// 消費者: データが準備されるのを待つ\nfunc consumer() {\n\tdefer wg.Done()\n\tfmt.Println(\"Consumer: 待機開始\")\n\tdataCond.L.Lock() // ロック取得\n\tfor data == \"\" { // ★ 条件チェックループ\n\t\tfmt.Println(\"Consumer: Wait...\")\n\t\tdataCond.Wait() // アンロックして待機、起こされたら再ロック\n\t}\n\tfmt.Printf(\"Consumer: データ受信 '%s'\\n\", data)\n\tdataCond.L.Unlock() // ロック解放\n}\n\n// 生産者: データを準備して通知\nfunc producer() {\n\tdefer wg.Done()\n\tfmt.Println(\"Producer: 準備開始\")\n\ttime.Sleep(100 * time.Millisecond) // 準備時間\n\tdataCond.L.Lock() // ロック取得\n\tdata = \"準備完了データ\"\n\tfmt.Println(\"Producer: 準備完了、Signal 送信\")\n\tdataCond.Signal() // 待機中の Goroutine を1つ起こす\n\tdataCond.L.Unlock() // ロック解放\n}\n\nfunc main() {\n\twg.Add(2)\n\tgo consumer()\n\ttime.Sleep(10 * time.Millisecond) // consumer が先に Wait するように\n\tgo producer()\n\twg.Wait()\n\tfmt.Println(\"完了\")\n}",
        "tags": [
          "concurrency",
          "goroutine",
          "sync",
          "Cond",
          "Mutex",
          "条件変数",
          "待機",
          "通知",
          "Wait",
          "Signal",
          "Broadcast"
        ]
      },
      {
        "title": "並行処理: アトミック操作 (`sync/atomic` パッケージ)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"sync/atomic\" // atomic パッケージ\n)\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\tvar counter atomic.Int64 // ★ atomic.Int64 で宣言\n\titerations := 1000\n\n\twg.Add(iterations)\n\tfor i := 0; i < iterations; i++ {\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\t// ★ Add メソッドでアトミックにインクリメント\n\t\t\tcounter.Add(1)\n\t\t}()\n\t}\n\twg.Wait()\n\n\t// ★ Load メソッドでアトミックに読み取り\n\tfinalCount := counter.Load()\n\tfmt.Printf(\"最終カウンター: %d\\n\", finalCount) // 常に 1000\n}",
        "tags": [
          "concurrency",
          "goroutine",
          "sync",
          "atomic",
          "アトミック操作",
          "競合状態",
          "低レベル同期",
          "Go1.19"
        ]
      },
      {
        "title": "\"並行処理: アトミック操作 (Go 1.19 未満の古い方法)\"",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"sync/atomic\" // atomic パッケージをインポート\n)\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\tvar counter int64 // ★ 通常の int64 型で宣言\n\titerations := 1000\n\n\tfmt.Printf(\"%d 回インクリメントします...\\n\", iterations)\n\n\twg.Add(iterations)\n\tfor i := 0; i < iterations; i++ {\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\t// ★ atomic.AddInt64 でアトミックにインクリメント ★\n\t\t\t// 第一引数にはカウンター変数のポインタ (&counter) を渡す\n\t\t\tatomic.AddInt64(&counter, 1)\n\t\t}()\n\t}\n\n\twg.Wait() // すべての Goroutine が完了するのを待つ\n\n\t// ★ atomic.LoadInt64 でアトミックに値を読み取る ★\n\t// 第一引数にはカウンター変数のポインタ (&counter) を渡す\n\tfinalCount := atomic.LoadInt64(&counter)\n\tfmt.Printf(\"最終カウンター: %d (期待値: %d)\\n\", finalCount, iterations)\n\n\t// --- その他の操作例 ---\n\tfmt.Println(\"\\n--- その他の操作 ---\")\n\n\t// CompareAndSwap: 現在値が 1000 なら 0 にする\n\tswapped := atomic.CompareAndSwapInt64(&counter, 1000, 0)\n\tfmt.Printf(\"CompareAndSwapInt64(1000, 0): %t, 現在値: %d\\n\", swapped, atomic.LoadInt64(&counter))\n\n\t// Swap: 現在値を 500 に設定し、古い値を取得\n\toldValue := atomic.SwapInt64(&counter, 500)\n\tfmt.Printf(\"SwapInt64(500): 古い値=%d, 現在値: %d\\n\", oldValue, atomic.LoadInt64(&counter))\n\n\t// Store: 現在値を -100 に設定\n\tatomic.StoreInt64(&counter, -100)\n\tfmt.Printf(\"StoreInt64(-100): 現在値: %d\\n\", atomic.LoadInt64(&counter))\n}\n\n/* 実行結果:\n1000 回インクリメントします...\n最終カウンター: 1000 (期待値: 1000)\n\n--- その他の操作 ---\nCompareAndSwapInt64(1000, 0): true, 現在値: 0\nSwapInt64(500): 古い値=0, 現在値: 500\nStoreInt64(-100): 現在値: -100\n*/",
        "tags": [
          "concurrency",
          "goroutine",
          "sync",
          "atomic",
          "アトミック操作",
          "競合状態",
          "低レベル同期"
        ]
      },
      {
        "title": "並行処理: アトミックポインタ (`atomic.Pointer[T]`, Go 1.19+)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"sync/atomic\"\n)\n\ntype Config struct { Version string; APIKey string }\n\n// Config へのポインタをアトミックに保持\nvar currentConfig atomic.Pointer[Config]\n\n// 設定読み取り (アトミックにポインタ取得)\nfunc configReader(id int, wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\tcfg := currentConfig.Load() // アトミックにポインタ取得\n\tif cfg != nil {\n\t\tfmt.Printf(\"Reader %d: Read Ver='%s'\\n\", id, cfg.Version)\n\t} else {\n\t\tfmt.Printf(\"Reader %d: Config nil\\n\", id)\n\t}\n}\n\n// 設定更新 (アトミックにポインタ設定)\nfunc configUpdater(newCfg *Config, wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\tfmt.Printf(\"Updater: Set Ver='%s'\\n\", newCfg.Version)\n\tcurrentConfig.Store(newCfg) // アトミックにポインタ設定\n\t// ok := currentConfig.CompareAndSwap(oldCfg, newCfg) // CASも可能\n}\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\tinitialCfg := &Config{Version: \"v1\"}\n\tcurrentConfig.Store(initialCfg) // 初期設定\n\n\twg.Add(2)\n\tgo configReader(1, &wg)\n\tgo configUpdater(&Config{Version: \"v2\"}, &wg)\n\twg.Wait()\n\n\tfinalCfg := currentConfig.Load()\n\tfmt.Printf(\"Final Version: %s\\n\", finalCfg.Version) // v2\n}",
        "tags": [
          "concurrency",
          "goroutine",
          "sync",
          "atomic",
          "Pointer",
          "アトミック操作",
          "ポインタ",
          "型安全",
          "Go1.19"
        ]
      },
      {
        "title": "並行処理: Context の生成 (`context` パッケージ)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\ntype contextKey string // Value 用のキー型\nconst userIDKey contextKey = \"userID\"\n\nfunc main() {\n\t// 1. ルート Context (通常 Background を使う)\n\tctxBg := context.Background()\n\tfmt.Println(\"1. Background:\", ctxBg)\n\t// ctxTodo := context.TODO() // 未定の場合のプレースホルダー\n\n\t// 2. キャンセル可能 Context\n\tctxCancel, cancelFunc := context.WithCancel(ctxBg)\n\tdefer cancelFunc() // ★ 必ず cancel を呼ぶ\n\tfmt.Println(\"2. WithCancel:\", ctxCancel)\n\t// cancelFunc() // 呼ぶとキャンセルされる\n\n\t// 3. タイムアウト付き Context\n\tctxTimeout, cancelTimeout := context.WithTimeout(ctxBg, 100*time.Millisecond)\n\tdefer cancelTimeout() // ★ 必ず cancel を呼ぶ\n\tfmt.Println(\"3. WithTimeout:\", ctxTimeout)\n\n\t// 4. 値付き Context\n\tctxValue := context.WithValue(ctxBg, userIDKey, \"user-123\")\n\tfmt.Println(\"4. WithValue:\", ctxValue)\n\tretrieved := ctxValue.Value(userIDKey)\n\tfmt.Printf(\"   Value: %v (%T)\\n\", retrieved, retrieved)\n}",
        "tags": [
          "concurrency",
          "goroutine",
          "context",
          "Background",
          "TODO",
          "WithCancel",
          "WithTimeout",
          "WithDeadline",
          "WithValue",
          "キャンセル",
          "タイムアウト"
        ]
      },
      {
        "title": "並行処理: Context による値の伝達 (`context.WithValue`)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// Context キー用の独自型\ntype contextKey string\nconst requestIDKey contextKey = \"requestID\"\n\n// ミドルウェア: Context にリクエストIDを追加\nfunc addRequestID(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\treqID := \"req-123\" // 簡単な例\n\t\t// ★ WithValue で Context に値を追加\n\t\tctxWithID := context.WithValue(r.Context(), requestIDKey, reqID)\n\t\t// ★ 新しい Context を持つリクエストで次を呼び出す\n\t\tnext.ServeHTTP(w, r.WithContext(ctxWithID))\n\t})\n}\n\n// ハンドラ: Context からリクエストIDを取得\nfunc myHandler(w http.ResponseWriter, r *http.Request) {\n\t// ★ r.Context() で Context を取得\n\tctx := r.Context()\n\t// ★ Value() と型アサーションで値を取得\n\treqID, ok := ctx.Value(requestIDKey).(string)\n\tif !ok { reqID = \"unknown\" }\n\n\tfmt.Printf(\"[%s] ハンドラ処理\\n\", reqID)\n\tfmt.Fprintf(w, \"[%s] 完了\", reqID)\n\t// processData(ctx) // 後続処理にも ctx を渡せる\n}\n\nfunc main() {\n\thandlerWithMiddleware := addRequestID(http.HandlerFunc(myHandler))\n\thttp.Handle(\"/data\", handlerWithMiddleware)\n\tfmt.Println(\"Listening on :8080...\")\n\t// http.ListenAndServe(\":8080\", nil) // サーバー起動 (実行は省略)\n}",
        "tags": [
          "concurrency",
          "goroutine",
          "context",
          "WithValue",
          "Value",
          "リクエストスコープ",
          "値伝達"
        ]
      },
      {
        "title": "並行処理: Context を使ったキャンセル処理 (`ctx.Done()`, `ctx.Err()`)",
        "description": "**`context`** パッケージの主な目的は、処理の**キャンセル**や\n**タイムアウト/デッドライン**のシグナルを伝達することです。\nこれにより不要な処理を早期中断できます。\n\n**Context の受け渡し規約:**\nContext を利用する関数は、通常、**第一引数**として\n`ctx context.Context` を受け取るのが Go の慣習です。\n`func DoSomething(ctx context.Context, ...) error`\n\n**キャンセルの検知: `ctx.Done()` と `select`**\n`ctx.Done()` メソッドは受信専用チャネル (`<-chan struct{}`) を返します。\nこのチャネルは Context が**キャンセルされるとクローズ**されます。\n`select` 文でこのチャネルからの受信を待つことでキャンセルを検知できます。",
        "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\n// Context を受け取り、キャンセルをチェックする関数\nfunc longRunningTask(ctx context.Context, taskID int) error {\n\tfmt.Printf(\"Task %d: 開始\\n\", taskID)\n\tfor i := 0; i < 5; i++ {\n\t\tselect {\n\t\tcase <-ctx.Done(): // ★ Done() チャネルでキャンセルを検知\n\t\t\tfmt.Printf(\"Task %d: キャンセル (%v)\\n\", taskID, ctx.Err())\n\t\t\treturn ctx.Err() // キャンセル理由を返す\n\t\tcase <-time.After(200 * time.Millisecond): // 処理/待機を模倣\n\t\t\tfmt.Printf(\"Task %d: Step %d\\n\", taskID, i+1)\n\t\t}\n\t}\n\tfmt.Printf(\"Task %d: 正常終了\\n\", taskID)\n\treturn nil\n}\n\nfunc main() {\n\t// タイムアウト (500ms) 付き Context を作成\n\tctxTimeout, cancel := context.WithTimeout(context.Background(), 500*time.Millisecond)\n\tdefer cancel() // ★ cancel 関数を必ず呼ぶ\n\n\t// タスク実行 (1000ms かかるはず)\n\terr := longRunningTask(ctxTimeout, 1)\n\tif err != nil {\n\t\tfmt.Printf(\"Main: エラー: %v\\n\", err) // context deadline exceeded\n\t}\n}",
        "tags": [
          "concurrency",
          "goroutine",
          "context",
          "Done",
          "Err",
          "select",
          "キャンセル",
          "タイムアウト",
          "デッドライン"
        ]
      },
      {
        "title": "並行処理: Context による明示的なキャンセル",
        "description": "",
        "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\n// キャンセルされるまで作業するワーカー\nfunc worker(ctx context.Context, id int, wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\tfmt.Printf(\"Worker %d: 開始\\n\", id)\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done(): // ★ キャンセルを検知\n\t\t\tfmt.Printf(\"Worker %d: キャンセル (%v)\\n\", id, ctx.Err())\n\t\t\treturn\n\t\tcase <-time.After(150 * time.Millisecond): // 作業模倣\n\t\t\tfmt.Printf(\"Worker %d: 動作中...\\n\", id)\n\t\t}\n\t}\n}\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\n\t// キャンセル可能なルート Context と cancel 関数を作成\n\tctx, cancelAll := context.WithCancel(context.Background())\n\tdefer cancelAll() // ★ main 終了時に必ず cancel を呼ぶ\n\n\tnumWorkers := 2\n\twg.Add(numWorkers)\n\tfor i := 1; i <= numWorkers; i++ {\n\t\tgo worker(ctx, i, &wg) // 同じ ctx を渡す\n\t}\n\n\ttime.Sleep(400 * time.Millisecond) // しばらく実行\n\n\tfmt.Println(\"\\nMain: キャンセル実行 (cancelAll)\")\n\tcancelAll() // ★ これで全ワーカーにキャンセルが伝播\n\n\twg.Wait() // 全ワーカーの終了を待つ\n\tfmt.Println(\"Main: 全ワーカー終了\")\n}",
        "tags": [
          "concurrency",
          "goroutine",
          "context",
          "WithCancel",
          "cancel",
          "キャンセル",
          "伝播"
        ]
      }
    ]
  },
  {
    "title": "Context",
    "codeExamples": [
      {
        "title": "Context パッケージ: 概要",
        "description": "",
        "code": "package context // (実際には組み込み)\n\nimport \"time\"\n\n// Context インターフェース定義\ntype Context interface {\n\tDeadline() (deadline time.Time, ok bool)\n\tDone() <-chan struct{}\n\tErr() error\n\tValue(key any) any\n}",
        "tags": [
          "context",
          "concurrency",
          "キャンセル",
          "タイムアウト",
          "デッドライン",
          "値伝達",
          "リクエストスコープ"
        ]
      },
      {
        "title": "\"Context パッケージ: 基本的な Context の生成\"",
        "description": "すべての `context.Context` は、2つの基本的な Context のいずれかから派生します。これらの基本的な Context は `context` パッケージによって提供されます。\n\nこれらの基本的な Context と、そこから派生 Context を生成する方法については、**「並行処理」**セクションの**「Context の生成 (`context` パッケージ)」** (`090_concurrency/190_creating-contexts.md`) で既に説明しました。\n\nここでは、その要点を再確認します。\n\n## `context.Background()`\n\n*   **役割:** 通常、Context ツリーの**ルート**として使用されます。`main` 関数や、リクエスト処理の起点となる場所で最初に生成します。\n*   **特性:**\n    *   キャンセルされることはありません (`Done()` は `nil` チャネルを返します)。\n    *   値を持っていません (`Value()` は常に `nil` を返します)。\n    *   デッドラインを持っていません (`Deadline()` は `ok == false` を返します)。\n\n## `context.TODO()`\n\n*   **役割:** `Background()` と機能的には同じですが、どの Context を使うべきか**まだ明確でない**場合や、既存のコードが Context を受け取るように**まだ更新されていない**場合に、**一時的なプレースホルダー**として使用します。\n*   **意図:** 静的解析ツールなどで `context.TODO()` の使用箇所を検出し、将来的に適切な Context を渡すようにリファクタリングを促すことを意図しています。\n*   **特性:** `Background()` と同じく、キャンセルされず、値もデッドラインも持ちません。\n\n**原則として、Context ツリーの起点には `context.Background()` を使い、`context.TODO()` は一時的な代替としてのみ使用し、最終的には適切な Context に置き換えるべきです。**\n\n**参考コード (context.TODO):**",
        "code": "import \"context\"\n\n// main 関数や初期化処理でルート Context を生成\nctx := context.Background()\n\n// この ctx を基にして、WithCancel, WithTimeout などで子 Context を作成していく",
        "tags": [
          "context",
          "concurrency",
          "Background",
          "TODO"
        ]
      },
      {
        "title": "Context パッケージ: Context の受け渡し規約",
        "description": "",
        "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\n// 下位関数: Context を受け取りキャンセルをチェック\nfunc queryDatabase(ctx context.Context, query string) (string, error) {\n\tfmt.Printf(\" DB Query: '%s'\\n\", query)\n\tselect {\n\tcase <-time.After(100 * time.Millisecond): // 処理模倣\n\t\tfmt.Printf(\" Query OK: '%s'\\n\", query)\n\t\treturn \"data\", nil\n\tcase <-ctx.Done(): // ★ キャンセルチェック\n\t\tfmt.Printf(\" Query Cancelled: '%s' (%v)\\n\", query, ctx.Err())\n\t\treturn \"\", ctx.Err()\n\t}\n}\n\n// 上位関数: Context を受け取り下位関数に渡す\nfunc handleRequest(ctx context.Context, requestData string) error {\n\tfmt.Println(\"Request Handling Start\")\n\t// ★ 下位関数に ctx をそのまま渡す\n\tresult, err := queryDatabase(ctx, \"find:\"+requestData)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"request failed: %w\", err)\n\t}\n\tfmt.Printf(\"Result: %s\\n\", result)\n\treturn nil\n}\n\n// main (呼び出し元)\n// func main() {\n// \tctx := context.Background()\n// \tctxTimeout, cancel := context.WithTimeout(ctx, 50*time.Millisecond)\n// \tdefer cancel()\n// \thandleRequest(ctxTimeout, \"some-data\") // Context を渡す\n// }",
        "tags": [
          "context",
          "concurrency",
          "規約",
          "関数シグネチャ",
          "第一引数"
        ]
      },
      {
        "title": "\"Context パッケージ: Context の伝播\"",
        "description": "",
        "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\n// 下位の関数: Context を受け取る\nfunc queryDatabase(ctx context.Context, query string) (string, error) {\n\tfmt.Printf(\"データベースクエリ '%s' を実行中...\\n\", query)\n\tselect {\n\tcase <-time.After(100 * time.Millisecond):\n\t\tfmt.Printf(\"クエリ '%s' 成功\\n\", query)\n\t\treturn \"結果データ\", nil\n\tcase <-ctx.Done(): // ★ 上位から渡された Context のキャンセルをチェック\n\t\tfmt.Printf(\"クエリ '%s' はキャンセルされました: %v\\n\", query, ctx.Err())\n\t\treturn \"\", ctx.Err()\n\t}\n}\n\n// 上位の関数: Context を受け取り、下位の関数にそのまま渡す\nfunc handleRequest(ctx context.Context, requestData string) error {\n\tfmt.Println(\"リクエスト処理開始\")\n\t// ★ 受け取った ctx をそのまま queryDatabase に渡す ★\n\tresult, err := queryDatabase(ctx, fmt.Sprintf(\"SELECT data WHERE id='%s'\", requestData))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"リクエスト処理失敗: %w\", err)\n\t}\n\tfmt.Printf(\"取得結果: %s\\n\", result)\n\tfmt.Println(\"リクエスト処理完了\")\n\treturn nil\n}\n\nfunc main() {\n\t// タイムアウト付き Context を作成\n\tctxWithTimeout, cancel := context.WithTimeout(context.Background(), 50*time.Millisecond)\n\tdefer cancel()\n\n\t// handleRequest にタイムアウト付き Context を渡す\n\t// handleRequest はそれを queryDatabase に渡す\n\t// タイムアウト (50ms) がクエリの実行時間 (100ms) より短いため、キャンセルされる\n\terr := handleRequest(ctxWithTimeout, \"data1\")\n\tif err != nil {\n\t\tfmt.Println(\"エラー:\", err)\n\t}\n}\n\n/* 実行結果:\nリクエスト処理開始\nデータベースクエリ 'SELECT data WHERE id='data1'' を実行中...\nクエリ 'SELECT data WHERE id='data1'' はキャンセルされました: context deadline exceeded\nエラー: リクエスト処理失敗: クエリ 'SELECT data WHERE id='data1'' はキャンセルされました: context deadline exceeded\n*/",
        "tags": [
          "context",
          "concurrency",
          "関数呼び出し",
          "伝播"
        ]
      },
      {
        "title": "Context パッケージ: キャンセル可能な Context の生成 (`WithCancel`)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\n// キャンセルされるまで待機するワーカー\nfunc watch(ctx context.Context, name string, wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\tfmt.Printf(\"%s: 開始\\n\", name)\n\tselect {\n\tcase <-ctx.Done(): // キャンセルを待つ\n\t\tfmt.Printf(\"%s: キャンセル (%v)\\n\", name, ctx.Err())\n\t}\n}\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\trootCtx := context.Background()\n\n\t// キャンセル可能な Context を作成\n\tctx1, cancel1 := context.WithCancel(rootCtx)\n\tdefer cancel1() // ★ 必ず cancel を呼ぶ\n\n\twg.Add(1)\n\tgo watch(ctx1, \"Watcher 1\", &wg) // ctx1 を渡す\n\n\t// (ctx1 から派生した ctx2 を作成し、別の Goroutine に渡すことも可能)\n\t// ctx2, cancel2 := context.WithCancel(ctx1)\n\t// defer cancel2()\n\t// go watch(ctx2, \"Watcher 2\", &wg)\n\n\ttime.Sleep(100 * time.Millisecond)\n\n\tfmt.Println(\"main: cancel1() 呼び出し...\")\n\tcancel1() // ★ ctx1 をキャンセル (派生した ctx2 もキャンセルされる)\n\n\twg.Wait() // Goroutine の終了を待つ\n\tfmt.Println(\"main: 終了\")\n}",
        "tags": [
          "context",
          "concurrency",
          "WithCancel",
          "cancel",
          "キャンセル"
        ]
      },
      {
        "title": "\"Context パッケージ: キャンセルへの応答 (`ctx.Done()`)\"",
        "description": "",
        "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\n// 時間のかかる処理をシミュレートする関数 (再掲)\nfunc longRunningTask(ctx context.Context, taskID int) error {\n\tfmt.Printf(\"タスク %d: 開始\\n\", taskID)\n\tticker := time.NewTicker(100 * time.Millisecond) // 定期的な処理を模倣\n\tdefer ticker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done(): // ★ Context のキャンセルをチェック\n\t\t\tfmt.Printf(\"タスク %d: キャンセル検知 (%v)\\n\", taskID, ctx.Err())\n\t\t\treturn ctx.Err() // キャンセル理由を返す\n\t\tcase t := <-ticker.C: // ★ 通常の処理 (例: 100ms ごと)\n\t\t\tfmt.Printf(\"タスク %d: 実行中 at %v\\n\", taskID, t.Format(\"15:04:05.000\"))\n\t\t\t// ここで実際の処理を行う\n\t\t\t// もしこの処理が非常に長い場合は、さらに内部で ctx.Done() をチェックすることも検討\n\t\t}\n\t}\n}\n\nfunc main() {\n\t// キャンセル可能な Context を作成\n\tctx, cancel := context.WithCancel(context.Background())\n\n\t// Goroutine でタスクを開始\n\tgo longRunningTask(ctx, 1)\n\n\t// 500ms 後にキャンセル\n\ttime.Sleep(500 * time.Millisecond)\n\tfmt.Println(\"main: キャンセル実行！\")\n\tcancel()\n\n\t// Goroutine が終了するのを少し待つ\n\ttime.Sleep(100 * time.Millisecond)\n\tfmt.Println(\"main: 終了\")\n}\n\n/* 実行結果の例 (時刻は実行時に依存):\nタスク 1: 開始\nタスク 1: 実行中 at 01:50:00.100\nタスク 1: 実行中 at 01:50:00.200\nタスク 1: 実行中 at 01:50:00.300\nタスク 1: 実行中 at 01:50:00.400\nタスク 1: 実行中 at 01:50:00.500\nmain: キャンセル実行！\nタスク 1: キャンセル検知 (context canceled)\nmain: 終了\n*/",
        "tags": [
          "context",
          "concurrency",
          "goroutine",
          "Done",
          "select",
          "キャンセル"
        ]
      },
      {
        "title": "Context パッケージ: ワーカーパターンにおけるキャンセル",
        "description": "",
        "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Task int\ntype Result int\n\n// ワーカー: Context を受け取り、キャンセルを監視\nfunc worker(ctx context.Context, id int, tasks <-chan Task, results chan<- Result, wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\tfmt.Printf(\"Worker %d: Start\\n\", id)\n\tfor {\n\t\tselect {\n\t\tcase task, ok := <-tasks:\n\t\t\tif !ok { return } // タスクチャネル close\n\t\t\tfmt.Printf(\"Worker %d: Task %d Process...\\n\", id, task)\n\t\t\ttime.Sleep(100 * time.Millisecond) // 処理模倣\n\t\t\tresults <- Result(task * 10)\n\t\tcase <-ctx.Done(): // ★ キャンセル検知\n\t\t\tfmt.Printf(\"Worker %d: Cancelled (%v)\\n\", id, ctx.Err())\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc main() {\n\ttasks := make(chan Task, 5)\n\tresults := make(chan Result, 5)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel() // main 終了時にキャンセル\n\tvar wg sync.WaitGroup\n\n\t// ワーカー起動\n\tfor w := 1; w <= 3; w++ {\n\t\twg.Add(1)\n\t\tgo worker(ctx, w, tasks, results, &wg) // ctx を渡す\n\t}\n\n\t// タスク送信\n\tfor j := 1; j <= 5; j++ { tasks <- Task(j) }\n\tclose(tasks) // タスク送信完了 -> ワーカーはタスクを終えたら終了できる\n\n\t// 途中でキャンセルする場合 (例)\n\t// time.Sleep(150 * time.Millisecond)\n\t// fmt.Println(\">>> Cancelling...\")\n\t// cancel() // これで全ワーカーにキャンセルが伝播\n\n\twg.Wait() // 全ワーカー終了待機\n\tclose(results) // 結果チャネルをクローズ\n\tfmt.Println(\"All workers done.\")\n\t// 結果収集 (省略)\n\t// for res := range results { fmt.Println(\"Result:\", res) }\n}",
        "tags": [
          "context",
          "concurrency",
          "goroutine",
          "worker pool",
          "select",
          "Done",
          "キャンセル"
        ]
      },
      {
        "title": "Context パッケージ: タイムアウト付き Context (`WithTimeout`)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\n// Context のキャンセルをチェックする関数\nfunc simulateWork(ctx context.Context, duration time.Duration) error {\n\tfmt.Printf(\"作業開始 (最大 %v)\\n\", duration)\n\tselect {\n\tcase <-time.After(duration): // 処理模倣\n\t\tfmt.Println(\"作業完了\")\n\t\treturn nil\n\tcase <-ctx.Done(): // ★ タイムアウト/キャンセル検知\n\t\tfmt.Printf(\"作業キャンセル: %v\\n\", ctx.Err())\n\t\treturn ctx.Err()\n\t}\n}\n\nfunc main() {\n\t// 500ms でタイムアウトする Context を作成\n\tctx, cancel := context.WithTimeout(context.Background(), 500*time.Millisecond)\n\tdefer cancel() // ★ 必ず cancel を呼ぶ\n\n\t// 1秒かかる処理を実行 -> タイムアウトするはず\n\terr := simulateWork(ctx, 1*time.Second)\n\tif err != nil {\n\t\tfmt.Printf(\"エラー: %v\\n\", err) // context deadline exceeded\n\t}\n}",
        "tags": [
          "context",
          "concurrency",
          "WithTimeout",
          "cancel",
          "タイムアウト",
          "デッドライン"
        ]
      },
      {
        "title": "Context パッケージ: デッドライン付き Context (`WithDeadline`)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\n// Context のキャンセルをチェックする関数\nfunc simulateWork(ctx context.Context, duration time.Duration) error {\n\tfmt.Printf(\"作業開始 (最大 %v)\\n\", duration)\n\tselect {\n\tcase <-time.After(duration): // 処理模倣\n\t\tfmt.Println(\"作業完了\")\n\t\treturn nil\n\tcase <-ctx.Done(): // ★ デッドライン超過/キャンセル検知\n\t\tfmt.Printf(\"作業キャンセル: %v\\n\", ctx.Err())\n\t\treturn ctx.Err()\n\t}\n}\n\nfunc main() {\n\t// 500ms 後をデッドラインとして設定\n\tdeadline := time.Now().Add(500 * time.Millisecond)\n\tctx, cancel := context.WithDeadline(context.Background(), deadline)\n\tdefer cancel() // ★ 必ず cancel を呼ぶ\n\n\t// 1秒かかる処理を実行 -> デッドラインを超えるはず\n\terr := simulateWork(ctx, 1*time.Second)\n\tif err != nil {\n\t\tfmt.Printf(\"エラー: %v\\n\", err) // context deadline exceeded\n\t}\n}",
        "tags": [
          "context",
          "concurrency",
          "WithDeadline",
          "cancel",
          "タイムアウト",
          "デッドライン"
        ]
      },
      {
        "title": "Context パッケージ: タイムアウト/デッドライン超過の確認",
        "description": "",
        "code": "package main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n)\n\n// Context のキャンセル理由を確認する関数\nfunc checkContextStatus(ctx context.Context, name string) {\n\tselect {\n\tcase <-ctx.Done(): // キャンセル待ち\n\t\terr := ctx.Err() // 理由を取得\n\t\tfmt.Printf(\"%s: Cancelled. Reason: %v\\n\", name, err)\n\t\t// 理由を判定\n\t\tif err == context.DeadlineExceeded { // または errors.Is\n\t\t\tfmt.Printf(\"   -> %s: Timeout/Deadline\\n\", name)\n\t\t} else if err == context.Canceled { // または errors.Is\n\t\t\tfmt.Printf(\"   -> %s: Explicit Cancel\\n\", name)\n\t\t}\n\tcase <-time.After(1 * time.Second): // タイムアウト待ち (デモ用)\n\t\tfmt.Printf(\"%s: Not cancelled within 1s\\n\", name)\n\t}\n}\n\nfunc main() {\n\t// タイムアウトケース\n\tctxTimeout, cancelT := context.WithTimeout(context.Background(), 50*time.Millisecond)\n\tdefer cancelT()\n\tcheckContextStatus(ctxTimeout, \"TimeoutCtx\")\n\n\t// 明示的キャンセルケース\n\tctxCancel, cancelC := context.WithCancel(context.Background())\n\tgo func() { time.Sleep(100 * time.Millisecond); cancelC() }()\n\tcheckContextStatus(ctxCancel, \"CancelCtx\")\n\n\t// ラップされたエラーの場合 (解説参照)\n\t// wrappedErr := fmt.Errorf(\"... %w\", ctx.Err())\n\t// if errors.Is(wrappedErr, context.DeadlineExceeded) { ... }\n}",
        "tags": [
          "context",
          "concurrency",
          "Err",
          "DeadlineExceeded",
          "Canceled",
          "errors.Is",
          "タイムアウト",
          "デッドライン"
        ]
      },
      {
        "title": "Context パッケージ: HTTP クライアントでのタイムアウト/キャンセル",
        "description": "",
        "code": "package main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n)\n\nfunc main() {\n\t// タイムアウト付き Context (例: 50ms)\n\trequestTimeout := 50 * time.Millisecond\n\tctx, cancel := context.WithTimeout(context.Background(), requestTimeout)\n\tdefer cancel() // ★ 必ず cancel を呼ぶ\n\n\t// Context 付きリクエスト作成\n\turl := \"https://example.com\"\n\treq, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)\n\tif err != nil { /* エラー処理 */ return }\n\n\tfmt.Printf(\"GET %s (Timeout: %v)...\\n\", url, requestTimeout)\n\n\t// リクエスト実行\n\tresp, err := http.DefaultClient.Do(req)\n\t// ★ エラーがあってもなくても resp.Body を閉じる必要あり\n\tif resp != nil {\n\t\tdefer resp.Body.Close()\n\t}\n\n\t// エラーチェック\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Request Error: %v\\n\", err)\n\t\t// タイムアウトかチェック\n\t\tif errors.Is(err, context.DeadlineExceeded) {\n\t\t\tfmt.Fprintln(os.Stderr, \"-> Timeout!\")\n\t\t}\n\t\treturn\n\t}\n\n\t// 成功時の処理 (例)\n\tfmt.Printf(\"Status: %s\\n\", resp.Status)\n\t// body, _ := io.ReadAll(resp.Body) // ボディ読み取りなど\n}",
        "tags": [
          "context",
          "concurrency",
          "net/http",
          "http client",
          "timeout",
          "deadline",
          "cancel",
          "NewRequestWithContext",
          "Do"
        ]
      },
      {
        "title": "Context パッケージ: データベース操作でのタイムアウト/キャンセル",
        "description": "",
        "code": "package main\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\t// _ \"github.com/mattn/go-sqlite3\" // 実際のドライバ\n)\n\n// ダミーのDBクエリ関数 (Context をチェック)\nfunc dummyQueryContext(ctx context.Context, db *sql.DB, query string) error {\n\tfmt.Printf(\"Query: %s\\n\", query)\n\tselect {\n\tcase <-time.After(200 * time.Millisecond): // 200ms かかると仮定\n\t\tfmt.Println(\" -> Query Success (Dummy)\")\n\t\t// _, err := db.QueryContext(ctx, query) // 実際の呼び出し\n\t\t// return err\n\t\treturn nil\n\tcase <-ctx.Done(): // Context キャンセルをチェック\n\t\tfmt.Printf(\" -> Query Cancelled: %v\\n\", ctx.Err())\n\t\treturn ctx.Err()\n\t}\n}\n\nfunc main() {\n\t// db, err := sql.Open(\"sqlite3\", \":memory:\") // 実際の接続例\n\tdb := &sql.DB{} // ダミー\n\t// if err != nil { log.Fatal(err) }\n\t// defer db.Close()\n\n\t// 100ms でタイムアウトする Context\n\tctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)\n\tdefer cancel()\n\n\t// QueryContext (を模倣した関数) を呼び出す\n\terr := dummyQueryContext(ctx, db, \"SELECT ...\")\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t\tif errors.Is(err, context.DeadlineExceeded) {\n\t\t\tfmt.Println(\"-> Timeout!\")\n\t\t}\n\t}\n}",
        "tags": [
          "context",
          "concurrency",
          "database/sql",
          "QueryContext",
          "ExecContext",
          "BeginTx",
          "PingContext",
          "timeout",
          "cancel"
        ]
      },
      {
        "title": "\"Context パッケージ: Context への値の追加 (`WithValue`)\"",
        "description": "",
        "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n)\n\n// キーとして使うための独自型\ntype contextKey string\n\nconst (\n\tuserIDKey    contextKey = \"userID\"\n\ttraceIDKey   contextKey = \"traceID\"\n\tsessionIDKey contextKey = \"sessionID\"\n)\n\nfunc main() {\n\t// 1. ベースとなる Context\n\tctx := context.Background()\n\tfmt.Printf(\"ベース Context: %v\\n\", ctx)\n\n\t// 2. userID を追加\n\tctx = context.WithValue(ctx, userIDKey, \"user-987\")\n\tfmt.Printf(\"userID 追加後: %v\\n\", ctx)\n\n\t// 3. traceID を追加 (前の Context を親にする)\n\tctx = context.WithValue(ctx, traceIDKey, \"trace-abc-123\")\n\tfmt.Printf(\"traceID 追加後: %v\\n\", ctx)\n\n\t// 4. sessionID を追加 (さらに親にする)\n\tctx = context.WithValue(ctx, sessionIDKey, \"sess-xyz-789\")\n\tfmt.Printf(\"sessionID 追加後: %v\\n\", ctx)\n\n\t// --- 値の取得 (後続のファイルで説明) ---\n\t// 値を取得するには ctx.Value(key) を使う\n\t// 例: userID := ctx.Value(userIDKey).(string)\n\t// 例: traceID := ctx.Value(traceIDKey).(string)\n\t// 例: sessionID := ctx.Value(sessionIDKey).(string)\n\t// 例: 존재하지 않는 키 -> nil\n\t// nonExistent := ctx.Value(contextKey(\"otherKey\"))\n\t// fmt.Printf(\"存在しないキーの値: %v (nil: %t)\\n\", nonExistent, nonExistent == nil)\n}\n\n/* 実行結果の例 (Context の文字列表現は内部詳細であり、変わりうる):\nベース Context: context.Background\nuserID 追加後: context.Background.WithValue(type main.contextKey, val user-987)\ntraceID 追加後: context.Background.WithValue(type main.contextKey, val user-987).WithValue(type main.contextKey, val trace-abc-123)\nsessionID 追加後: context.Background.WithValue(type main.contextKey, val user-987).WithValue(type main.contextKey, val trace-abc-123).WithValue(type main.contextKey, val sess-xyz-789)\n*/",
        "tags": [
          "context",
          "concurrency",
          "WithValue",
          "リクエストスコープ",
          "値伝達"
        ]
      },
      {
        "title": "\"Context パッケージ: Context からの値の取得 (`Value`)\"",
        "description": "",
        "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n)\n\n// キーとして使うための独自型 (再掲)\ntype contextKey string\n\nconst (\n\tuserIDKey    contextKey = \"userID\"\n\ttraceIDKey   contextKey = \"traceID\"\n\tsessionIDKey contextKey = \"sessionID\"\n)\n\n// Context を受け取り、値を表示する関数\nfunc processRequest(ctx context.Context) {\n\tfmt.Println(\"\\n--- processRequest ---\")\n\n\t// userID を取得\n\tuserIDValue := ctx.Value(userIDKey)\n\t// 型アサーション (カンマOKイディオム)\n\tuserID, ok := userIDValue.(string)\n\tif !ok {\n\t\tfmt.Println(\"userID が見つからないか、型が異なります。\")\n\t} else {\n\t\tfmt.Printf(\"取得した userID: %s\\n\", userID)\n\t}\n\n\t// traceID を取得\n\ttraceID, ok := ctx.Value(traceIDKey).(string)\n\tif !ok {\n\t\tfmt.Println(\"traceID が見つからないか、型が異なります。\")\n\t} else {\n\t\tfmt.Printf(\"取得した traceID: %s\\n\", traceID)\n\t}\n\n\t// 存在しないキーを試す\n\totherValue := ctx.Value(contextKey(\"otherKey\"))\n\tif otherValue == nil {\n\t\tfmt.Println(\"存在しないキー 'otherKey' の値は nil です。\")\n\t}\n}\n\nfunc main() {\n\t// 値を持つ Context を作成 (前のセクションの例)\n\tctx := context.Background()\n\tctx = context.WithValue(ctx, userIDKey, \"user-987\")\n\tctx = context.WithValue(ctx, traceIDKey, \"trace-abc-123\")\n\t// sessionIDKey は設定しない\n\n\t// 関数に Context を渡す\n\tprocessRequest(ctx)\n\n\t// sessionIDKey を持つ子 Context を作成\n\tctxWithSession := context.WithValue(ctx, sessionIDKey, \"sess-xyz-789\")\n\tprocessRequest(ctxWithSession) // この呼び出しでは sessionID も取得できるはず\n}\n\n/* 実行結果:\n--- processRequest ---\n取得した userID: user-987\n取得した traceID: trace-abc-123\n存在しないキー 'otherKey' の値は nil です。\n\n--- processRequest ---\n取得した userID: user-987\n取得した traceID: trace-abc-123\n存在しないキー 'otherKey' の値は nil です。\n*/",
        "tags": [
          "context",
          "concurrency",
          "Value",
          "型アサーション",
          "リクエストスコープ",
          "値伝達"
        ]
      },
      {
        "title": "\"Context パッケージ: 値のキーに関するベストプラクティス\"",
        "description": "",
        "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n)\n\n// --- キーの定義 ---\n// キーとして使うための非公開の独自型 (string のエイリアスでも良い)\ntype contextKey string\n// または type contextKey struct{} でも良い\n\n// このパッケージ内でのみ使うキー変数を定義\nconst (\n\tuserIDKey    contextKey = \"user_id\" // 値は何でも良いが、区別できる文字列が一般的\n\ttraceIDKey   contextKey = \"trace_id\"\n)\n\n// --- 値の設定と取得 ---\nfunc main() {\n\t// 値を設定\n\tctx := context.Background()\n\tctx = context.WithValue(ctx, userIDKey, 12345) // キーには userIDKey (contextKey 型) を使う\n\tctx = context.WithValue(ctx, traceIDKey, \"xyz-trace-987\")\n\n\t// 値を取得\n\tuserIDValue := ctx.Value(userIDKey) // キーには userIDKey を使う\n\tuserID, ok := userIDValue.(int)     // 型アサーション\n\tif ok {\n\t\tfmt.Printf(\"UserID: %d\\n\", userID)\n\t} else {\n\t\tfmt.Println(\"UserID が見つからないか、型が異なります。\")\n\t}\n\n\ttraceIDValue := ctx.Value(traceIDKey)\n\ttraceID, ok := traceIDValue.(string)\n\tif ok {\n\t\tfmt.Printf(\"TraceID: %s\\n\", traceID)\n\t} else {\n\t\tfmt.Println(\"TraceID が見つからないか、型が異なります。\")\n\t}\n\n\t// --- 文字列リテラルをキーとして使う場合 (非推奨) ---\n\t// ctx = context.WithValue(ctx, \"userID\", 12345) // 非推奨\n\t// userIDValue = ctx.Value(\"userID\")             // 非推奨\n}\n\n/* 実行結果:\nUserID: 12345\nTraceID: xyz-trace-987\n*/",
        "tags": [
          "context",
          "concurrency",
          "WithValue",
          "Value",
          "キー",
          "独自型",
          "ベストプラクティス"
        ]
      },
      {
        "title": "\"Context パッケージ: 呼び出しスタックを通じた Context の伝播\"",
        "description": "`context.Context` の重要な役割の一つは、キャンセルシグナル、デッドライン、リクエストスコープの値を、一連の関数呼び出し（呼び出しスタック）を通じて伝達することです。\n\nContext を関数間でどのように渡すべきか（第一引数としてそのまま渡す）という規約については、**「Context の受け渡し規約」** (`100_context/020_passing-context-convention.md`) や **「Context の伝播」** (`100_context/030_chaining-context-aware-functions.md`) で説明しました。\n\nここでは、HTTPリクエスト処理を例に、Context がどのように伝播していくかを再確認します。\n\n## HTTPリクエスト処理における Context 伝播\n\n1.  **リクエストの開始:** HTTPサーバーがリクエストを受け取ると、通常、そのリクエストに対応するベースとなる Context が生成されます（`net/http` サーバーでは `r.Context()` で取得できます）。\n2.  **ミドルウェア:** 認証、ロギング、リクエストID付与などのミドルウェアは、受け取った Context を基に `context.WithValue` などで新しい Context を生成し、次のハンドラに渡します。\n3.  **メインハンドラ:** リクエストを処理するメインのハンドラ関数は、ミドルウェアから渡された Context を受け取ります。必要であれば、`context.WithTimeout` などでさらに派生させた Context を生成します。\n4.  **下位の関数呼び出し:** ハンドラが内部で呼び出すビジネスロジック関数、データベースアクセス関数、外部API呼び出し関数などには、**受け取った Context (またはそこから派生させた Context) をそのまま第一引数として渡します**。\n5.  **最下層の処理:** データベースドライバや HTTP クライアントなど、ブロッキングする可能性のある I/O 操作を行う関数は、渡された Context の `Done()` チャネルを監視し、キャンセルされれば処理を中断します。\n\nこのように Context をリクエスト処理の開始から終了まで一貫して引き回すことで、タイムアウトやクライアントからのキャンセル要求が、処理のどの段階にいても適切に伝播し、関連するすべての Goroutine が効率的に停止できるようになります。\n\n**コード解説:**\n\n*   `handleRequest` は `r.Context()` でリクエストの Context を取得し、`context.WithTimeout` でタイムアウトを設定した `ctxWithTimeout` を作成します。\n*   `processLogic` は `ctxWithTimeout` を受け取り、それをそのまま `callExternalAPI` に渡します。\n*   `callExternalAPI` は渡された Context (`ctx`) の `Done()` チャネルを `select` で監視します。\n*   `main` 関数で設定されたタイムアウト (200ms) は、`handleRequest` -> `processLogic` -> `callExternalAPI` へと伝播します。`callExternalAPI` 内の `time.After(150 * time.Millisecond)` はタイムアウト内に完了しますが、もしこれが 200ms より長ければ、`<-ctx.Done()` が先に発生し、`context.DeadlineExceeded` エラーが返され、呼び出し元に伝播していきます。\n\nこのように、Context を呼び出しスタックを通じて適切に伝播させることで、リクエスト全体のライフサイクル（タイムアウトやキャンセル）を一貫して管理することができます。\n\n**実行方法と結果:**\n\nサーバー起動後、 `http://localhost:8080/` にアクセスすると、\nコンソールに以下のようなログが出力され、ブラウザにはエラーが表示されます。",
        "code": "package main\n\nimport (\n\t\"context\"\n\t\"errors\" // errors パッケージをインポート\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// 下位の処理 (例: 外部 API 呼び出し)\nfunc callExternalAPI(ctx context.Context, param string) (string, error) {\n\tfmt.Printf(\"  (外部API呼び出し '%s' 開始...)\\n\", param)\n\tselect {\n\tcase <-time.After(150 * time.Millisecond): // API 応答に時間がかかると仮定\n\t\tfmt.Printf(\"  (外部API呼び出し '%s' 成功)\\n\", param)\n\t\treturn fmt.Sprintf(\"API結果(%s)\", param), nil\n\tcase <-ctx.Done(): // ★ Context のキャンセルをチェック\n\t\tfmt.Printf(\"  (外部API呼び出し '%s' キャンセル: %v)\\n\", param, ctx.Err())\n\t\treturn \"\", ctx.Err()\n\t}\n}\n\n// 中間の処理 (Context を受け取り、下位に渡す)\nfunc processLogic(ctx context.Context, data string) (string, error) {\n\tfmt.Printf(\" 中間処理 '%s' 開始...\\n\", data)\n\t// ★ 受け取った ctx をそのまま callExternalAPI に渡す ★\n\tresult, err := callExternalAPI(ctx, data)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"中間処理失敗: %w\", err)\n\t}\n\tprocessedResult := fmt.Sprintf(\"処理済み: %s\", result)\n\tfmt.Printf(\" 中間処理 '%s' 完了\\n\", data)\n\treturn processedResult, nil\n}\n\n// HTTP ハンドラ (リクエストの起点)\nfunc handleRequest(w http.ResponseWriter, r *http.Request) {\n\tfmt.Println(\"\\n--- リクエスト受信 ---\")\n\t// リクエストから Context を取得 (ミドルウェアで値が追加されている可能性もある)\n\tctx := r.Context()\n\n\t// このリクエスト処理全体のタイムアウトを設定 (例: 200ms)\n\tctxWithTimeout, cancel := context.WithTimeout(ctx, 200*time.Millisecond)\n\tdefer cancel() // ハンドラ終了時に cancel を呼ぶ\n\n\t// ★ タイムアウト付き Context を下位の処理に渡す ★\n\tresult, err := processLogic(ctxWithTimeout, \"input-data\")\n\tif err != nil {\n\t\t// エラーの種類に応じて適切なステータスコードを返す\n\t\tstatusCode := http.StatusInternalServerError\n\t\tif errors.Is(err, context.DeadlineExceeded) {\n\t\t\tstatusCode = http.StatusGatewayTimeout // タイムアウトの場合\n\t\t}\n\t\thttp.Error(w, err.Error(), statusCode)\n\t\tfmt.Printf(\"--- リクエスト処理エラー: %v ---\\n\", err)\n\t\treturn\n\t}\n\n\t// 成功レスポンス\n\tfmt.Fprintf(w, \"成功: %s\", result)\n\tfmt.Println(\"--- リクエスト処理成功 ---\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handleRequest)\n\tfmt.Println(\"サーバーをポート :8080 で起動します...\")\n\t// エラーハンドリングを追加\n\terr := http.ListenAndServe(\":8080\", nil)\n\tif err != nil {\n\t\tfmt.Printf(\"サーバー起動エラー: %v\\n\", err)\n\t}\n}",
        "tags": [
          "context",
          "concurrency",
          "関数呼び出し",
          "伝播",
          "http"
        ]
      },
      {
        "title": "\"Context パッケージ: ミドルウェアでの Context 利用\"",
        "description": "",
        "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// キーの型とキー\ntype contextKey string\nconst requestTimeKey contextKey = \"requestTime\"\nconst requestIDKey contextKey = \"requestID\" // 200_context-with-values.md の例から\n\n// リクエスト時刻とIDを追加するミドルウェア\nfunc loggingMiddleware(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tstartTime := time.Now()\n\t\treqID := fmt.Sprintf(\"req-%d\", startTime.UnixNano()) // 簡単なID生成\n\n\t\t// 元の Context を取得\n\t\tctx := r.Context()\n\t\t// 値を追加して新しい Context を生成\n\t\tctx = context.WithValue(ctx, requestTimeKey, startTime)\n\t\tctx = context.WithValue(ctx, requestIDKey, reqID)\n\n\t\tfmt.Printf(\"[%s] ミドルウェア: リクエスト受信 (%s)\\n\", reqID, r.URL.Path)\n\n\t\t// 新しい Context を持つリクエストで次のハンドラを呼び出す\n\t\tnext.ServeHTTP(w, r.WithContext(ctx))\n\n\t\t// レスポンスが返された後の処理 (例: 処理時間ログ)\n\t\tduration := time.Since(startTime)\n\t\tfmt.Printf(\"[%s] ミドルウェア: 処理完了 (%s, duration: %v)\\n\", reqID, r.URL.Path, duration)\n\t})\n}\n\n// Context から値を取得するハンドラ\nfunc myHandler(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\treqID, _ := ctx.Value(requestIDKey).(string)\n\tstartTime, _ := ctx.Value(requestTimeKey).(time.Time)\n\n\tfmt.Printf(\"[%s] ハンドラ: 処理開始 (リクエスト時刻: %s)\\n\", reqID, startTime.Format(time.RFC3339Nano))\n\ttime.Sleep(50 * time.Millisecond) // 処理をシミュレート\n\tfmt.Fprintf(w, \"[%s] Hello!\", reqID)\n}\n\nfunc main() {\n\tfinalHandler := http.HandlerFunc(myHandler)\n\t// ミドルウェアでハンドラをラップ\n\thttp.Handle(\"/\", loggingMiddleware(finalHandler))\n\n\tfmt.Println(\"サーバーをポート :8080 で起動します...\")\n\t// エラーハンドリングを追加\n\terr := http.ListenAndServe(\":8080\", nil)\n\tif err != nil {\n\t\tfmt.Printf(\"サーバー起動エラー: %v\\n\", err)\n\t}\n}\n\n/*\nサーバー起動後、 http://localhost:8080/ にアクセスすると、\nコンソールに以下のようなログが出力される (IDと時刻は実行ごとに変わる):\n\n[req-1711644000123456789] ミドルウェア: リクエスト受信 (/)\n[req-1711644000123456789] ハンドラ: 処理開始 (リクエスト時刻: 2025-03-29T01:56:00.123456789+09:00)\n[req-1711644000123456789] ミドルウェア: 処理完了 (/, duration: 50.XXXms)\n*/",
        "tags": [
          "context",
          "concurrency",
          "http",
          "middleware",
          "WithValue",
          "WithContext"
        ]
      },
      {
        "title": "Context パッケージ: タイムアウト Context を使ったテスト",
        "description": "",
        "code": "package processor_test // テスト対象とは別パッケージ\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"testing\" // testing パッケージ\n\t\"time\"\n\n\t\"myproject/processor\" // テスト対象パッケージ (パスは例)\n)\n\n// 正常系: タイムアウトしない\nfunc TestProcessDataWithContext_Success(t *testing.T) {\n\t// 処理時間(150ms想定)より長いタイムアウト(500ms)\n\tctx, cancel := context.WithTimeout(context.Background(), 500*time.Millisecond)\n\tdefer cancel()\n\n\t_, err := processor.ProcessDataWithContext(ctx, \"test-success\")\n\tif err != nil { // エラーが発生しないことを期待\n\t\tt.Errorf(\"予期せぬエラー: %v\", err)\n\t}\n}\n\n// 異常系: タイムアウトする\nfunc TestProcessDataWithContext_Timeout(t *testing.T) {\n\t// 処理時間(150ms想定)より短いタイムアウト(50ms)\n\tctx, cancel := context.WithTimeout(context.Background(), 50*time.Millisecond)\n\tdefer cancel()\n\n\t_, err := processor.ProcessDataWithContext(ctx, \"test-timeout\")\n\n\t// エラーが発生することを期待\n\tif err == nil {\n\t\tt.Fatal(\"タイムアウトエラーが発生しませんでした\")\n\t}\n\t// ★ エラーが DeadlineExceeded であることを確認 ★\n\tif !errors.Is(err, context.DeadlineExceeded) {\n\t\tt.Errorf(\"期待したエラーは DeadlineExceeded ですが、実際は %v\", err)\n\t}\n}\n\n// --- テスト対象の関数 (例: processor/processor.go) ---\n/*\npackage processor\nimport (\"context\"; \"time\"; \"fmt\")\nfunc ProcessDataWithContext(ctx context.Context, data string) (string, error) {\n\tselect {\n\tcase <-time.After(150 * time.Millisecond): // 150ms かかる処理\n\t\treturn \"processed: \" + data, nil\n\tcase <-ctx.Done(): // キャンセルチェック\n\t\treturn \"\", ctx.Err()\n\t}\n}\n*/",
        "tags": [
          "context",
          "concurrency",
          "testing",
          "timeout",
          "WithTimeout",
          "errors.Is",
          "DeadlineExceeded"
        ]
      },
      {
        "title": "Context パッケージ: キャンセル Context を使ったテスト",
        "description": "",
        "code": "package processor_test\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n\n\t\"myproject/processor\" // テスト対象パッケージ (パスは例)\n)\n\n// テスト: 明示的にキャンセルする場合\nfunc TestProcessDataWithContext_Cancel(t *testing.T) {\n\t// キャンセル可能な Context を作成\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel() // テスト終了時に確実に解放\n\n\terrChan := make(chan error, 1) // 結果受け取り用チャネル\n\n\t// テスト対象関数を Goroutine で実行\n\tgo func() {\n\t\t_, err := processor.ProcessDataWithContext(ctx, \"test-cancel\")\n\t\terrChan <- err\n\t}()\n\n\t// 少し待ってからキャンセルを実行 (処理時間より短く)\n\ttime.Sleep(50 * time.Millisecond)\n\tfmt.Println(\"Test: cancel() 呼び出し...\")\n\tcancel() // ★ Context をキャンセル\n\n\t// 結果を検証 (タイムアウト付きで待つのがより安全)\n\tselect {\n\tcase err := <-errChan:\n\t\tif err == nil { // エラーが発生することを期待\n\t\t\tt.Fatal(\"キャンセルエラーが発生しませんでした\")\n\t\t}\n\t\t// ★ エラーが Canceled であることを確認 ★\n\t\tif !errors.Is(err, context.Canceled) {\n\t\t\tt.Errorf(\"期待エラーは Canceled ですが、実際は %v\", err)\n\t\t} else {\n\t\t\tfmt.Println(\"Test: 期待通りキャンセルされました\")\n\t\t}\n\tcase <-time.After(1 * time.Second): // テスト自体のタイムアウト\n\t\tt.Fatal(\"テストがタイムアウトしました\")\n\t}\n}\n\n// --- テスト対象の関数 (例: processor/processor.go) ---\n/*\npackage processor\nimport (\"context\"; \"time\"; \"fmt\")\nfunc ProcessDataWithContext(ctx context.Context, data string) (string, error) {\n\tselect {\n\tcase <-time.After(150 * time.Millisecond): // 150ms かかる処理\n\t\treturn \"processed: \" + data, nil\n\tcase <-ctx.Done(): // キャンセルチェック\n\t\treturn \"\", ctx.Err()\n\t}\n}\n*/",
        "tags": [
          "context",
          "concurrency",
          "testing",
          "cancel",
          "WithCancel",
          "errors.Is",
          "Canceled"
        ]
      },
      {
        "title": "Context パッケージ: Context のテスト (モックは通常不要)",
        "description": "",
        "code": "// Context のテストでは通常モックは不要。\n// 標準の context.WithCancel や context.WithTimeout を使う。\n\n// 例 (タイムアウトテスト):\n// ctx, cancel := context.WithTimeout(context.Background(), 50*time.Millisecond)\n// defer cancel()\n// err := functionUnderTest(ctx)\n// if !errors.Is(err, context.DeadlineExceeded) { /* エラー処理 */ }\n\n// 例 (キャンセルテスト):\n// ctx, cancel := context.WithCancel(context.Background())\n// defer cancel()\n// go func() { time.Sleep(50*time.Millisecond); cancel() }()\n// err := functionUnderTest(ctx)\n// if !errors.Is(err, context.Canceled) { /* エラー処理 */ }\n\n// 例 (値テスト):\n// ctx := context.WithValue(context.Background(), myKey, testValue)\n// functionUnderTest(ctx)\n// // (必要なら functionUnderTest 内での値利用を検証)",
        "tags": [
          "context",
          "concurrency",
          "testing",
          "mocking",
          "WithCancel",
          "WithTimeout"
        ]
      }
    ]
  },
  {
    "title": "Io Operations",
    "codeExamples": [
      {
        "title": "I/O 操作: ファイル全体を読み込む (`os.ReadFile`)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\" // os パッケージ\n)\n\nfunc main() {\n\tfileName := \"example.txt\" // 読み込むファイル名\n\t// 事前にファイルを作成しておく必要があります\n\t// os.WriteFile(fileName, []byte(\"ファイル内容\"), 0644)\n\n\tfmt.Printf(\"'%s' を読み込み中...\\n\", fileName)\n\t// os.ReadFile でファイル全体をバイトスライスに読み込む\n\tdata, err := os.ReadFile(fileName)\n\n\t// エラーチェックは必須\n\tif err != nil {\n\t\tlog.Fatalf(\"読み込み失敗: %v\", err)\n\t}\n\n\t// 読み込んだ内容 (バイトスライス) を文字列に変換して表示\n\tfmt.Println(\"--- 内容 ---\")\n\tfmt.Print(string(data))\n\tfmt.Println(\"------------\")\n\tfmt.Printf(\"バイト数: %d\\n\", len(data))\n\n\t// os.Remove(fileName) // 後片付け\n}",
        "tags": [
          "io-operations",
          "io",
          "os",
          "file",
          "read",
          "ReadFile",
          "ファイル読み込み"
        ]
      },
      {
        "title": "I/O 操作: ファイルへの書き込み (`os.WriteFile`)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\" // os パッケージ\n)\n\nfunc main() {\n\tfileName := \"output.txt\"\n\tcontent := \"os.WriteFile で書き込むテキスト。\\n改行もOK。\\n\"\n\tdata := []byte(content) // 文字列をバイトスライスに変換\n\n\t// os.WriteFile でファイルに書き込む (パーミッション 0644)\n\terr := os.WriteFile(fileName, data, 0644)\n\n\t// エラーチェックは必須\n\tif err != nil {\n\t\tlog.Fatalf(\"書き込み失敗 '%s': %v\", fileName, err)\n\t}\n\n\tfmt.Printf(\"'%s' に書き込み成功。\\n\", fileName)\n\n\t// (確認のため os.ReadFile で読み込む処理は省略)\n\t// os.Remove(fileName) // 後片付け\n}",
        "tags": [
          "io-operations",
          "io",
          "os",
          "file",
          "write",
          "WriteFile",
          "ファイル書き込み",
          "パーミッション"
        ]
      },
      {
        "title": "I/O 操作: ファイルを開く/作成する (`os.Open`, `os.Create`, `os.OpenFile`)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n)\n\nfunc main() {\n\tfileName := \"test_open.txt\"\n\n\t// os.Create: 書き込み用に作成 (または上書き)\n\tfile1, err := os.Create(fileName)\n\tif err != nil { log.Fatalf(\"Create failed: %v\", err) }\n\tfmt.Printf(\"'%s' created/opened for writing.\\n\", fileName)\n\tdefer file1.Close() // ★ 必ず Close する\n\t// file1.WriteString(\"...\") // 書き込み可能\n\n\t// os.Open: 読み取り専用で開く\n\tfile2, err := os.Open(fileName) // 既存ファイルを開く\n\tif err != nil { log.Fatalf(\"Open failed: %v\", err) }\n\tfmt.Printf(\"'%s' opened for reading.\\n\", fileName)\n\tdefer file2.Close() // ★ 必ず Close する\n\t// content, _ := io.ReadAll(file2) // 読み取り可能\n\n\t// os.OpenFile: 追記モードで開く (例)\n\t// flag := os.O_WRONLY | os.O_APPEND | os.O_CREATE\n\t// file3, err := os.OpenFile(fileName, flag, 0644)\n\t// if err != nil { log.Fatalf(\"OpenFile failed: %v\", err) }\n\t// fmt.Printf(\"'%s' opened for appending.\\n\", fileName)\n\t// defer file3.Close()\n\t// file3.WriteString(\"Appended text.\\n\")\n\n\tos.Remove(fileName) // 後片付け\n}",
        "tags": [
          "io-operations",
          "io",
          "os",
          "file",
          "open",
          "create",
          "OpenFile",
          "ファイル操作",
          "defer",
          "Close"
        ]
      },
      {
        "title": "I/O 操作: ファイルからの読み込み (`file.Read`)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\" // io.EOF\n\t\"log\"\n\t\"os\"\n)\n\nfunc main() {\n\tfileName := \"example.txt\" // 事前に作成しておく\n\t// os.WriteFile(fileName, []byte(\"Line1\\nLine2\"), 0644)\n\n\tfile, err := os.Open(fileName) // 読み取り用に開く\n\tif err != nil { log.Fatal(err) }\n\tdefer file.Close() // ★ 必ず閉じる\n\n\tbuffer := make([]byte, 32) // 読み込み用バッファ\n\ttotalBytes := 0\n\tfmt.Println(\"--- Reading ---\")\n\n\tfor {\n\t\t// バッファに読み込む\n\t\tbytesRead, err := file.Read(buffer)\n\t\tif bytesRead > 0 {\n\t\t\t// 読み込んだ分だけ処理 (例: 表示)\n\t\t\tfmt.Printf(\"Read %d bytes: %s\\n\", bytesRead, string(buffer[:bytesRead]))\n\t\t\ttotalBytes += bytesRead\n\t\t}\n\n\t\t// ★ エラーチェック (EOF含む) ★\n\t\tif err != nil {\n\t\t\tif err == io.EOF { // ファイル終端なら正常終了\n\t\t\t\tfmt.Println(\"--- EOF ---\")\n\t\t\t\tbreak // ループを抜ける\n\t\t\t}\n\t\t\t// EOF 以外のエラー\n\t\t\tlog.Fatalf(\"Read error: %v\", err)\n\t\t}\n\t}\n\tfmt.Printf(\"Total read: %d bytes\\n\", totalBytes)\n\t// os.Remove(fileName) // 後片付け\n}",
        "tags": [
          "io-operations",
          "io",
          "os",
          "file",
          "read",
          "Reader",
          "EOF",
          "ファイル読み込み",
          "バッファ",
          "ループ"
        ]
      },
      {
        "title": "I/O 操作: ファイルへの書き込み (`file.Write`, `file.WriteString`)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n)\n\nfunc main() {\n\tfileName := \"output_write.txt\"\n\tfile, err := os.Create(fileName) // 書き込み用に作成/オープン\n\tif err != nil { log.Fatal(err) }\n\tdefer file.Close() // ★ 必ず閉じる\n\n\tfmt.Printf(\"'%s' を書き込み用にオープン\\n\", fileName)\n\n\t// file.Write でバイトスライスを書き込む\n\tdata1 := []byte(\"Write で書き込み\\n\")\n\tn1, err := file.Write(data1)\n\tif err != nil { log.Fatalf(\"Write 失敗: %v\", err) }\n\tfmt.Printf(\"Write: %d バイト書き込み\\n\", n1)\n\n\t// file.WriteString で文字列を書き込む\n\tn2, err := file.WriteString(\"WriteString で書き込み\\n\")\n\tif err != nil { log.Fatalf(\"WriteString 失敗: %v\", err) }\n\tfmt.Printf(\"WriteString: %d バイト書き込み\\n\", n2)\n\n\t// fmt.Fprintf(file, \"Fprintf も使える\\n\") // *os.File は io.Writer\n\n\tfmt.Println(\"書き込み完了\")\n\t// os.Remove(fileName) // 後片付け\n}",
        "tags": [
          "io-operations",
          "io",
          "os",
          "file",
          "write",
          "WriteString",
          "Writer",
          "ファイル書き込み"
        ]
      },
      {
        "title": "I/O 操作: ファイル内の位置移動 (`file.Seek`)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\" // Seek 定数\n\t\"log\"\n\t\"os\"\n)\n\nfunc main() {\n\tfileName := \"example_seek.txt\"\n\t// 事前にファイル作成: os.WriteFile(fileName, []byte(\"0123456789ABC...\"), 0644)\n\n\tfile, err := os.OpenFile(fileName, os.O_RDWR, 0644) // 読み書きで開く\n\tif err != nil { log.Fatal(err) }\n\tdefer file.Close()\n\n\tbuffer := make([]byte, 5)\n\n\t// 1. 先頭から 10 バイト目に移動 (SeekStart)\n\tnewOffset, err := file.Seek(10, io.SeekStart)\n\tif err != nil { log.Fatal(err) }\n\tfmt.Printf(\"Seek(10, Start): Offset=%d\\n\", newOffset) // 10\n\n\t// 2. 現在位置から 5 バイト読み込む\n\tn, err := file.Read(buffer)\n\tif err != nil { log.Fatal(err) }\n\tfmt.Printf(\" Read: %s\\n\", string(buffer[:n])) // ABCDE\n\n\t// 3. 末尾から 5 バイト前に移動 (SeekEnd)\n\tnewOffset, err = file.Seek(-5, io.SeekEnd)\n\tif err != nil { log.Fatal(err) }\n\tfmt.Printf(\"Seek(-5, End): Offset=%d\\n\", newOffset) // 例: 31\n\n\t// 4. 現在位置から 5 バイト読み込む\n\tn, err = file.Read(buffer)\n\tif err != nil && err != io.EOF { log.Fatal(err) }\n\tfmt.Printf(\" Read: %s\\n\", string(buffer[:n])) // VWXYZ\n\n\t// os.Remove(fileName) // 後片付け\n}",
        "tags": [
          "io-operations",
          "io",
          "os",
          "file",
          "seek",
          "Seek",
          "SeekStart",
          "SeekCurrent",
          "SeekEnd",
          "オフセット"
        ]
      },
      {
        "title": "I/O 操作: データのコピー (`io.Copy`, `io.CopyN`)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\" // io.Copy\n\t\"log\"\n\t\"os\"\n\t// \"strings\" // strings.NewReader の例は省略\n)\n\nfunc main() {\n\t// --- ファイルからファイルへのコピー ---\n\tsrcFileName := \"source.txt\"\n\tdstFileName := \"dest.txt\"\n\tos.WriteFile(srcFileName, []byte(\"Source content.\\n\"), 0644) // 元ファイル準備\n\n\tsrcFile, err := os.Open(srcFileName) // Reader として開く\n\tif err != nil { log.Fatal(err) }\n\tdefer srcFile.Close()\n\n\tdstFile, err := os.Create(dstFileName) // Writer として開く\n\tif err != nil { log.Fatal(err) }\n\tdefer dstFile.Close()\n\n\t// ★ io.Copy で src から dst へコピー ★\n\tbytesCopied, err := io.Copy(dstFile, srcFile)\n\tif err != nil {\n\t\tlog.Fatalf(\"コピー失敗: %v\", err)\n\t}\n\tfmt.Printf(\"Copied %d bytes from %s to %s\\n\", bytesCopied, srcFileName, dstFileName)\n\n\t// (コピー結果確認や後片付けは省略)\n\t// os.Remove(srcFileName); os.Remove(dstFileName)\n}",
        "tags": [
          "io-operations",
          "io",
          "copy",
          "Copy",
          "CopyN",
          "Reader",
          "Writer",
          "ファイルコピー"
        ]
      },
      {
        "title": "I/O 操作: 一時ディレクトリの作成 (`os.MkdirTemp`)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t// \"path/filepath\"\n)\n\nfunc main() {\n\tfmt.Println(\"一時ディレクトリ作成...\")\n\n\t// システム一時ディレクトリ内に \"myapp-*\" パターンのディレクトリ作成\n\ttempDir, err := os.MkdirTemp(\"\", \"myapp-*\")\n\tif err != nil {\n\t\tlog.Fatalf(\"作成失敗: %v\", err)\n\t}\n\n\t// ★★★ defer で必ず削除 ★★★\n\tdefer func() {\n\t\tfmt.Printf(\"defer: '%s' を削除\\n\", tempDir)\n\t\terr := os.RemoveAll(tempDir) // ディレクトリと中身を削除\n\t\tif err != nil { log.Printf(\"警告: 削除失敗: %v\", err) }\n\t}()\n\n\tfmt.Printf(\"作成された一時ディレクトリ: %s\\n\", tempDir)\n\n\t// --- 一時ディレクトリ内にファイル作成等 ---\n\t// filePath := filepath.Join(tempDir, \"temp.txt\")\n\t// os.WriteFile(filePath, []byte(\"data\"), 0644)\n\tfmt.Println(\"一時ディレクトリ内で処理実行中...\")\n\n\t// main 終了時に defer が実行される\n}",
        "tags": [
          "io-operations",
          "os",
          "MkdirTemp",
          "一時ディレクトリ",
          "temp",
          "defer",
          "RemoveAll"
        ]
      },
      {
        "title": "I/O 操作: 一時ファイルの作成 (`os.CreateTemp`)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n)\n\nfunc main() {\n\tfmt.Println(\"一時ファイル作成...\")\n\n\t// 一時ディレクトリ内に \"temp-*.txt\" パターンのファイルを作成・オープン\n\ttempFile, err := os.CreateTemp(\"\", \"temp-*.txt\")\n\tif err != nil { log.Fatal(err) }\n\n\t// ★★★ 2段階 defer でクリーンアップ ★★★\n\t// 1. ファイルハンドルを閉じる (Remove より先に defer)\n\tdefer func() {\n\t\tfmt.Printf(\"defer: Close '%s'\\n\", tempFile.Name())\n\t\ttempFile.Close()\n\t}()\n\t// 2. ファイル自体を削除する (Close より後に defer)\n\tdefer func() {\n\t\tfmt.Printf(\"defer: Remove '%s'\\n\", tempFile.Name())\n\t\tos.Remove(tempFile.Name())\n\t}()\n\n\n\tfmt.Printf(\"作成された一時ファイル: %s\\n\", tempFile.Name())\n\n\t// 一時ファイルに書き込む\n\t_, err = tempFile.Write([]byte(\"一時データ\"))\n\tif err != nil { log.Fatal(err) }\n\tfmt.Println(\"一時ファイルに書き込み完了\")\n\n\t// main 終了時に defer が逆順 (Remove -> Close) で実行される\n}",
        "tags": [
          "io-operations",
          "os",
          "CreateTemp",
          "一時ファイル",
          "temp",
          "defer",
          "Remove",
          "Close"
        ]
      },
      {
        "title": "I/O 操作: Reader からすべて読み込む (`io.ReadAll`)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\" // io.ReadAll\n\t\"log\"\n\t\"strings\" // strings.NewReader\n\t// \"os\"\n\t// \"net/http\"\n)\n\nfunc main() {\n\t// 例: strings.Reader から読み込む\n\treader := strings.NewReader(\"リーダーからのデータ。\")\n\tdata, err := io.ReadAll(reader) // Reader から全て読み込む\n\n\tif err != nil { // EOF 以外のエラーチェック\n\t\tlog.Fatalf(\"ReadAll 失敗: %v\", err)\n\t}\n\n\t// data は []byte\n\tfmt.Printf(\"読み込み成功 (%d bytes): %s\\n\", len(data), string(data))\n\n\t// --- 他の Reader の例 ---\n\t// file, _ := os.Open(\"file.txt\")\n\t// defer file.Close()\n\t// fileData, _ := io.ReadAll(file)\n\n\t// resp, _ := http.Get(\"...\")\n\t// defer resp.Body.Close()\n\t// bodyData, _ := io.ReadAll(resp.Body)\n}",
        "tags": [
          "io-operations",
          "io",
          "ReadAll",
          "Reader",
          "EOF",
          "メモリ",
          "ファイル読み込み",
          "HTTP"
        ]
      },
      {
        "title": "I/O 操作: 複数の Reader の連結 (`io.MultiReader`)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\" // io.MultiReader, io.Copy\n\t\"log\"\n\t\"os\"\n\t\"strings\" // strings.NewReader\n)\n\nfunc main() {\n\t// 複数の Reader を準備\n\tr1 := strings.NewReader(\"First part. \")\n\tr2 := strings.NewReader(\"Second part. \")\n\tr3 := strings.NewReader(\"Third part.\")\n\n\t// io.MultiReader で連結\n\tmultiReader := io.MultiReader(r1, r2, r3)\n\n\tfmt.Println(\"--- Reading from MultiReader ---\")\n\n\t// 連結された Reader から io.Copy で読み込む\n\tbytesCopied, err := io.Copy(os.Stdout, multiReader) // 標準出力へコピー\n\tfmt.Println() // 改行\n\tif err != nil {\n\t\tlog.Fatalf(\"Copy failed: %v\", err)\n\t}\n\tfmt.Printf(\"(Copied %d bytes)\\n\", bytesCopied)\n\n\t// 読み込み後、元の r1, r2, r3 は EOF になっている\n}",
        "tags": [
          "io-operations",
          "io",
          "MultiReader",
          "Reader",
          "連結",
          "ストリーム"
        ]
      },
      {
        "title": "I/O 操作: 複数への同時書き込み (`io.MultiWriter`)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"bytes\" // bytes.Buffer\n\t\"fmt\"\n\t\"io\" // io.MultiWriter, io.WriteString\n\t\"log\"\n\t\"os\"\n)\n\nfunc main() {\n\t// 書き込み先を準備\n\tw1 := os.Stdout      // 1. 標準出力\n\tvar w2 bytes.Buffer // 2. メモリバッファ (io.Writer を満たす)\n\t// w3, _ := os.Create(\"file.log\") // 3. ファイル (例)\n\t// defer w3.Close()\n\n\t// io.MultiWriter で複数の Writer を束ねる\n\t// ここでは標準出力とメモリバッファに書き込む Writer を作成\n\tmultiWriter := io.MultiWriter(w1, &w2) // バッファはポインタを渡す\n\n\tfmt.Println(\"--- Writing to MultiWriter ---\")\n\n\t// multiWriter に書き込むと、w1 と w2 の両方に書き込まれる\n\tmessage := \"Log message.\\n\"\n\tn, err := io.WriteString(multiWriter, message)\n\tif err != nil {\n\t\tlog.Fatalf(\"Write failed: %v\", err)\n\t}\n\tfmt.Printf(\"(Wrote %d bytes)\\n\", n)\n\n\tfmt.Println(\"--- End Writing ---\")\n\n\t// 結果確認 (バッファの内容)\n\tfmt.Println(\"\\n--- Buffer Content ---\")\n\tfmt.Print(w2.String()) // \"Log message.\\n\" が入っている\n}",
        "tags": [
          "io-operations",
          "io",
          "MultiWriter",
          "Writer",
          "同時書き込み",
          "ログ"
        ]
      },
      {
        "title": "I/O 操作: バッファ付きリーダー (`bufio.NewReader`)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"bufio\" // bufio パッケージ\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t// \"strings\"\n)\n\nfunc main() {\n\tfileName := \"example.txt\" // 事前に作成しておく\n\t// os.WriteFile(fileName, []byte(\"Line1\\nLine2\\n\"), 0644)\n\n\tfile, err := os.Open(fileName)\n\tif err != nil { log.Fatal(err) }\n\tdefer file.Close()\n\n\t// bufio.NewReader でラップ\n\treader := bufio.NewReader(file)\n\n\tfmt.Println(\"--- Reading line by line ---\")\n\tfor {\n\t\t// ReadString('\\n') で改行まで読み込む\n\t\tline, err := reader.ReadString('\\n')\n\t\tif len(line) > 0 {\n\t\t\tfmt.Print(line) // 読み込んだ行を表示 (改行含む)\n\t\t}\n\n\t\t// エラーチェック (EOF含む)\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tfmt.Println(\"--- EOF ---\")\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tlog.Fatalf(\"Read error: %v\", err)\n\t\t}\n\t}\n\t// os.Remove(fileName) // 後片付け\n}",
        "tags": [
          "io-operations",
          "io",
          "bufio",
          "Reader",
          "NewReader",
          "バッファリング",
          "効率化",
          "ReadString",
          "ReadByte"
        ]
      },
      {
        "title": "I/O 操作: バッファ付きスキャナー (`bufio.Scanner`)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"bufio\" // bufio.Scanner\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t// \"strings\"\n)\n\nfunc main() {\n\tfileName := \"example_scanner.txt\" // 事前に作成しておく\n\t// os.WriteFile(fileName, []byte(\"Line 1\\nLine 2\\n\"), 0644)\n\n\tfile, err := os.Open(fileName)\n\tif err != nil { log.Fatal(err) }\n\tdefer file.Close()\n\n\t// Scanner を作成 (デフォルトは行単位でスキャン)\n\tscanner := bufio.NewScanner(file)\n\n\tfmt.Println(\"--- Reading file line by line ---\")\n\tlineNum := 1\n\t// for scanner.Scan() ループで反復処理\n\tfor scanner.Scan() {\n\t\t// scanner.Text() で現在の行を取得 (改行は含まない)\n\t\tline := scanner.Text()\n\t\tfmt.Printf(\"%d: %s\\n\", lineNum, line)\n\t\tlineNum++\n\t}\n\n\t// ★ ループ終了後、必ずエラーをチェック ★\n\tif err := scanner.Err(); err != nil {\n\t\tlog.Fatalf(\"Scan error: %v\", err)\n\t}\n\tfmt.Println(\"Scan finished.\")\n\t// os.Remove(fileName) // 後片付け\n}",
        "tags": [
          "io-operations",
          "io",
          "bufio",
          "Scanner",
          "NewScanner",
          "Scan",
          "Text",
          "Err",
          "Split",
          "ファイル読み込み",
          "行単位"
        ]
      },
      {
        "title": "I/O 操作: バッファ付きライター (`bufio.Writer`)",
        "description": "`io.Writer` に頻繁に小さな書き込みを行うと非効率な場合があります。\n**バッファリング**で書き込み効率を改善できます。\n\n`bufio` パッケージの **`NewWriter`** は、既存の `io.Writer` を\nラップし、内部バッファを持つ `*bufio.Writer` を作成します。\n`import \"bufio\"` で利用します。\n\n**使い方:**\n`writer := bufio.NewWriter(wr io.Writer)`\n*   `wr`: 元の `io.Writer` (例: `*os.File`)。\n*   `writer`: `*bufio.Writer` (これも `io.Writer`)。\n*   デフォルトバッファサイズ 4096 バイト (`NewWriterSize` で指定可)。\n\n`writer` への `Write`, `WriteString` 等はまず内部バッファに書き込まれます。\nバッファが一杯になるか、**`Flush()`** が呼ばれるまで、\n元の `wr` には書き込まれません。\n\n**`Flush()` メソッドの重要性:**\n`err := writer.Flush()`\n*   バッファに残っているデータを元の `io.Writer` に書き出す。\n*   **重要:** `bufio.Writer` を使ったら、書き込み処理の\n    **最後に必ず `Flush()` を呼ぶ**必要があります。\n    忘れるとデータが書き込まれず欠損します。\n*   `defer` で呼ぶことも可能ですが、`Flush()` 自体のエラー処理が必要です。",
        "code": "package main\n\nimport (\n\t\"bufio\" // bufio.Writer\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n)\n\nfunc main() {\n\tfileName := \"output_buffered.txt\"\n\tfile, err := os.Create(fileName)\n\tif err != nil { log.Fatal(err) }\n\tdefer file.Close() // ファイル自体の Close も必要\n\n\t// bufio.NewWriter でラップ\n\twriter := bufio.NewWriter(file)\n\n\tfmt.Println(\"Writing to buffer...\")\n\t// データ書き込み (バッファへ)\n\tn1, _ := writer.WriteString(\"Buffered Write 1.\\n\")\n\tn2, _ := writer.Write([]byte(\"Buffered Write 2.\\n\"))\n\t_ = writer.WriteByte('!')\n\tfmt.Printf(\"Buffered: %d bytes\\n\", writer.Buffered()) // バッファ内のバイト数\n\n\t// ★★★ Flush でバッファ内容を書き出す ★★★\n\tfmt.Println(\"Flushing buffer...\")\n\terr = writer.Flush() // この時点でファイルに書き込まれる\n\tif err != nil { log.Fatalf(\"Flush failed: %v\", err) }\n\tfmt.Println(\"Flush complete.\")\n\tfmt.Printf(\"Buffered after flush: %d bytes\\n\", writer.Buffered()) // 0\n\n\t// (ファイル内容確認や os.Remove は省略)\n}",
        "tags": [
          "io-operations",
          "io",
          "bufio",
          "Writer",
          "NewWriter",
          "Flush",
          "バッファリング",
          "効率化",
          "ファイル書き込み"
        ]
      },
      {
        "title": "I/O 操作: 文字列を Reader として扱う (`strings.NewReader`)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"strings\" // strings.NewReader\n)\n\n// io.Reader を受け取る関数 (例)\nfunc printContent(r io.Reader) error {\n\tfmt.Println(\"--- Content ---\")\n\t_, err := io.Copy(os.Stdout, r) // Reader から標準出力へコピー\n\tfmt.Println(\"\\n---------------\")\n\treturn err\n}\n\nfunc main() {\n\tmyString := \"メモリ上の文字列データ。\\nReader として扱える。\"\n\n\t// strings.NewReader で文字列から Reader を作成\n\tstringReader := strings.NewReader(myString)\n\n\t// io.Reader を引数に取る関数に渡す\n\terr := printContent(stringReader)\n\tif err != nil { log.Fatal(err) }\n\n\t// 読み込み後は EOF になっている\n\t// n, readErr := stringReader.Read([]byte{0}) // n=0, readErr=io.EOF\n\n\t// Seek も可能 (io.Seeker を満たす)\n\t// stringReader.Seek(10, io.SeekStart)\n}",
        "tags": [
          "io-operations",
          "io",
          "strings",
          "Reader",
          "NewReader",
          "テスト",
          "メモリ"
        ]
      },
      {
        "title": "I/O 操作: バイトバッファ (`bytes.Buffer`)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"bytes\" // bytes.Buffer\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t// \"os\"\n)\n\nfunc main() {\n\t// 空のバッファを作成\n\tvar buffer bytes.Buffer\n\n\t// 書き込み (io.Writer として動作)\n\tbuffer.WriteString(\"Hello, \")\n\tbuffer.Write([]byte(\"Buffer!\\n\"))\n\tfmt.Fprintf(&buffer, \"Length: %d\\n\", buffer.Len())\n\n\t// 内容取得\n\tfmt.Println(\"--- Content ---\")\n\tfmt.Print(buffer.String()) // 未読部分を文字列で取得\n\tfmt.Println(\"---------------\")\n\n\t// 読み込み (io.Reader として動作)\n\tfmt.Println(\"--- Reading ---\")\n\tline, err := buffer.ReadString('\\n') // 1行読み込み\n\tif err != nil && err != io.EOF { log.Fatal(err) }\n\tfmt.Printf(\"Read line: %s\", line)\n\n\tremaining, _ := io.ReadAll(&buffer) // 残りを全て読み込み\n\tfmt.Printf(\"Read remaining: %s\", string(remaining))\n\tfmt.Printf(\"Len after read: %d\\n\", buffer.Len()) // 0\n\n\t// buffer.Reset() // バッファを空にする\n}",
        "tags": [
          "io-operations",
          "io",
          "bytes",
          "Buffer",
          "NewBuffer",
          "NewBufferString",
          "Reader",
          "Writer",
          "メモリ",
          "バッファ"
        ]
      },
      {
        "title": "I/O 操作: 読み込みサイズの制限 (`io.LimitReader`)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"strings\"\n)\n\nfunc main() {\n\toriginalData := \"0123456789ABCDEFGHIJ\" // 20バイトのデータ\n\treader := strings.NewReader(originalData)\n\n\t// LimitReader で最大 15 バイトに制限\n\tlimitReader := io.LimitReader(reader, 15)\n\n\t// ReadAll で読み込む (最大15バイトしか読めない)\n\tdata, err := io.ReadAll(limitReader)\n\tif err != nil {\n\t\tlog.Fatalf(\"ReadAll failed: %v\", err)\n\t}\n\tfmt.Printf(\"Read (%d bytes): %s\\n\", len(data), string(data)) // 15バイト\n\n\t// さらに読み込もうとしても EOF になる\n\t// n, err := limitReader.Read([]byte{0}) // n=0, err=io.EOF\n\n\t// 元の reader は 15 バイト分進んでいる\n\t// remaining, _ := io.ReadAll(reader) // \"FGHIJ\" が読める\n}",
        "tags": [
          "io-operations",
          "io",
          "LimitReader",
          "Reader",
          "制限",
          "セキュリティ"
        ]
      },
      {
        "title": "I/O 操作: CSV データの読み込み (`encoding/csv`)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"encoding/csv\" // csv パッケージ\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"strings\"\n\t// \"os\" // ファイルから読む場合は os.Open\n)\n\nfunc main() {\n\tcsvData := `\"Name\",\"Age\",\"City\"\\n\"Alice\",\"30\",\"New York\"\\n\"Bob\",\"\",\"London\"`\n\n\t// csv.NewReader でリーダー作成\n\treader := csv.NewReader(strings.NewReader(csvData))\n\t// reader.Comma = '\\t' // タブ区切りなど、オプション設定可能\n\n\tfmt.Println(\"--- Reading CSV record by record ---\")\n\t// ヘッダー行読み飛ばし (オプション)\n\t// header, _ := reader.Read()\n\t// fmt.Println(\"Header:\", header)\n\n\tfor {\n\t\t// Read() で1レコード (1行) ずつ読み込む\n\t\trecord, err := reader.Read()\n\t\tif err != nil {\n\t\t\tif err == io.EOF { break } // 終端でループ終了\n\t\t\tlog.Fatal(err) // EOF 以外のエラー\n\t\t}\n\t\t// record は []string (フィールドのスライス)\n\t\tfmt.Printf(\"Record: %v, Fields: %d\\n\", record, len(record))\n\t\t// fmt.Printf(\" Name: %s, Age: %s\\n\", record[0], record[1])\n\t}\n\tfmt.Println(\"Finished reading.\")\n}",
        "tags": [
          "io-operations",
          "encoding/csv",
          "csv",
          "Reader",
          "ReadAll",
          "Read",
          "ファイル読み込み",
          "データ解析"
        ]
      },
      {
        "title": "I/O 操作: CSV データの書き込み (`encoding/csv`)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"encoding/csv\" // csv パッケージ\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t// \"bytes\"\n)\n\nfunc main() {\n\trecords := [][]string{\n\t\t{\"Header1\", \"Header2\"},\n\t\t{\"Data1\", \"Value, with comma\"},\n\t\t{\"Data2\", \"Value\\nwith newline\"},\n\t}\n\tfileName := \"output.csv\"\n\n\tfile, err := os.Create(fileName)\n\tif err != nil { log.Fatal(err) }\n\tdefer file.Close()\n\n\t// csv.NewWriter を作成 (io.Writer を渡す)\n\twriter := csv.NewWriter(file)\n\t// writer.Comma = '\\t' // オプション: 区切り文字変更\n\t// writer.UseCRLF = true // オプション: 改行を CRLF に\n\n\t// Write で1レコードずつ書き込み\n\tfor _, record := range records {\n\t\terr := writer.Write(record) // 自動でクォート等処理\n\t\tif err != nil { log.Fatalf(\"Write failed: %v\", err) }\n\t}\n\n\t// ★ Flush でバッファ内容を書き出す (Write を使った場合は必須) ★\n\twriter.Flush()\n\tif err := writer.Error(); err != nil { // Flush 後のエラーチェック\n\t\tlog.Fatalf(\"Flush error: %v\", err)\n\t}\n\n\tfmt.Printf(\"'%s' に書き込み完了\\n\", fileName)\n\t// (ファイル内容確認や os.Remove は省略)\n}",
        "tags": [
          "io-operations",
          "encoding/csv",
          "csv",
          "Writer",
          "NewWriter",
          "Write",
          "WriteAll",
          "Flush",
          "ファイル書き込み"
        ]
      },
      {
        "title": "I/O 操作: ディレクトリの作成 (`os.Mkdir`, `os.MkdirAll`)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\" // os.Mkdir, os.MkdirAll\n)\n\nfunc main() {\n\t// os.Mkdir: 単一ディレクトリ作成 (親が必要)\n\tdirName1 := \"single_dir\"\n\terr := os.Mkdir(dirName1, 0755) // パーミッション 0755\n\tif err != nil {\n\t\tlog.Printf(\"Mkdir %s failed: %v\", dirName1, err)\n\t\t// if os.IsExist(err) { /* 既に存在する場合の処理 */ }\n\t} else {\n\t\tfmt.Printf(\"'%s' created.\\n\", dirName1)\n\t}\n\t// os.Remove(dirName1) // 後片付け\n\n\t// os.Mkdir: 親がないとエラー\n\t// err = os.Mkdir(\"parent/child\", 0755)\n\t// if err != nil { fmt.Println(\"Mkdir parent/child error:\", err) }\n\n\t// os.MkdirAll: 親ディレクトリも含めて作成\n\tdirPathAll := \"path/to/nested\"\n\terr = os.MkdirAll(dirPathAll, 0755) // path, path/to も作成\n\tif err != nil {\n\t\tlog.Printf(\"MkdirAll %s failed: %v\", dirPathAll, err)\n\t} else {\n\t\tfmt.Printf(\"'%s' (and parents) created.\\n\", dirPathAll)\n\t}\n\t// os.RemoveAll(\"path\") // 後片付け\n}",
        "tags": [
          "io-operations",
          "os",
          "directory",
          "mkdir",
          "Mkdir",
          "MkdirAll",
          "ディレクトリ作成",
          "パーミッション",
          "IsExist"
        ]
      },
      {
        "title": "I/O 操作: カレントワーキングディレクトリ (`os.Getwd`, `os.Chdir`)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n)\n\nfunc main() {\n\t// 現在のワーキングディレクトリを取得\n\tinitialWd, err := os.Getwd()\n\tif err != nil { log.Fatalf(\"Getwd failed: %v\", err) }\n\tfmt.Printf(\"Initial WD: %s\\n\", initialWd)\n\n\t// (例: 一時ディレクトリを作成)\n\t// tempDir, _ := os.MkdirTemp(\"\", \"chdir-example-*\")\n\t// defer os.RemoveAll(tempDir)\n\t// defer os.Chdir(initialWd) // 元に戻る defer\n\n\t// os.Chdir でワーキングディレクトリを変更 (例: /tmp へ)\n\t// 注意: 存在し、アクセス可能なディレクトリを指定する必要がある\n\ttargetDir := os.TempDir() // システムの一時ディレクトリを取得\n\tfmt.Printf(\"Changing WD to: %s\\n\", targetDir)\n\terr = os.Chdir(targetDir)\n\tif err != nil {\n\t\tlog.Fatalf(\"Chdir to %s failed: %v\", targetDir, err)\n\t}\n\n\t// 変更後のワーキングディレクトリを確認\n\tnewWd, err := os.Getwd()\n\tif err != nil { log.Fatalf(\"Getwd after Chdir failed: %v\", err) }\n\tfmt.Printf(\"New WD: %s\\n\", newWd)\n\n\t// 相対パスでのファイル操作は newWd が基準になる\n\t// os.WriteFile(\"relative.txt\", ...)\n}",
        "tags": [
          "io-operations",
          "os",
          "Getwd",
          "Chdir",
          "ワーキングディレクトリ",
          "カレントディレクトリ",
          "パス"
        ]
      },
      {
        "title": "I/O 操作: ディレクトリエントリの読み込み (`os.ReadDir`, Go 1.16+)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\" // os.ReadDir\n)\n\nfunc main() {\n\ttargetDir := \".\" // カレントディレクトリ\n\n\tfmt.Printf(\"Reading directory '%s'...\\n\", targetDir)\n\n\t// os.ReadDir でエントリを取得\n\tentries, err := os.ReadDir(targetDir)\n\tif err != nil {\n\t\tlog.Fatalf(\"ReadDir failed: %v\", err)\n\t}\n\n\tfmt.Println(\"--- Directory Entries ---\")\n\t// 取得したエントリをループ処理\n\tfor _, entry := range entries {\n\t\t// entry は os.DirEntry\n\t\tfmt.Printf(\" Name: %-20s IsDir: %t\\n\", entry.Name(), entry.IsDir())\n\n\t\t// 詳細情報が必要なら entry.Info() を使う (エラーチェック必要)\n\t\t// info, err := entry.Info()\n\t\t// if err == nil { fmt.Printf(\"  Size: %d\\n\", info.Size()) }\n\t}\n\tfmt.Println(\"-----------------------\")\n}",
        "tags": [
          "io-operations",
          "os",
          "ReadDir",
          "DirEntry",
          "ディレクトリ一覧",
          "ファイル一覧",
          "Go1.16"
        ]
      },
      {
        "title": "I/O 操作: ディレクトリツリーの探索 (`filepath.WalkDir`, Go 1.16+)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/fs\" // fs.DirEntry, fs.WalkDirFunc\n\t\"log\"\n\t\"path/filepath\" // filepath.WalkDir, filepath.SkipDir, filepath.Ext\n\t// \"os\" // テスト用ファイル作成・削除は省略\n)\n\nfunc main() {\n\t// 事前にテスト用ディレクトリ・ファイルを作成しておく想定\n\t// os.MkdirAll(\"tmp/subdir\", 0755)\n\t// os.MkdirAll(\"tmp/.git\", 0755)\n\t// os.WriteFile(\"tmp/file.txt\", ...)\n\t// os.WriteFile(\"tmp/app.log\", ...)\n\t// os.WriteFile(\"tmp/subdir/other.log\", ...)\n\n\troot := \"tmp\" // 探索開始ディレクトリ\n\tfmt.Printf(\"Walking directory '%s'...\\n\", root)\n\n\terr := filepath.WalkDir(root, func(path string, d fs.DirEntry, err error) error {\n\t\t// 1. パスアクセスエラーチェック\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Error accessing path %q: %v\\n\", path, err)\n\t\t\treturn err // エラーがあれば探索中断 (nil を返せば続行)\n\t\t}\n\n\t\t// 2. 特定ディレクトリをスキップ (例: .git)\n\t\tif d.IsDir() && d.Name() == \".git\" {\n\t\t\tfmt.Printf(\"Skipping dir: %s\\n\", path)\n\t\t\treturn filepath.SkipDir // このディレクトリ以下は探索しない\n\t\t}\n\n\t\t// 3. ファイルのみ対象とし、拡張子チェック (例: .log)\n\t\tif !d.IsDir() && filepath.Ext(path) == \".log\" {\n\t\t\tfmt.Printf(\"Found log file: %s\\n\", path)\n\t\t}\n\n\t\treturn nil // 探索続行\n\t})\n\n\tif err != nil {\n\t\tlog.Fatalf(\"WalkDir failed: %v\", err)\n\t}\n\tfmt.Println(\"Walk finished.\")\n\t// os.RemoveAll(root) // 後片付け\n}",
        "tags": [
          "io-operations",
          "os",
          "filepath",
          "WalkDir",
          "WalkDirFunc",
          "fs",
          "DirEntry",
          "ディレクトリ探索",
          "再帰",
          "Go1.16"
        ]
      }
    ]
  },
  {
    "title": "Generics",
    "codeExamples": [
      {
        "title": "ジェネリクス: 型パラメータを持つジェネリック関数",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\n// ジェネリック関数 Print の定義\n// [T any] で型パラメータ T (任意の型) を宣言\nfunc Print[T any](value T) {\n\tfmt.Printf(\"Type: %T, Value: %v\\n\", value, value)\n}\n\nfunc main() {\n\t// 型推論による呼び出し\n\tPrint(42)      // T は int と推論される\n\tPrint(\"hello\") // T は string と推論される\n\n\t// 型の明示的な指定 (通常は不要)\n\t// Print[bool](true)\n}",
        "tags": [
          "generics",
          "ジェネリクス",
          "型パラメータ",
          "type parameter",
          "関数",
          "any",
          "型推論",
          "Go1.18"
        ]
      },
      {
        "title": "ジェネリクス: 複数の型パラメータを持つジェネリック関数",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\n// ジェネリック関数 Map: スライス s ([]T) の各要素に f (func(T) U) を適用し、\n// 結果のスライス ([]U) を返す。\n// [T, U any] で2つの型パラメータ T と U (どちらも任意の型) を定義。\nfunc Map[T, U any](s []T, f func(T) U) []U {\n\tresult := make([]U, len(s))\n\tfor i, v := range s {\n\t\tresult[i] = f(v)\n\t}\n\treturn result\n}\n\nfunc main() {\n\tintSlice := []int{1, 2, 3}\n\tfmt.Printf(\"Input: %v\\n\", intSlice)\n\n\t// 例1: int -> int (2乗)\n\t// T=int, U=int と推論される\n\tsquares := Map(intSlice, func(x int) int { return x * x })\n\tfmt.Printf(\"Squares: %v (%T)\\n\", squares, squares)\n\n\t// 例2: int -> string (フォーマット)\n\t// T=int, U=string と推論される\n\tidStrings := Map(intSlice, func(x int) string { return fmt.Sprintf(\"ID-%d\", x) })\n\tfmt.Printf(\"Strings: %v (%T)\\n\", idStrings, idStrings)\n\n\t// 例3: string -> int (文字数) も可能 (省略)\n\t// stringSlice := []string{\"a\", \"bb\"}\n\t// lengths := Map(stringSlice, func(s string) int { return len(s) })\n}",
        "tags": [
          "generics",
          "ジェネリクス",
          "型パラメータ",
          "type parameter",
          "関数",
          "any",
          "マップ関数"
        ]
      },
      {
        "title": "ジェネリクス: インターフェースによる型制約",
        "description": "型パラメータに `any` を使うと任意の型を受け入れられますが、\n関数内でその型の値に対して行える操作が限られます。\n特定のメソッドや演算を可能にするには**型制約**を課します。\nGoでは型制約は**インターフェース型**で定義します。\n\n**型制約としてのインターフェース:**\n1.  **メソッドセットによる制約:**\n    従来通りインターフェースに必要なメソッドを定義。\n    型パラメータに指定すると、そのメソッドを持つ型のみ受け入れ可能。\n    関数内ではそのメソッドを呼び出せる。",
        "code": "package main\n\nimport \"fmt\"\n\n// 型制約: 組み込みの数値型を許可するインターフェース\ntype Numeric interface {\n\tint | int8 | int16 | int32 | int64 |\n\t\tuint | uint8 | uint16 | uint32 | uint64 | uintptr |\n\t\tfloat32 | float64\n\t// (Go 1.18+ constraints パッケージに同様の定義あり)\n}\n\n// ジェネリック関数 Sum: T は Numeric 制約を満たす必要がある\nfunc Sum[T Numeric](values []T) T {\n\tvar sum T\n\tfor _, v := range values {\n\t\tsum += v // + 演算子が使える (Numeric 内の型は全てサポート)\n\t}\n\treturn sum\n}\n\nfunc main() {\n\tintSlice := []int{1, 2, 3}\n\tintSum := Sum(intSlice) // T=int\n\tfmt.Printf(\"Sum(%v): %v (%T)\\n\", intSlice, intSum, intSum)\n\n\tfloatSlice := []float64{1.1, 2.2}\n\tfloatSum := Sum(floatSlice) // T=float64\n\tfmt.Printf(\"Sum(%v): %v (%T)\\n\", floatSlice, floatSum, floatSum)\n\n\t// stringSlice := []string{\"a\"}\n\t// Sum(stringSlice) // コンパイルエラー (string は Numeric ではない)\n}",
        "tags": [
          "generics",
          "ジェネリクス",
          "型パラメータ",
          "type parameter",
          "型制約",
          "type constraint",
          "interface",
          "any",
          "Union"
        ]
      },
      {
        "title": "ジェネリクス: 定義済みの型制約 (`comparable`, `cmp.Ordered`)",
        "description": "",
        "code": "package main\n\nimport (\n\t\"cmp\" // Go 1.21+\n\t\"fmt\"\n)\n\n// ジェネリック関数 Max: T は順序付け可能 (Ordered) である必要がある\nfunc Max[T cmp.Ordered](a, b T) T {\n\tif a > b { // > 演算子が使える\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc main() {\n\tfmt.Println(\"Max(10, 5):\", Max(10, 5))         // int\n\tfmt.Println(\"Max(3.14, 2.7):\", Max(3.14, 2.7)) // float64\n\tfmt.Println(\"Max(\\\"A\\\", \\\"B\\\"):\", Max(\"A\", \"B\")) // string\n\n\t// --- comparable の例 (参考) ---\n\t// func MapKeys[K comparable, V any](m map[K]V) []K { ... }\n\t// m := map[string]int{\"a\": 1}\n\t// keys := MapKeys(m) // OK: string は comparable\n\n\t// --- エラー例 ---\n\t// Max([]int{1}, []int{2}) // コンパイルエラー (スライスは Ordered ではない)\n}",
        "tags": [
          "generics",
          "ジェネリクス",
          "型制約",
          "type constraint",
          "comparable",
          "cmp",
          "Ordered",
          "比較",
          "順序付け"
        ]
      },
      {
        "title": "\"ジェネリクス: ジェネリックなスタック (データ構造)\"",
        "description": "",
        "code": "package main\n\nimport \"fmt\"\n\n// --- ジェネリック型の定義 ---\n// Stack[T any]: 任意の型 T の値を格納できるスタック\ntype Stack[T any] struct {\n\titems []T // 内部的に T 型のスライスでデータを保持\n}\n\n// --- ジェネリック型に対するメソッド定義 ---\n\n// Push: スタックに要素を追加する\nfunc (s *Stack[T]) Push(item T) {\n\tif s == nil { return }\n\ts.items = append(s.items, item)\n}\n\n// Pop: スタックから要素を取り出して返す\nfunc (s *Stack[T]) Pop() (T, bool) {\n\tif s == nil || len(s.items) == 0 {\n\t\tvar zero T // T 型のゼロ値を返す準備\n\t\treturn zero, false\n\t}\n\tlastIndex := len(s.items) - 1\n\titem := s.items[lastIndex]\n\ts.items = s.items[:lastIndex]\n\treturn item, true\n}\n\n// IsEmpty: スタックが空かどうかを返す\nfunc (s *Stack[T]) IsEmpty() bool {\n\treturn s == nil || len(s.items) == 0\n}\n\nfunc main() {\n\t// --- int 型のスタック ---\n\tintStack := Stack[int]{}\n\tintStack.Push(1)\n\tintStack.Push(2)\n\tv1, ok1 := intStack.Pop() // v1=2, ok1=true\n\tfmt.Printf(\"Pop int: %v, %t\\n\", v1, ok1)\n\tv2, ok2 := intStack.Pop() // v2=1, ok2=true\n\tfmt.Printf(\"Pop int: %v, %t\\n\", v2, ok2)\n\tv3, ok3 := intStack.Pop() // v3=0, ok3=false (空)\n\tfmt.Printf(\"Pop int: %v, %t\\n\", v3, ok3)\n\n\t// --- string 型のスタック ---\n\tstrStack := Stack[string]{}\n\tstrStack.Push(\"A\")\n\tstrStack.Push(\"B\")\n\tsv1, sok1 := strStack.Pop() // sv1=\"B\", sok1=true\n\tfmt.Printf(\"Pop string: %v, %t\\n\", sv1, sok1)\n}\n\n/* 実行結果:\nPop int: 2, true\nPop int: 1, true\nPop int: 0, false\nPop string: B, true\n*/",
        "tags": [
          "generics",
          "ジェネリクス",
          "型パラメータ",
          "type parameter",
          "データ構造",
          "struct",
          "スタック",
          "Stack"
        ]
      },
      {
        "title": "ジェネリクス: スレッドセーフなジェネリックマップ",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\n// スレッドセーフなジェネリックマップ\n// K は比較可能 (comparable), V は任意 (any)\ntype SafeMap[K comparable, V any] struct {\n\tdata map[K]V\n\tmu   sync.RWMutex // 読み書きロックで保護\n}\n\n// コンストラクタ\nfunc NewSafeMap[K comparable, V any]() *SafeMap[K, V] {\n\treturn &SafeMap[K, V]{data: make(map[K]V)}\n}\n\n// Set: 書き込み操作 (Lock/Unlock)\nfunc (m *SafeMap[K, V]) Set(key K, value V) {\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\tm.data[key] = value\n}\n\n// Get: 読み取り操作 (RLock/RUnlock)\nfunc (m *SafeMap[K, V]) Get(key K) (V, bool) {\n\tm.mu.RLock()\n\tdefer m.mu.RUnlock()\n\tval, ok := m.data[key]\n\treturn val, ok\n}\n\n// (Delete, Len などのメソッドも同様に実装可能)\n\nfunc main() {\n\t// string -> int のマップを作成\n\tsafeMap := NewSafeMap[string, int]()\n\n\t// 複数の Goroutine から安全にアクセスできる\n\t// (ここでは main Goroutine からのみアクセス)\n\tsafeMap.Set(\"apple\", 100)\n\tsafeMap.Set(\"banana\", 200)\n\n\tval, ok := safeMap.Get(\"apple\")\n\tif ok { fmt.Println(\"apple:\", val) } // apple: 100\n\n\tval, ok = safeMap.Get(\"grape\")\n\tif !ok { fmt.Println(\"grape: not found\") } // grape: not found\n}",
        "tags": [
          "generics",
          "ジェネリクス",
          "型パラメータ",
          "type parameter",
          "データ構造",
          "struct",
          "マップ",
          "map",
          "sync",
          "RWMutex",
          "スレッドセーフ",
          "comparable"
        ]
      },
      {
        "title": "ジェネリクス: メソッドによる型制約 (`fmt.Stringer` など)",
        "description": "型パラメータに制約を課すもう一つの方法は、\n**メソッドセット**を持つインターフェースを使うことです。\nこれにより、型パラメータが特定のメソッドを持つことを保証できます。\n\n**メソッドセットによる制約:**\n*   型制約として、メソッドシグネチャを持つインターフェースを指定。\n    `type MyInterface interface { MethodA() }`\n*   ジェネリック関数/型で `[T MyInterface]` のように指定。\n*   `T` は `MyInterface` が要求する全メソッドを持つ必要がある。\n*   関数内では `T` 型の値に対し、制約インターフェースのメソッド\n    (`v.MethodA()`) を安全に呼び出せる。\n\n**標準インターフェースの利用: `fmt.Stringer`**\nよく使われるのが `fmt.Stringer` です。",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\n// ジェネリック関数 Join: T は fmt.Stringer を満たす必要がある\nfunc Join[T fmt.Stringer](values []T, sep string) string {\n\tvar sb strings.Builder\n\tfor i, v := range values {\n\t\tif i > 0 { sb.WriteString(sep) }\n\t\t// ★ v.String() メソッドを呼び出せる (制約で保証) ★\n\t\tsb.WriteString(v.String())\n\t}\n\treturn sb.String()\n}\n\n// fmt.Stringer を実装する型\ntype Person struct { Name string; Age int }\nfunc (p Person) String() string { // Stringer を満たす\n\treturn fmt.Sprintf(\"%s(%d)\", p.Name, p.Age)\n}\n\n// type IPAddr [4]byte\n// func (ip IPAddr) String() string { ... } // これも Stringer\n\nfunc main() {\n\tpeople := []Person{{\"Alice\", 30}, {\"Bob\", 25}}\n\t// T=Person (Stringer を満たす)\n\tpeopleStr := Join(people, \", \")\n\tfmt.Println(\"People:\", peopleStr) // People: Alice(30), Bob(25)\n\n\t// addrs := []IPAddr{{127,0,0,1}, {192,168,1,1}}\n\t// addrsStr := Join(addrs, \"; \") // これも OK\n\n\t// nums := []int{1, 2}\n\t// Join(nums, \"-\") // コンパイルエラー (int は Stringer ではない)\n}",
        "tags": [
          "generics",
          "ジェネリクス",
          "型制約",
          "type constraint",
          "interface",
          "メソッドセット",
          "Stringer"
        ]
      },
      {
        "title": "ジェネリクス: メソッドによる比較制約 (Comparable)",
        "description": "組み込みの `comparable` や `cmp.Ordered` 制約は、\n`==`, `<`, `>` などの演算子が使える型に限定されます。\n独自の比較ロジックを持つ構造体など、これらの演算子が\n定義されていない型で比較を行いたい場合は、\n**メソッドセットを持つインターフェース**を型制約として使います。\n\n**メソッドによる比較制約:**\n1. 比較メソッド (例: `CompareTo(other T) int`) を持つ\n   インターフェースを定義する。",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\n// 比較メソッドを持つインターフェース制約\ntype Comparer[T any] interface {\n\t// other より小さい場合に負、等しい場合に 0、大きい場合に正を返す\n\tCompareTo(other T) int\n}\n\n// ジェネリックソート関数 (T は Comparer[T] を満たす必要あり)\nfunc SortSlice[T Comparer[T]](items []T) {\n\tsort.Slice(items, func(i, j int) bool {\n\t\t// ★ CompareTo メソッドを使って比較 ★\n\t\treturn items[i].CompareTo(items[j]) < 0\n\t})\n}\n\n// Comparer[Version] を実装する Version 型\ntype Version struct { Major, Minor, Patch int }\nfunc (v Version) String() string { /* ... */ return fmt.Sprintf(\"v%d.%d.%d\", v.Major, v.Minor, v.Patch) }\nfunc (v Version) CompareTo(other Version) int {\n\tif v.Major != other.Major { return v.Major - other.Major }\n\tif v.Minor != other.Minor { return v.Minor - other.Minor }\n\treturn v.Patch - other.Patch\n}\n\nfunc main() {\n\tversions := []Version{{1, 10, 0}, {1, 9, 5}, {2, 0, 0}}\n\tfmt.Println(\"Before:\", versions)\n\tSortSlice(versions) // T=Version (Comparer[Version] を満たす)\n\tfmt.Println(\"After:\", versions) // [v1.9.5 v1.10.0 v2.0.0]\n}",
        "tags": [
          "generics",
          "ジェネリクス",
          "型制約",
          "type constraint",
          "interface",
          "メソッドセット",
          "comparable",
          "比較"
        ]
      },
      {
        "title": "ジェネリクス: Optional/Maybe 型パターン",
        "description": "関数が値を返す際、その値が**存在する場合**と**存在しない場合**を\n明確に示したいことがあります (例: マップ検索)。\n\nGoでは複数戻り値 (`value, ok := ...`) が一般的ですが、\n他の言語で見られる **Optional** / **Maybe** パターンを\nジェネリクスで実装することも可能です。\n値の有無と値自体を一つの型でカプセル化します。\n\n**実装:**\n*   ジェネリック構造体 `Optional[T any]` を定義。\n*   内部に値 `value T` と有効フラグ `valid bool` を持つ。\n*   `Some(value T)`: 値を持つ Optional (`valid=true`) を作成。\n*   `None[T any]()`: 値を持たない Optional (`valid=false`) を作成。\n    (型パラメータ `T` の指定が必要)\n*   `IsPresent()`, `Get()` 等のメソッドで値の有無確認や取得を行う。\n\nコード例は `Optional[T]` 型とその基本的なコンストラクタ、\nメソッドを示しています。\n\n**使用例:**",
        "code": "package optional // (パッケージ名は例)\n\n// Optional[T any]: T 型の値が存在するかもしれないことを示す型\ntype Optional[T any] struct {\n\tvalue T    // 値 (存在しない場合はゼロ値)\n\tvalid bool // 値が有効か (存在するか)\n}\n\n// Some: 値が存在する Optional を作成\nfunc Some[T any](value T) Optional[T] {\n\treturn Optional[T]{value: value, valid: true}\n}\n\n// None: 値が存在しない Optional を作成\nfunc None[T any]() Optional[T] {\n\treturn Optional[T]{valid: false} // value は T のゼロ値\n}\n\n// IsPresent: 値が存在するかどうか\nfunc (o Optional[T]) IsPresent() bool {\n\treturn o.valid\n}\n\n// Get: 値と存在有無 (bool) を返す (マップのカンマOK風)\nfunc (o Optional[T]) Get() (T, bool) {\n\treturn o.value, o.valid\n}\n\n// (IsEmpty, OrElse などのヘルパーメソッドも追加可能)",
        "tags": [
          "generics",
          "ジェネリクス",
          "型パラメータ",
          "type parameter",
          "データ構造",
          "struct",
          "Optional",
          "Maybe",
          "nil",
          "ゼロ値"
        ]
      },
      {
        "title": "ジェネリクス: Result 型パターン",
        "description": "Go標準のエラー処理は複数戻り値 (`value, err`) ですが、\n他の言語で見られる **Result 型** パターンもジェネリクスで実装可能です。\nResult 型は、操作の**成功値 (`Ok`)** または **失敗エラー (`Err`)** の\n**どちらか一方**を保持し、関数の戻り値を単一の型にまとめます。\n\n**実装:**\n*   ジェネリック構造体 `Result[T any]` を定義。\n*   内部に成功時の値 `value T` と失敗時のエラー `err error` を持つ。\n*   `Success(value T)`: 成功 Result (`err=nil`) を作成。\n*   `Failure[T any](err error)`: 失敗 Result (`value=ゼロ値`) を作成。\n    (型パラメータ `T` の指定が必要)\n*   `IsOk()`, `IsErr()`, `Value()`, `Error()` 等のメソッドで\n    状態確認や値/エラー取得を行う。\n\n**使用例:**",
        "code": "package result // (パッケージ名は例)\n\nimport \"fmt\"\n\n// Result[T any]: 成功時の T 型の値、またはエラーのどちらかを保持\ntype Result[T any] struct {\n\tvalue T\n\terr   error\n}\n\n// Success: 成功 Result を作成\nfunc Success[T any](value T) Result[T] {\n\treturn Result[T]{value: value, err: nil}\n}\n\n// Failure: 失敗 Result を作成\nfunc Failure[T any](err error) Result[T] {\n\treturn Result[T]{err: err} // value はゼロ値\n}\n\n// Failuref: フォーマット文字列から失敗 Result を作成\nfunc Failuref[T any](format string, args ...any) Result[T] {\n\treturn Result[T]{err: fmt.Errorf(format, args...)}\n}\n\n// IsOk: 成功かどうか\nfunc (r Result[T]) IsOk() bool { return r.err == nil }\n\n// IsErr: 失敗かどうか\nfunc (r Result[T]) IsErr() bool { return r.err != nil }\n\n// Value: 成功時の値 (失敗時はゼロ値)\nfunc (r Result[T]) Value() T { return r.value }\n\n// Error: 失敗時のエラー (成功時は nil)\nfunc (r Result[T]) Error() error { return r.err }\n\n// (Unwrap, UnwrapOr などのヘルパーも追加可能)\n// func (r Result[T]) Unwrap() T { if r.IsErr() { panic(...) }; return r.value }\n// func (r Result[T]) UnwrapOr(defaultVal T) T { if r.IsErr() { return defaultVal }; return r.value }",
        "tags": [
          "generics",
          "ジェネリクス",
          "型パラメータ",
          "type parameter",
          "データ構造",
          "struct",
          "Result",
          "エラー処理",
          "関数型プログラミング"
        ]
      },
      {
        "title": "\"ジェネリクス: ジェネリックな Min/Max 関数\"",
        "description": "",
        "code": "package main\n\nimport (\n\t\"cmp\" // Go 1.21+ で Ordered を使うためにインポート\n\t\"fmt\"\n)\n\n// Min は 2 つの順序付け可能な値のうち小さい方を返す\nfunc Min[T cmp.Ordered](a, b T) T {\n\t// cmp.Ordered 制約により < 演算子が使える\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\n// Max は 2 つの順序付け可能な値のうち大きい方を返す (030 で説明済み)\nfunc Max[T cmp.Ordered](a, b T) T {\n\t// cmp.Ordered 制約により > 演算子が使える\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc main() {\n\t// int で使用\n\tfmt.Printf(\"Min(10, 5) = %v\\n\", Min(10, 5)) // 5\n\tfmt.Printf(\"Max(10, 5) = %v\\n\", Max(10, 5)) // 10\n\n\t// float64 で使用\n\tfmt.Printf(\"Min(3.14, 2.71) = %v\\n\", Min(3.14, 2.71)) // 2.71\n\tfmt.Printf(\"Max(3.14, 2.71) = %v\\n\", Max(3.14, 2.71)) // 3.14\n\n\t// string で使用\n\tfmt.Printf(\"Min(\\\"apple\\\", \\\"banana\\\") = %v\\n\", Min(\"apple\", \"banana\")) // \"apple\"\n\tfmt.Printf(\"Max(\\\"apple\\\", \\\"banana\\\") = %v\\n\", Max(\"apple\", \"banana\")) // \"banana\"\n\n\t// Go 1.21 以降では、標準ライブラリに min, max 関数が追加された\n\t// import \"cmp\" // または import \"math\" (Go 1.23+)\n\t// fmt.Println(min(10, 5)) // 5\n\t// fmt.Println(max(3.14, 2.71)) // 3.14\n}\n\n/* 実行結果:\nMin(10, 5) = 5\nMax(10, 5) = 10\nMin(3.14, 2.71) = 2.71\nMax(3.14, 2.71) = 3.14\nMin(\"apple\", \"banana\") = apple\nMax(\"apple\", \"banana\") = banana\n*/",
        "tags": [
          "generics",
          "ジェネリクス",
          "型制約",
          "type constraint",
          "cmp",
          "Ordered",
          "Min",
          "Max"
        ]
      }
    ]
  },
  {
    "title": "References",
    "codeExamples": [
      {
        "title": "\"リファレンス: Go コマンドラインツール\"",
        "description": "",
        "code": "// このセクションにはGoのコード例はありません。\n// Goコマンドはターミナルで実行します。",
        "tags": [
          "references",
          "go command",
          "cli",
          "build",
          "run",
          "test",
          "get",
          "install",
          "fmt",
          "vet",
          "mod",
          "list",
          "doc",
          "version"
        ]
      },
      {
        "title": "\"リファレンス: Go 環境変数\"",
        "description": "Go のツールチェーン (`go` コマンドなど) の動作は、いくつかの**環境変数**によって制御・カスタマイズできます。これらの環境変数は、OS の設定や `go env -w` コマンドで設定できます。\n\n現在の設定値は **`go env`** コマンドで一覧表示できます。特定の変数の値だけを表示するには `go env <変数名>` を使います（例: `go env GOPATH`）。\n\nここでは、特に重要な環境変数をいくつか紹介します。\n\n## 主要な Go 環境変数\n\n*   **`GOOS` と `GOARCH`**:\n    *   `go build` で生成する実行可能ファイルの**ターゲットオペレーティングシステム (`GOOS`)** と**アーキテクチャ (`GOARCH`)** を指定します。\n    *   これにより、例えば macOS 上で Windows 用や Linux 用の実行可能ファイルを簡単に作成（クロスコンパイル）できます。\n    *   設定可能な値の組み合わせは `go tool dist list` で確認できます。\n    *   例:\n        *   Windows 64bit 向け: `GOOS=windows GOARCH=amd64 go build`\n        *   Linux ARM 64bit 向け: `GOOS=linux GOARCH=arm64 go build`\n    *   設定しない場合は、現在の OS とアーキテクチャがデフォルト値となります。\n\n*   **`GOPATH`**:\n    *   Go Modules 導入以前（Go 1.11 より前）に、Go のワークスペース（ソースコードやビルドされたパッケージが置かれる場所）を指定するために使われていました。\n    *   Go Modules が主流の現在では、その重要性は低下しています。通常は設定する必要はなく、デフォルトの場所（通常はホームディレクトリ以下の `go` ディレクトリ、例: `$HOME/go`）が使われます。\n    *   `go install` でインストールされたバイナリは `$GOPATH/bin` (または `$GOBIN`) に置かれます。\n\n*   **`GOROOT`**:\n    *   Go の**インストールディレクトリ**を示します。標準ライブラリのソースコードなどがここにあります。\n    *   通常、Go をインストールする際に自動的に設定され、ユーザーが手動で変更する必要はほとんどありません。\n\n*   **`GOBIN`**:\n    *   `go install` コマンドでビルドされた実行可能ファイルがインストールされるディレクトリを指定します。\n    *   設定されていない場合は、`$GOPATH/bin` がデフォルトで使われます。\n    *   このディレクトリに PATH を通しておくと、インストールした Go 製ツールをコマンド名だけで実行できるようになります。\n\n*   **`GO111MODULE`**:\n    *   Go Modules の有効/無効を制御します。\n        *   `on`: Go Modules を常に有効にします。\n        *   `off`: Go Modules を無効にし、古い `GOPATH` モードで動作します。\n        *   `auto` (デフォルト): カレントディレクトリまたは親ディレクトリに `go.mod` ファイルが存在する場合に Go Modules を有効にします。\n    *   Go 1.16 以降ではデフォルトで `on` (または `auto` で `go.mod` があれば `on`) になるため、通常は明示的に設定する必要はありません。\n\n*   **`GOPROXY`**:\n    *   Go Modules をダウンロードする際に使用する**モジュールプロキシ**の URL を指定します。デフォルトは `https://proxy.golang.org,direct` で、まず Google が運営するプロキシにアクセスし、見つからなければ直接リポジトリ（GitHubなど）にアクセスします。\n    *   企業内などで独自のプロキシサーバーを使いたい場合に設定します。`direct` を指定するとプロキシを使わず直接アクセスします。`off` を指定すると `GOPATH` 内のみを探します。\n\n*   **`GOPRIVATE`, `GONOPROXY`, `GONOSUMDB`**:\n    *   プライベートなリポジトリ（例: GitHub Enterprise や社内 Git サーバー）にあるモジュールを扱う際に、プロキシやチェックサムデータベース (`sum.golang.org`) の対象外とするモジュールパスのパターンを指定します。\n\n*   **`GOFLAGS`**:\n    *   `go` コマンド（`build`, `test`, `run` など）を実行する際に、**常に適用されるフラグ**を指定します。例えば、常に `-tags=mytag` を付けたい場合などに設定します。\n\n*   **`CGO_ENABLED`**:\n    *   C言語のコードを利用する Cgo 機能を有効にするか (`1`) 無効にするか (`0`) を指定します。\n    *   クロスコンパイル時に Cgo を無効にしたい場合（例: `CGO_ENABLED=0 GOOS=linux go build`）などによく使われます。\n\n## 設定方法の例 (macOS/Linux)",
        "code": "// このセクションにはGoのコード例はありません。\n// 環境変数はOSのシェルや `go env -w` コマンドで設定します。",
        "tags": [
          "references",
          "environment variables",
          "go env",
          "GOPATH",
          "GOROOT",
          "GOOS",
          "GOARCH",
          "GO111MODULE"
        ]
      },
      {
        "title": "\"コードスタイル: 変数 (Variables)\"",
        "description": "Goのコードスタイルは、読みやすさと簡潔さを重視します。変数に関する一般的な慣習とスタイルガイドラインは以下の通りです。\n\n## 変数名\n\n*   **キャメルケース (Camel Case):** 複数の単語からなる変数名は、`userCount`, `maxRetries`, `requestBody` のようにキャメルケースを使います。アンダースコア (`_`) は通常使いません。\n*   **短く、しかし明確に:** 変数名は、その役割が明確にわかる範囲で、できるだけ短くするのが好まれます。\n    *   スコープが狭い（数行程度でしか使われない）場合は、`i`, `j` (ループカウンタ), `r` (Reader), `w` (Writer), `b` (byte スライス), `err` (エラー) のような短い名前が慣習的に使われます。\n    *   スコープが広い場合や、より複雑な意味を持つ場合は、`userCount`, `httpClient`, `requestURL` のように、より説明的な名前を使います。\n*   **エクスポートされる変数:** パッケージ外に公開される変数（パッケージレベルで宣言され、大文字で始まる）は、その意味が明確にわかる名前を付け、必要であればドキュメンテーションコメントを追加します。\n*   **頭字語 (Acronyms):** `userID`, `htmlContent`, `jsonEncoder` のように、頭字語は一貫して大文字または小文字にします（例: `UserID` や `HTMLContent` は良いが、`UserId` や `HtmlContent` は避ける）。ただし、`Id` を `ID` とするかどうかは議論があり、プロジェクトやチームの規約に従うのが一般的です。\n\n## 宣言と初期化\n\n*   **`:=` (短縮変数宣言):** 関数内で変数を宣言し、同時に初期値を代入する場合に最もよく使われます。型は初期値から推論されます。（上記「コード」セクション参照）\n*   **`var` 宣言:**\n    *   初期値を指定せずに変数を宣言する場合（ゼロ値で初期化される）。\n    *   変数の型を明示したい場合。\n    *   パッケージレベルで変数を宣言する場合（`:=` は関数内でしか使えない）。\n    *   複数の変数をまとめて宣言する場合（グループ化）。",
        "code": "import \"os\" // os.Open を使うため\n\ncount := 0\nmessage := \"Hello\"\nfile, err := os.Open(\"file.txt\") // os パッケージのインポートが必要な例\n// エラーチェックは省略 (例示のため)\nif err == nil {\n\tdefer file.Close() // ファイルを閉じるのを忘れない\n}",
        "tags": [
          "references",
          "code style",
          "variables",
          "naming",
          "var",
          ":=",
          "ゼロ値",
          "エラー変数"
        ]
      },
      {
        "title": "\"コードスタイル: 定数 (Constants)\"",
        "description": "**定数 (Constant)** は、プログラム実行中に値が変わらない識別子です。Goでは `const` キーワードを使って宣言します。\n\n## 定数名\n\n*   **キャメルケース (Camel Case):** Goの定数名は、**変数と同様にキャメルケース** (`maxConnections`, `defaultTimeout`) を使うのが**一般的**です。\n*   **エクスポート:** パッケージ外に公開する定数は、変数と同様に名前の最初の文字を大文字にします (`MaxConnections`)。非公開なら小文字で始めます (`maxRetries`)。\n*   **すべて大文字は非推奨:** 他の言語で定数によく使われる `ALL_CAPS_WITH_UNDERSCORES` (例: `MAX_CONNECTIONS`) は、**Goの慣習ではありません**。Goではキャメルケースを使用してください。\n\n## 宣言\n\n*   **`const` キーワード:** `const` キーワードを使って宣言します。\n*   **型指定:** 定数は型を持つことができますが、多くの場合、型は初期値から推論されるため省略可能です（型付けなし定数）。型付けなし定数は、より柔軟に扱える利点があります。\n*   **初期値:** 定数は宣言時に必ず値を設定する必要があります。値はコンパイル時に決定できる必要があります（例: 数値リテラル、文字列リテラル、`true`/`false`、他の定数を使った式など）。\n*   **グループ化:** `var` と同様に `const (...)` で複数の定数をまとめて宣言できます。（上記「コード」セクション参照）\n\n## `iota`\n\n`iota` は、`const` 宣言ブロック内で使われる特別な定数ジェネレータです。`iota` は `const` ブロックが登場するたびに `0` にリセットされ、ブロック内の各 `const` 指定（行）ごとに `1` ずつ増加します。連続する定数値を生成するのに便利です。",
        "code": "package config // 例として config パッケージ\n\nimport \"time\"\n\n// パッケージレベルで定数を宣言\nconst defaultPort = 8080 // 型付けなし整数定数 (int になる)\nconst defaultHost = \"localhost\" // 型付けなし文字列定数 (string になる)\n\n// グループ化して宣言\nconst (\n\tStatusOK         = 200 // 型付けなし整数定数\n\tStatusNotFound   = 404\n\tdefaultTimeout   = 30 * time.Second // 型付けなし duration 定数 (time.Duration になる)\n\tMaxIdleConns int = 100              // 型を明示した整数定数 (int)\n)\n\n// エクスポートされる定数 (大文字始まり)\nconst Version = \"v1.2.0\"\n\n// 非公開の定数 (小文字始まり)\nconst internalKey = \"some-internal-value\"\n\n// 非推奨な命名 (Go では使わない)\n// const DEFAULT_PORT = 8080",
        "tags": [
          "references",
          "code style",
          "constants",
          "const",
          "naming",
          "iota"
        ]
      },
      {
        "title": "\"コードスタイル: 関数とメソッド (Functions and Methods)\"",
        "description": "関数とメソッドは Go プログラムの基本的な構成要素です。読みやすく、保守しやすいコードを書くために、以下のスタイルガイドラインに従うことが推奨されます。\n\n## 名前付け\n\n*   **キャメルケース (Camel Case / MixedCaps):** 関数名やメソッド名は、変数や定数と同様にキャメルケースを使います。アンダースコア (`_`) は通常使いません。\n    *   良い例: `getUser`, `CalculateTotal`, `parseRequest`, `ConnectToDatabase`\n    *   悪い例: `get_user`, `calculatetotal`, `Connect_To_Database`\n*   **エクスポート:**\n    *   パッケージ外に公開する関数やメソッドは、名前の最初の文字を**大文字**にします (例: `CalculateTotal`)。\n    *   パッケージ内部でのみ使う関数やメソッドは、名前の最初の文字を**小文字**にします (例: `calculateSubtotal`)。\n*   **明確かつ簡潔に:** 関数名やメソッド名は、その処理内容を明確に、かつ簡潔に表すようにします。動詞または動詞句で始めることが多いです (例: `GetUser`, `Save`, `Validate`)。\n\n## 関数の責務と長さ\n\n*   **単一責任の原則:** 一つの関数は、一つの明確な責務を持つように設計します。複数の異なる処理を一つの大きな関数に詰め込むのは避けましょう。\n*   **短く保つ:** 関数はできるだけ短く、理解しやすい長さに保つように心がけます。数十行を超えるような長い関数は、より小さなヘルパー関数に分割することを検討します。\n\n## 引数と戻り値\n\n*   **引数の型:** （上記「コード」セクション参照）\n*   **エラー処理:** エラーが発生する可能性のある関数は、通常、**最後の戻り値**として `error` 型を返します。成功した場合は `nil` を返します。",
        "code": "// 同じ型の引数が続く場合は型をまとめることができる\nfunc process(id int, name string, age int, city string) // OK\nfunc process(id, age int, name, city string)       // より簡潔",
        "tags": [
          "references",
          "code style",
          "functions",
          "methods",
          "naming",
          "camel case",
          "error handling",
          "return values",
          "documentation"
        ]
      },
      {
        "title": "\"コードスタイル: インターフェース (Interfaces)\"",
        "description": "インターフェースは Go のポリモーフィズム（多態性）を実現する中心的な機能であり、柔軟で疎結合なコードを書くために不可欠です。インターフェースの設計と使い方に関する Go の慣習とスタイルは以下の通りです。\n\n## インターフェース名\n\n*   **`-er` サフィックス:** 単一のメソッドを持つインターフェースの名前は、そのメソッド名に `-er` を付けるのが強い慣習です。これは、そのインターフェースが「～するもの」という能力を表すことを示唆します。\n    *   `Read() ...` メソッドを持つ -> `Reader` (`io.Reader`)\n    *   `Write() ...` メソッドを持つ -> `Writer` (`io.Writer`)\n    *   `ServeHTTP(...)` メソッドを持つ -> `Handler` (`http.Handler`)\n    *   `String() string` メソッドを持つ -> `Stringer` (`fmt.Stringer`)\n*   **複数のメソッド:** 複数のメソッドを持つインターフェースには、必ずしも `-er` を付ける必要はありません。そのインターフェースが表現する概念を表す名前を付けます（例: `sort.Interface`, `database/sql.DB`）。\n*   **`I` プレフィックスは不要:** 他の言語で見られるような `IMyInterface` のようなプレフィックスは Go では使いません。\n\n## インターフェースのサイズ\n\n*   **小さく保つ (Interface Segregation Principle):** Go では、**小さなインターフェース**（メソッド数が少ない、理想的には1つ）を組み合わせることが推奨されます。大きなインターフェースは、実装する側に多くの負担を強いるだけでなく、不必要な依存関係を生み出す可能性があります。\n*   必要なメソッドだけを持つ小さなインターフェースを定義することで、実装の柔軟性が高まり、モック化も容易になります。",
        "code": "// 単一メソッドの例\ntype Reader interface {\n\tRead(p []byte) (n int, err error)\n}\n\ntype Writer interface {\n\tWrite(p []byte) (n int, err error)\n}\n\n// 複数のメソッドの例\ntype ReadWriter interface {\n\tReader // インターフェースの埋め込み\n\tWriter\n}\n\ntype Shape interface {\n    Area() float64\n    Perimeter() float64\n}",
        "tags": [
          "references",
          "code style",
          "interfaces",
          "naming",
          "er suffix",
          "interface segregation"
        ]
      },
      {
        "title": "\"コードスタイル: エラーハンドリング (Error Handling)\"",
        "description": "Go言語のエラーハンドリングは、他の多くの言語の例外処理 (`try-catch`) とは異なり、**エラーを通常の戻り値として扱う**ことを基本としています。このアプローチは、コードの制御フローを明確にし、エラー処理を強制する効果があります。\n\n## 基本原則: エラーは値、明示的にチェックする\n\n*   **エラーは値:** `error` は組み込みのインターフェース型であり、他の値と同様に扱われます。\n*   **明示的なチェック:** エラーを返す可能性のある関数を呼び出した後は、**必ず戻り値のエラーをチェック**します。Goには例外がないため、チェックを怠るとエラーが見過ごされ、プログラムが予期せぬ動作をする可能性があります。\n*   **`if err != nil` パターン:** 最も基本的なエラーチェックの方法です。関数呼び出しの直後に `if err != nil` ブロックを書き、エラーが発生した場合の処理（ログ出力、エラーのラップ、早期リターンなど）を記述します。（上記「コード」セクション参照）\n*   **早期リターン:** エラーが発生した場合は、できるだけ早く関数から `return` する（早期リターン）ことで、正常系のコードのネストを浅く保ち、可読性を高めます。\n\n## エラーメッセージとコンテキスト\n\n*   **エラーメッセージは明確に:** `errors.New` や `fmt.Errorf` でエラーを作成する際は、何が問題だったのかが分かるような明確なメッセージを記述します。\n*   **コンテキストの追加 (`%w`):** 下位の関数から返されたエラーを上位の関数でラップして返す場合、**`fmt.Errorf` の `%w` 動詞を使って元のエラーをラップ**します。これにより、エラーの原因を追跡しやすくなり、`errors.Is` や `errors.As` による判定が可能になります。",
        "code": "import (\n\t\"fmt\"\n\t\"log\" // log.Printf を使うため\n)\n\n// エラーを返す可能性のある関数の例 (仮)\nfunc potentiallyFailingFunction() (string, error) {\n\t// return \"\", errors.New(\"何か問題が発生\") // エラーの場合\n\treturn \"成功時の値\", nil // 成功の場合\n}\n\nfunc main() { // main 関数内で実行する例\n\tvalue, err := potentiallyFailingFunction()\n\tif err != nil {\n\t\t// エラー処理 (例: ログ出力、エラーをラップして return)\n\t\tlog.Printf(\"エラーが発生しました: %v\", err)\n\t\t// main 関数なので return せずに終了する例\n\t\t// return fmt.Errorf(\"処理失敗: %w\", err) // 通常の関数ならこのようにラップして返す\n\t\treturn\n\t}\n\t// 正常系の処理 (err == nil が保証される)\n\tfmt.Println(\"成功:\", value)\n}",
        "tags": [
          "references",
          "code style",
          "error handling",
          "error",
          "if err != nil",
          "panic",
          "recover",
          "%w"
        ]
      },
      {
        "title": "\"コードスタイル: コメント (Comments)\"",
        "description": "Goのコードにおけるコメントは、コードの意図を伝え、可読性を高めるために重要です。Goでは主に2種類のコメントが使われます。\n\n## ドキュメンテーションコメント (Documentation Comments)\n\n*   **目的:** パッケージ、型、関数、メソッド、定数、変数など、**エクスポートされる（公開される）識別子**の役割や使い方を説明するために使われます。\n*   **形式:** コメント対象の識別子の**直前**に、空行を挟まずに `//` で始まるコメント行を記述します。\n*   **書き出し:** コメントの最初の文は、**コメント対象の識別子名で始まる**完全な文（主語＋述語）にするのが強い慣習です。これにより `godoc` が生成するドキュメントが読みやすくなります。\n    *   例: `// User はシステム内のユーザーを表します。`\n    *   例: `// CalculateTotal はアイテムの合計金額を計算して返します。`\n*   **内容:** 何をするのか (What)、なぜそうするのか (Why)、どのように使うのか (How) を簡潔に説明します。自明なことを繰り返すコメントは避けます。\n*   **パッケージコメント:** パッケージ全体の説明は、`package` 宣言の直前に記述します (`// Package mypkg は ...`)。 (`070_packages/020_package-documentation.md` 参照)\n*   **`godoc`:** ドキュメンテーションコメントは `go doc` コマンドや `pkg.go.dev` によって自動的に抽出・整形され、APIドキュメントとして利用されます。（上記「コード」セクション参照）\n\n## 実装コメント (Implementation Comments)\n\n*   **目的:** コードブロックや特定の行について、その**実装の詳細**、**複雑なロジックの意図**、**注意点**、**将来的な改善点 (TODO)** などを説明するために使われます。\n*   **形式:** `//` (行コメント) または `/* ... */` (ブロックコメント) を使います。通常は `//` が好まれます。\n*   **場所:** 説明が必要なコードの近くに記述します。\n*   **内容:** なぜそのように実装したのか (Why) を説明することが重要です。コードが何をしているか (What) をそのまま説明するだけのコメントは、コード自体を読めばわかるため、冗長になることがあります。",
        "code": "package user // 例として user パッケージ\n\nimport \"fmt\"\n\n// User はシステム内のユーザーを表す構造体です。\n// Name と Age フィールドを持ちます。\ntype User struct {\n\tName string\n\tAge  int\n}\n\n// NewUser は新しい User インスタンスを作成して返します。\n// name が空の場合はエラーを返します。\nfunc NewUser(name string, age int) (*User, error) {\n\tif name == \"\" {\n\t\treturn nil, fmt.Errorf(\"ユーザー名は空にできません\")\n\t}\n\t// 実装コメント: 年齢チェックはここでは行わない (将来追加するかも)\n\treturn &User{Name: name, Age: age}, nil\n}\n\n// String は User の文字列表現を返します (fmt.Stringer を満たす)。\nfunc (u *User) String() string {\n\tif u == nil {\n\t\treturn \"<nil>\"\n\t}\n\treturn fmt.Sprintf(\"%s (%d歳)\", u.Name, u.Age)\n}",
        "tags": [
          "references",
          "code style",
          "comments",
          "documentation",
          "godoc"
        ]
      },
      {
        "title": "\"コードスタイル: インデント (Indentation)\"",
        "description": "Go言語のコードスタイルにおいて、インデント（字下げ）に関するルールは非常にシンプルかつ厳格です。\n\n## ルール: インデントにはタブを使う\n\n*   Goのコードでは、インデントには**タブ文字 (`\\t`)** を使用します。スペース文字（通常2つや4つ）を使うことはありません。\n*   このルールは、Goの標準フォーマットツールである **`gofmt`** (または `go fmt` コマンド) によって**自動的に強制**されます。\n\n## `gofmt` / `go fmt` による自動フォーマット\n\nGoには `gofmt` という強力なコードフォーマッターが標準で付属しています (`go fmt` コマンドとして利用可能)。このツールを実行すると、インデント（タブの使用）、スペースの入れ方、括弧の位置、`import` の整理など、Goの標準的なコードスタイルに従ってソースコードが**自動的に整形**されます。\n\n**利点:**\n\n*   **スタイルの統一:** チームやプロジェクト全体でコードの見た目が統一され、読みやすさが向上します。\n*   **議論の不要化:** インデントをタブにするかスペースにするか、スペースなら何個にするか、といった**不毛なスタイル論争を避ける**ことができます。Goでは「`gofmt` が正義」です。\n*   **自動化:** エディタの保存時フックやCI/CDパイプラインに `go fmt` を組み込むことで、常にフォーマットされた状態を保つことができます。\n\n**使い方:**",
        "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tmessage := \"Hello, Go!\"\n\t// ↓ この行はタブでインデントされている\n\tif len(message) > 0 {\n\t\t// ↓ この行もタブでさらにインデントされている\n\t\tfmt.Println(message)\n\t\t// ↓ 同じレベルのインデント\n\t\tanotherVariable := true\n\t\tif anotherVariable {\n\t\t\t// ↓ さらにインデント\n\t\t\tfmt.Println(\"Indented with tabs\")\n\t\t}\n\t} // 対応する閉じ括弧は if と同じレベル\n}",
        "tags": [
          "references",
          "code style",
          "indentation",
          "tabs",
          "gofmt",
          "go fmt"
        ]
      },
      {
        "title": "\"ベストプラクティス: エラーを明示的に処理する\"",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n)\n\nfunc main() {\n\tfileName := \"my_data.txt\"\n\n\t// --- 悪い例: エラーを無視 ---\n\t// file, _ := os.Create(fileName) // エラーを変数 _ で受け取り、無視している\n\t// if file == nil {\n\t// \t// これではエラーの原因がわからない\n\t// \tlog.Println(\"ファイルの作成に失敗しました (原因不明)\")\n\t// \treturn\n\t// }\n\t// defer file.Close()\n\t// _, _ = file.WriteString(\"...\") // 書き込みエラーも無視\n\n\t// --- 良い例: エラーを明示的にチェック ---\n\tfile, err := os.Create(fileName)\n\t// ★ 必ずエラーをチェック ★\n\tif err != nil {\n\t\tlog.Printf(\"ファイルの作成に失敗しました: %v\", err)\n\t\treturn // または他の適切なエラー処理\n\t}\n\tdefer file.Close()\n\n\t_, err = file.WriteString(\"ファイルに書き込むデータ。\\n\")\n\t// ★ 書き込みエラーもチェック ★\n\tif err != nil {\n\t\tlog.Printf(\"ファイルへの書き込みに失敗しました: %v\", err)\n\t\t// 必要であれば、エラーをラップして呼び出し元に返すなども検討\n\t\t// return fmt.Errorf(\"書き込み失敗: %w\", err)\n\t}\n\n\tfmt.Println(\"ファイル操作が（おそらく）成功しました。\")\n\n\t// 後片付け\n\terr = os.Remove(fileName) // 削除エラーもチェックする方がより丁寧\n\tif err != nil {\n\t\tlog.Printf(\"ファイルの削除に失敗しました: %v\", err)\n\t}\n}",
        "tags": [
          "references",
          "best practice",
          "error handling",
          "error",
          "if err != nil"
        ]
      },
      {
        "title": "\"ベストプラクティス: 継承よりコンポジションを優先する\"",
        "description": "オブジェクト指向プログラミングに慣れていると、「継承 (Inheritance)」を使ってコードを再利用したり、is-a (〜は〜の一種である) 関係を表現したりすることがあります。しかし、Go言語には他の多くのオブジェクト指向言語に見られるような**クラス継承の仕組みがありません**。\n\nその代わりに、Goでは**コンポジション (Composition)**、特に**構造体の埋め込み (Embedding)** を使うことが推奨されます。これは \"has-a\" (〜は〜を持つ) 関係を表現し、より柔軟で疎結合な設計を促進します。\n\n## コンポジションと埋め込み\n\n*   **コンポジション:** ある型が、別の型の値を**フィールドとして持つ**ことです。",
        "code": "package main\n\nimport \"fmt\"\n\n// --- 埋め込まれる型: Logger ---\ntype Logger struct {\n\tPrefix string\n}\n\n// Logger のメソッド\nfunc (l *Logger) Log(message string) {\n\tfmt.Printf(\"%s %s\\n\", l.Prefix, message)\n}\n\n// --- 埋め込む型: Server ---\ntype Server struct {\n\tLogger // ★ Logger 型を埋め込む ★\n\tHost   string\n\tPort   int\n}\n\n// Server 独自のメソッド\nfunc (s *Server) Start() {\n\t// ★ 埋め込まれた Logger の Log メソッドを直接呼び出せる ★\n\ts.Log(fmt.Sprintf(\"サーバーを %s:%d で起動します...\", s.Host, s.Port))\n\t// 実際のサーバー起動処理...\n}\n\n// --- 埋め込む型: AdvancedServer (Server を埋め込む) ---\ntype AdvancedServer struct {\n\tServer // ★ Server 型をさらに埋め込む ★\n\tTLS    bool\n}\n\n// AdvancedServer 独自のメソッド (Server のメソッドをオーバーライドも可能)\nfunc (as *AdvancedServer) Start() {\n\t// 埋め込まれた Server の Log メソッドを呼び出す\n\tas.Log(\"AdvancedServer を起動します...\") // Prefix は AdvancedServer.Server.Logger.Prefix が使われる\n\tif as.TLS {\n\t\tas.Log(fmt.Sprintf(\"TLS 有効 (%s:%d)\", as.Host, as.Port))\n\t} else {\n\t\tas.Log(fmt.Sprintf(\"TLS 無効 (%s:%d)\", as.Host, as.Port))\n\t}\n\t// 実際の起動処理...\n\n\t// もし Server の Start を呼び出したい場合は明示的に行う\n\t// as.Server.Start() // これは再帰呼び出しになるので注意！\n}\n\n\nfunc main() {\n\t// --- Server の使用 ---\n\tserver := &Server{\n\t\tHost: \"localhost\",\n\t\tPort: 8080,\n\t\t// Logger フィールドはゼロ値 (Prefix=\"\") で初期化される\n\t}\n\t// 埋め込まれた Logger のフィールドにアクセス\n\tserver.Prefix = \"[BasicServer]\"\n\t// Server のメソッド呼び出し (内部で Logger.Log が呼ばれる)\n\tserver.Start()\n\t// 埋め込まれた Logger のメソッドを直接呼び出し\n\tserver.Log(\"BasicServer 処理完了\")\n\n\tfmt.Println(\"---\")\n\n\t// --- AdvancedServer の使用 ---\n\tadvServer := &AdvancedServer{\n\t\tServer: Server{ // 埋め込む Server を初期化\n\t\t\tHost: \"example.com\",\n\t\t\tPort: 443,\n\t\t\tLogger: Logger{ // Logger も初期化\n\t\t\t\tPrefix: \"[Advanced]\",\n\t\t\t},\n\t\t},\n\t\tTLS: true,\n\t}\n\t// AdvancedServer の Start メソッド呼び出し\n\tadvServer.Start()\n\t// 埋め込まれた Server からさらに埋め込まれた Logger のメソッドを呼び出し\n\tadvServer.Log(\"AdvancedServer 処理完了\") // as.Server.Logger.Log が呼ばれる\n\t// 埋め込まれた Server のフィールドにもアクセス可能\n\tfmt.Printf(\"AdvancedServer Host: %s\\n\", advServer.Host) // as.Server.Host と同じ\n}\n\n/* 実行結果:\n[BasicServer] サーバーを localhost:8080 で起動します...\n[BasicServer] BasicServer 処理完了\n---\n[Advanced] AdvancedServer を起動します...\n[Advanced] TLS 有効 (example.com:443)\n[Advanced] AdvancedServer 処理完了\nAdvancedServer Host: example.com\n*/",
        "tags": [
          "references",
          "best practice",
          "composition",
          "embedding",
          "struct",
          "継承",
          "コンポジション",
          "埋め込み"
        ]
      },
      {
        "title": "\"ベストプラクティス: 依存性注入 (DI) にインターフェースを使う\"",
        "description": "**依存性注入 (Dependency Injection, DI)** は、あるコンポーネント（例: `UserService`）が依存する別のコンポーネント（例: `UserRepository`）を、自身で生成するのではなく、**外部から与えられる（注入される）**ように設計する手法です。\n\nGoでは、この依存関係を表現するために**インターフェース**を使うことが非常に効果的であり、ベストプラクティスとされています。\n\n## なぜ DI にインターフェースを使うのか？\n\n*   **疎結合 (Loose Coupling):** コンポーネントが具体的な実装（例: `PostgresUserRepository`）ではなく、抽象的なインターフェース (`UserRepository`) に依存することで、両者の間の結合度が低くなります。`UserRepository` インターフェースを満たすものであれば、将来的に別の実装（例: `MySQLUserRepository`, `InMemoryUserRepository`）に**簡単に差し替える**ことができます。\n*   **テスト容易性 (Testability):** テスト時には、本番用の実装（例: 実際のデータベースにアクセスする `PostgresUserRepository`）の代わりに、テスト用の**モック実装 (Mock/Stub)** を注入することができます。これにより、外部依存なしにコンポーネント単体のロジックを簡単にテストできます。\n*   **柔軟性と拡張性:** 新しいデータストア実装を追加する場合でも、インターフェースを満たしていれば、既存の `UserService` コードを変更する必要がありません。\n\n## インターフェースを使った DI の実装パターン\n\n1.  **依存される側の機能をインターフェースとして定義:** 依存されるコンポーネントが提供すべきメソッドをインターフェースとして定義します（通常は利用側で定義します）。",
        "code": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t// service \"path/to/user/service\" // 仮のインポートパス\n\t// postgres \"path/to/user/postgres\" // 仮のインポートパス\n\t// memory \"path/to/user/memory\" // 仮のインポートパス\n)\n\n// --- インターフェース定義 (利用側) ---\ntype Notifier interface {\n\tNotify(message string) error\n}\n\n// --- 依存するコンポーネント ---\ntype OrderProcessor struct {\n\tnotifier Notifier // ★ インターフェース型のフィールド\n}\n\n// コンストラクタで依存性を注入\nfunc NewOrderProcessor(notifier Notifier) *OrderProcessor {\n\treturn &OrderProcessor{notifier: notifier}\n}\n\nfunc (p *OrderProcessor) ProcessOrder(orderID string) error {\n\tfmt.Printf(\"注文 %s を処理中...\\n\", orderID)\n\t// ... 注文処理ロジック ...\n\n\t// 処理完了を通知 (インターフェース経由で呼び出し)\n\tnotification := fmt.Sprintf(\"注文 %s の処理が完了しました。\", orderID)\n\terr := p.notifier.Notify(notification) // ★ 具体的な実装を知らない\n\tif err != nil {\n\t\t// 通知失敗時の処理 (例: ログ出力)\n\t\tlog.Printf(\"通知失敗 (注文 %s): %v\", orderID, err)\n\t\t// ここではエラーを返さないとする (通知は補助的な機能)\n\t}\n\treturn nil\n}\n\n// --- 具体的な実装 ---\n\n// EmailNotifier: メールで通知する実装\ntype EmailNotifier struct {\n\tAdminEmail string\n}\n\nfunc (n *EmailNotifier) Notify(message string) error {\n\tfmt.Printf(\"メール送信先 '%s': %s\\n\", n.AdminEmail, message)\n\t// 実際のメール送信処理...\n\treturn nil // 成功したとする\n}\n\n// SlackNotifier: Slack で通知する実装\ntype SlackNotifier struct {\n\tWebhookURL string\n}\n\nfunc (n *SlackNotifier) Notify(message string) error {\n\tfmt.Printf(\"Slack 送信先 '%s': %s\\n\", n.WebhookURL, message)\n\t// 実際の Slack 送信処理...\n\tif message == \"\" { return errors.New(\"空のメッセージは送信できません\") } // エラー例\n\treturn nil\n}\n\n// --- 組み立て (main) ---\nfunc main() {\n\t// --- EmailNotifier を注入 ---\n\temailNotifier := &EmailNotifier{AdminEmail: \"admin@example.com\"}\n\tprocessor1 := NewOrderProcessor(emailNotifier) // インターフェースを満たす EmailNotifier を渡す\n\tprocessor1.ProcessOrder(\"Order-A1\")\n\n\tfmt.Println(\"---\")\n\n\t// --- SlackNotifier を注入 ---\n\tslackNotifier := &SlackNotifier{WebhookURL: \"https://hooks.slack.com/...\"}\n\tprocessor2 := NewOrderProcessor(slackNotifier) // インターフェースを満たす SlackNotifier を渡す\n\tprocessor2.ProcessOrder(\"Order-B2\")\n\n\t// --- UserRepository の例 (コメントアウト) ---\n\t// // 本番環境では PostgresRepo を注入\n\t// dbRepo := postgres.NewPostgresRepo(...)\n\t// userService := service.NewUserService(dbRepo)\n\t// // userService を使った処理...\n\n\t// // テスト環境では InMemoryRepo を注入できる\n\t// // testRepo := memory.NewInMemoryRepo()\n\t// // testUserService := service.NewUserService(testRepo)\n}\n\n/* 実行結果:\n注文 Order-A1 を処理中...\nメール送信先 'admin@example.com': 注文 Order-A1 の処理が完了しました。\n---\n注文 Order-B2 を処理中...\nSlack 送信先 'https://hooks.slack.com/...': 注文 Order-B2 の処理が完了しました。\n*/",
        "tags": [
          "references",
          "best practice",
          "dependency injection",
          "di",
          "interfaces",
          "疎結合",
          "テスト容易性"
        ]
      },
      {
        "title": "\"ベストプラクティス: Context を使う\"",
        "description": "",
        "code": "package main\n\nimport (\n\t\"context\"\n\t\"errors\" // errors.Is を使うため\n\t\"fmt\"\n\t\"time\"\n\t// \"myproject/service\" // 仮のサービスパッケージ\n)\n\n// Context を受け取るサービス関数 (仮)\nfunc doWorkWithContext(ctx context.Context, input string) (string, error) {\n\tfmt.Printf(\"  (doWork: '%s' の処理開始)\\n\", input)\n\tselect {\n\tcase <-time.After(100 * time.Millisecond): // 時間のかかる処理を模倣\n\t\tfmt.Printf(\"  (doWork: '%s' の処理完了)\\n\", input)\n\t\treturn \"結果:\" + input, nil\n\tcase <-ctx.Done(): // キャンセルをチェック\n\t\tfmt.Printf(\"  (doWork: '%s' の処理キャンセル: %v)\\n\", input, ctx.Err())\n\t\treturn \"\", ctx.Err()\n\t}\n}\n\nfunc main() {\n\t// 1. 起点となる Context\n\trootCtx := context.Background()\n\n\t// 2. タイムアウト付き Context を生成\n\tctx, cancel := context.WithTimeout(rootCtx, 50*time.Millisecond) // 50ms でタイムアウト\n\t// 3. defer cancel()\n\tdefer cancel()\n\n\tfmt.Println(\"処理を開始します...\")\n\t// 4. Context を関数に渡す\n\tresult, err := doWorkWithContext(ctx, \"my-data\")\n\n\t// 6. (doWorkWithContext 内で) ctx.Done() がチェックされる\n\t// 7. エラーをチェック (タイムアウトを検知)\n\tif err != nil {\n\t\tfmt.Printf(\"エラーが発生しました: %v\\n\", err)\n\t\tif errors.Is(err, context.DeadlineExceeded) {\n\t\t\tfmt.Println(\"-> タイムアウトが原因です。\")\n\t\t}\n\t} else {\n\t\tfmt.Printf(\"成功しました: %s\\n\", result)\n\t}\n}\n\n/* 実行結果:\n処理を開始します...\n  (doWork: 'my-data' の処理開始)\n  (doWork: 'my-data' の処理キャンセル: context deadline exceeded)\nエラーが発生しました: context deadline exceeded\n-> タイムアウトが原因です。\n*/",
        "tags": [
          "references",
          "best practice",
          "context",
          "concurrency",
          "cancel",
          "timeout",
          "deadline"
        ]
      },
      {
        "title": "\"ベストプラクティス: パッケージレベルの状態を避ける\"",
        "description": "",
        "code": "package main\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\t// \"myproject/db\" // ダミー\n\t_ \"github.com/lib/pq\" // Postgres ドライバ (例)\n)\n\n// --- 悪い例: パッケージレベルの変数 ---\nvar globalDB *sql.DB // グローバルなDB接続 (非推奨)\n\nfunc InitGlobalDB(dataSourceName string) {\n\tvar err error\n\t// globalDB, err = sql.Open(\"postgres\", dataSourceName) // 実際のコード\n\tglobalDB, err = openDummyDB() // ダミー\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\n// globalDB に暗黙的に依存する関数\nfunc GetUserNameByIDGlobal(userID int) (string, error) {\n\tif globalDB == nil {\n\t\treturn \"\", fmt.Errorf(\"データベースが初期化されていません\")\n\t}\n\t// return globalDB.QueryRow(...).Scan(...) // globalDB を直接使う\n\tfmt.Printf(\"  (GetUserNameByIDGlobal: globalDB を使って ID %d を検索)\\n\", userID)\n\treturn fmt.Sprintf(\"User-%d\", userID), nil // ダミー\n}\n\n\n// --- 良い例: 構造体と依存性注入 ---\ntype UserService struct {\n\tdb *sql.DB // ★ 依存関係をフィールドとして持つ ★\n}\n\n// コンストラクタで依存性を注入\nfunc NewUserService(db *sql.DB) *UserService {\n\tif db == nil {\n\t\t// コンストラクタで nil チェックを行うのがより安全\n\t\tlog.Println(\"警告: NewUserService に nil の *sql.DB が渡されました\")\n\t}\n\treturn &UserService{db: db}\n}\n\n// メソッドは構造体のフィールド (db) を使う\nfunc (s *UserService) GetUserNameByID(userID int) (string, error) {\n\tif s.db == nil {\n\t\treturn \"\", fmt.Errorf(\"UserService の db が nil です\")\n\t}\n\t// return s.db.QueryRow(...).Scan(...) // フィールド db を使う\n\tfmt.Printf(\"  (UserService.GetUserNameByID: s.db を使って ID %d を検索)\\n\", userID)\n\treturn fmt.Sprintf(\"User-%d\", userID), nil // ダミー\n}\n\n\nfunc main() {\n\t// --- 悪い例の使い方 ---\n\t// InitGlobalDB(\"user=pqgotest dbname=pqgotest sslmode=verify-full\") // 初期化が必要\n\t// name1, err1 := GetUserNameByIDGlobal(1) // グローバル変数に依存\n\t// fmt.Printf(\"悪い例: %s, %v\\n\", name1, err1)\n\n\t// --- 良い例の使い方 ---\n\t// 依存関係 (DB接続) を main などで初期化\n\t// dbConn, err := sql.Open(\"postgres\", \"...\")\n\tdbConn, err := openDummyDB() // ダミー\n\tif err != nil { log.Fatal(err) }\n\tdefer dbConn.Close()\n\n\t// 依存性を注入して UserService を作成\n\tuserService := NewUserService(dbConn)\n\n\t// UserService のメソッドを呼び出す\n\tname2, err2 := userService.GetUserNameByID(2)\n\tfmt.Printf(\"良い例: %s, %v\\n\", name2, err2)\n}\n\n// ダミー関数\nfunc openDummyDB() (*sql.DB, error) { return &sql.DB{}, nil }\n\n/* 実行結果:\n良い例: User-2, <nil>\n*/",
        "tags": [
          "references",
          "best practice",
          "package state",
          "global variables",
          "dependency injection",
          "struct"
        ]
      },
      {
        "title": "\"ベストプラクティス: クリーンアップに `defer` を使う\"",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"sync\"\n)\n\n// ファイル処理の例\nfunc processFile(filename string) error {\n\tfmt.Printf(\"\\nファイル '%s' を処理中...\\n\", filename)\n\tf, err := os.Open(filename)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"オープン失敗: %w\", err)\n\t}\n\t// ★ ファイルを開いた直後に Close を defer で登録 ★\n\tdefer func() {\n\t\tfmt.Printf(\"defer: '%s' をクローズします。\\n\", filename)\n\t\tif err := f.Close(); err != nil {\n\t\t\t// Close のエラーも考慮する (080_error-handling/180 参照)\n\t\t\tlog.Printf(\"警告: ファイルクローズ失敗: %v\", err)\n\t\t}\n\t}()\n\n\t// ... ファイル f を使った処理 ...\n\tfmt.Println(\"ファイルを読み込み中...\")\n\t// 例: 途中でエラーが発生して return する場合でも defer は実行される\n\t// if someCondition {\n\t// \treturn errors.New(\"処理中にエラー発生\")\n\t// }\n\n\tfmt.Println(\"ファイル処理完了。\")\n\treturn nil // 正常終了時も defer は実行される\n}\n\n// Mutex の例\nvar mu sync.Mutex\nvar counter int\n\nfunc incrementCounter() {\n\tmu.Lock() // ロックを取得\n\t// ★ ロック取得直後に Unlock を defer で登録 ★\n\tdefer func() {\n\t\tfmt.Println(\"defer: アンロックします。\")\n\t\tmu.Unlock()\n\t}()\n\n\tfmt.Println(\"カウンターをインクリメントします...\")\n\tcounter++\n\t// 例: ここで panic が発生しても defer は実行される\n\t// if counter == 1 { panic(\"意図的なパニック\") }\n}\n\nfunc main() {\n\t// ファイル処理の呼び出し\n\t// 一時ファイルを作成\n\ttempFile, err := os.CreateTemp(\"\", \"defer_example_*.txt\")\n\tif err != nil {\n\t\tlog.Fatalf(\"一時ファイルの作成に失敗: %v\", err)\n\t}\n\tfileName := tempFile.Name()\n\ttempFile.WriteString(\"data\")\n\ttempFile.Close() // CreateTemp で開かれたファイルを一旦閉じる\n\n\terr = processFile(fileName)\n\tif err != nil {\n\t\tlog.Printf(\"processFile エラー: %v\", err)\n\t}\n\tos.Remove(fileName) // 後片付け\n\n\tfmt.Println(\"---\")\n\n\t// Mutex 処理の呼び出し\n\tincrementCounter()\n\tfmt.Printf(\"現在のカウンター: %d\\n\", counter)\n}\n\n/* 実行結果 (一時ファイル名は実行ごとに変わる):\nファイル '/var/folders/.../defer_example_....txt' を処理中...\nファイルを読み込み中...\nファイル処理完了。\ndefer: '/var/folders/.../defer_example_....txt' をクローズします。\n---\nカウンターをインクリメントします...\ndefer: アンロックします。\n現在のカウンター: 1\n*/",
        "tags": [
          "references",
          "best practice",
          "defer",
          "cleanup",
          "Close",
          "Unlock",
          "リソース管理"
        ]
      },
      {
        "title": "\"リファレンス: 基本的なテスト関数\"",
        "description": "Go言語は、標準で**テスト**の仕組みを言語とツールチェーンに組み込んでいます。これにより、コードの品質を維持し、リグレッション（意図しない変更によるバグの再発）を防ぐことが容易になります。\n\n## テストファイルの規約\n\n*   テストコードは、テスト対象のコードと同じパッケージディレクトリ内に置きます。\n*   テストコードを含むファイル名は、**`_test.go`** というサフィックスで終わる必要があります（例: `mypackage_test.go`, `utils_test.go`）。\n*   テストファイル内のパッケージ名は、通常2つの選択肢があります。\n    *   **`package mypackage`**: テスト対象と同じパッケージ名にします。これにより、テストコードからパッケージ内の**非公開**な関数や変数にもアクセスできます（ユニットテスト向け）。\n    *   **`package mypackage_test`**: テスト対象のパッケージ名に `_test` サフィックスを付けた、**別のパッケージ**として扱います。この場合、テストコードはテスト対象パッケージの**公開**された API のみをテストすることになります（インテグレーションテストやブラックボックステストに近い）。こちらが推奨されることが多いです。\n\n## テスト関数の規約\n\n*   テスト関数は `testing` パッケージをインポート (`import \"testing\"`) します。\n*   関数名は **`Test`** で始まり、その後に続く名前の最初の文字は**大文字**である必要があります（例: `TestMyFunction`, `TestCalculateTotal`）。\n*   関数は **`*testing.T` 型の引数を一つだけ**受け取ります。この `t` パラメータは、テストの失敗を報告したり、ログを出力したりするためのメソッドを提供します。\n*   戻り値はありません。\n\n**シグネチャ:** `func TestXxx(t *testing.T) { ... }`\n\n## テストの失敗を報告する\n\n`*testing.T` が提供する主なメソッドを使って、テストが失敗したことを報告します。\n\n*   **`t.Errorf(format string, args ...any)`**: `fmt.Sprintf` と同じようにメッセージをフォーマットし、それを**エラーとして記録**します。テストの実行は**継続**されます。\n*   **`t.Fatalf(format string, args ...any)`**: `Errorf` と同様にメッセージをエラーとして記録しますが、その後すぐに現在のテスト関数**を終了**させます（`runtime.Goexit()` を呼び出します）。同じテスト関数内の後続のチェックは実行されません。\n*   **`t.Error(args ...any)`**: `fmt.Sprint` と同じように引数をフォーマットし、エラーとして記録します（`Errorf` の簡易版）。テストは継続されます。\n*   **`t.Fatal(args ...any)`**: `Error` と同様に引数をフォーマットし、エラーとして記録した後、テスト関数を終了させます（`Fatalf` の簡易版）。\n*   **`t.Logf(format string, args ...any)` / `t.Log(args ...any)`**: テストに関する情報をログとして記録します。テストが失敗した場合や `-v` フラグ付きで実行された場合に表示されます。\n\n## テストコード例\n\n簡単な足し算関数 `Add` をテストする例です。\n\n**テストコード (`mathutil/add_test.go` - 例):**",
        "code": "// テスト対象のコード (例: mathutil/add.go)\npackage mathutil\n\n// Add は 2 つの整数を加算します。\nfunc Add(a, b int) int {\n\treturn a + b\n}",
        "tags": [
          "references",
          "testing",
          "go test",
          "TestXxx",
          "t.Errorf",
          "t.Fatalf"
        ]
      },
      {
        "title": "\"リファレンス: テーブル駆動テスト (Table-Driven Tests)\"",
        "description": "Goのテストにおいて、同じ関数に対して複数の異なる入力と期待される出力でテストを行いたい場合、**テーブル駆動テスト (Table-Driven Tests)** というパターンが広く使われ、推奨されています。\n\nこれは、テストケース（入力値、期待される出力、テスト名など）をテーブル（通常は構造体のスライス）として定義し、ループを使って各テストケースを反復処理する書き方です。\n\n## テーブル駆動テストの利点\n\n*   **テストケースの追加・管理が容易:** 新しいテストケースを追加するには、テーブルに新しい要素を追加するだけで済みます。\n*   **コードの重複削減:** テストの実行ロジック（関数の呼び出しと比較）はループ内に一度だけ記述すれば良いため、テストケースごとにコードをコピー＆ペーストする必要がありません。\n*   **可読性の向上:** テストデータとテストロジックが分離され、どのようなケースをテストしているのかが分かりやすくなります。\n*   **サブテスト (`t.Run`) との連携:** 各テストケースを `t.Run` を使ってサブテストとして実行することで、どのケースが失敗したかが明確になり、特定のサブテストだけを実行することも可能になります。\n\n## テーブル駆動テストの構造\n\n1.  **テストケース用構造体の定義:** 各テストケースの入力値、期待される出力、そしてテストケースを識別するための名前などを保持する構造体を定義します（無名構造体を使うことも多いです）。\n2.  **テストデータの作成:** 定義した構造体のスライスを作成し、具体的なテストケースのデータを要素として格納します。\n3.  **ループによる反復処理:** 作成したテストデータのスライスを `for` ループで反復処理します。\n4.  **`t.Run` によるサブテストの実行:** ループ内で `t.Run(テストケース名, func(t *testing.T) { ... })` を呼び出します。\n    *   第一引数には、テストケースを識別するためのユニークな名前（通常はテストケース構造体の名前フィールド）を渡します。\n    *   第二引数には、実際のテストロジック（テスト対象関数の呼び出し、結果の比較、`t.Errorf`/`t.Fatalf` による失敗報告）を含む無名関数を渡します。\n    *   **注意:** ループ変数をサブテストの無名関数内で直接使う場合は、クロージャの落とし穴を避けるために、ループ内で変数をコピーする必要があります（例: `tt := tt`）。(Go 1.22以降では不要になる場合があります)\n\n## テストコード例: `Add` 関数のテーブル駆動テスト\n\n前のセクションで使った `Add` 関数をテーブル駆動テストで書き直してみます。\n\n**テストコード (`mathutil/add_test.go` - 例):**",
        "code": "// テスト対象のコード (例: mathutil/add.go)\npackage mathutil\n\nfunc Add(a, b int) int { return a + b }",
        "tags": [
          "references",
          "testing",
          "go test",
          "table-driven",
          "t.Run",
          "サブテスト"
        ]
      },
      {
        "title": "\"リファレンス: ベンチマーク関数 (Benchmark Functions)\"",
        "description": "Goの `testing` パッケージは、ユニットテストだけでなく、コードの**パフォーマンスを測定**するための**ベンチマークテスト**の機能も提供しています。ベンチマークテストを使うことで、特定の関数の実行時間を計測し、最適化の効果を確認したり、異なる実装のパフォーマンスを比較したりすることができます。\n\n## ベンチマークファイルの規約\n\n*   ベンチマーク関数も、通常のテスト関数と同様に **`_test.go`** ファイル内に記述します。\n*   `testing` パッケージをインポートします (`import \"testing\"`)。\n\n## ベンチマーク関数の規約\n\n*   関数名は **`Benchmark`** で始まり、その後に続く名前の最初の文字は**大文字**である必要があります（例: `BenchmarkMyFunction`, `BenchmarkCalculateFibonacci`）。\n*   関数は **`*testing.B` 型の引数を一つだけ**受け取ります。この `b` パメータは、ベンチマークの実行を制御するためのフィールドやメソッドを提供します。\n*   戻り値はありません。\n\n**シグネチャ:** `func BenchmarkXxx(b *testing.B) { ... }`\n\n## ベンチマークの実行ループ: `b.N`\n\n*   ベンチマーク関数の主な役割は、測定対象のコードを**繰り返し実行**することです。\n*   `*testing.B` 型のフィールド **`N`** は、テストフレームワークが**自動的に決定する反復回数**を表します。ベンチマーク関数内の `for` ループは、`i := 0; i < b.N; i++` のように、`b.N` 回繰り返すように記述します。\n*   `go test -bench` コマンドは、測定対象のコードが安定した実行時間を示すまで `b.N` の値を増やしながらベンチマーク関数を複数回実行し、1操作あたりの平均実行時間などを算出します。\n\n## ベンチマークの実行: `go test -bench`\n\nベンチマークテストを実行するには、`go test` コマンドに **`-bench`** フラグを付けて実行します。\n\n*   **`go test -bench=. [パッケージ]`**: 指定したパッケージ内のすべてのベンチマーク関数を実行します (`.` はすべてのベンチマークにマッチする正規表現)。\n*   **`go test -bench=BenchmarkMyFunction [パッケージ]`**: 特定のベンチマーク関数のみを実行します。\n*   **`go test -bench=. -benchmem`**: `-benchmem` フラグを付けると、1操作あたりのメモリ割り当て回数と割り当てバイト数も表示されます。\n*   **`go test -bench=. -count=5`**: `-count` フラグで各ベンチマークの実行回数を指定できます。\n\n## ベンチマークコード例\n\n簡単な文字列結合関数のベンチマーク例です。\n\n**ベンチマークコード (`stringutil/join_test.go` - 例):**",
        "code": "// テスト対象のコード (例: stringutil/join.go)\npackage stringutil\n\nimport \"strings\"\n\n// JoinWithPlus は + 演算子で文字列を結合します。\nfunc JoinWithPlus(strs []string) string {\n\tresult := \"\"\n\tfor _, s := range strs {\n\t\tresult += s // + 演算子は毎回新しい文字列を生成するため非効率な場合がある\n\t}\n\treturn result\n}\n\n// JoinWithBuilder は strings.Builder で文字列を結合します。\nfunc JoinWithBuilder(strs []string) string {\n\tvar sb strings.Builder\n\tfor _, s := range strs {\n\t\tsb.WriteString(s) // Builder は効率的にメモリを管理\n\t}\n\treturn sb.String()\n}",
        "tags": [
          "references",
          "testing",
          "benchmark",
          "go test -bench",
          "performance",
          "b.N"
        ]
      },
      {
        "title": "\"リファレンス: Example 関数 (テスト可能なドキュメント)\"",
        "description": "",
        "code": "package examples_test // 通常は _test パッケージ\n\nimport (\n\t\"fmt\"\n\t// \"myproject/mypackage\" // 例として使うパッケージ (仮)\n)\n\n// パッケージ全体の簡単な使用例\nfunc Example() {\n\tfmt.Println(\"これはパッケージレベルの Example です。\")\n\t// Output: これはパッケージレベルの Example です。\n}\n\n// Add 関数の使用例\nfunc ExampleAdd() {\n\t// sum := mypackage.Add(1, 2) // 実際にはテスト対象の関数を呼び出す\n\tsum := 1 + 2 // 簡単のため直接計算\n\tfmt.Println(sum)\n\t// Output: 3\n}\n\n// 複数の出力がある例\nfunc ExampleMultipleOutput() {\n\tfmt.Println(\"Line 1\")\n\tfmt.Println(\"Line 2\")\n\t// Output:\n\t// Line 1\n\t// Line 2\n}\n\n// 出力がない (ドキュメント用のみ) 例\nfunc ExampleNoOutput() {\n\t// この関数は go test では実行されるが、出力の検証は行われない\n\t// ドキュメントにはコード例として表示される\n\tfmt.Println(\"この出力は検証されません。\")\n}\n\n// サフィックス付きの例 (同じ関数に対する別の例)\nfunc ExampleAdd_second() {\n\tsum := 10 + (-5)\n\tfmt.Println(sum)\n\t// Output: 5\n}\n\n/*\nテスト実行コマンド: go test . または go test -v .\n\n実行結果 (すべて成功する場合):\nPASS\nok  \tmyproject/examples\t0.XXXs\n\n実行結果 (ExampleAdd の Output が間違っている場合、例: // Output: 4):\n--- FAIL: ExampleAdd (0.00s)\ngot:\n3\nwant:\n4\nFAIL\nexit status 1\nFAIL\tmyproject/examples\t0.XXXs\n*/",
        "tags": [
          "references",
          "testing",
          "example",
          "godoc",
          "documentation",
          "go test"
        ]
      },
      {
        "title": "\"リファレンス: テストのためのモック (Mocking)\"",
        "description": "ユニットテストを行う際、テスト対象のコードが依存している外部コンポーネント（データベース、外部API、ファイルシステムなど）があると、テストの実行が遅くなったり、外部の状態に依存して不安定になったり、テストのセットアップが複雑になったりします。\n\nこのような問題を解決するために、テスト時には外部依存性を**モック (Mock)** や**スタブ (Stub)**、**フェイク (Fake)** といったテスト用の代役オブジェクトに置き換える手法がよく使われます。Goでは、**インターフェース**と**依存性注入 (DI)** を組み合わせることで、これを容易に実現できます。\n\n## モックとは？ なぜ使うのか？\n\n*   **モック/スタブ/フェイク:** テスト対象が依存するコンポーネントの代わりとして振る舞うオブジェクト。テストに必要な最小限の機能（特定のメソッド呼び出しに対して決められた値を返す、呼び出されたことを記録するなど）を提供します。（用語の厳密な使い分けは文脈によりますが、ここでは広く「モック」と呼びます。）\n*   **目的:**\n    *   **外部依存性の排除:** データベースやネットワーク接続が不要になり、テストが高速かつ安定します。\n    *   **テスト対象の分離:** テスト対象コンポーネントのロジックのみに集中してテストできます。\n    *   **特定の状況のシミュレーション:** 依存コンポーネントがエラーを返す場合や、特定のデータを返す場合など、通常では再現しにくい状況を簡単に作り出すことができます。\n\n## インターフェースと DI によるモックの実現\n\n**「ベストプラクティス: 依存性注入 (DI) にインターフェースを使う」** (`130_references/110_best-practice-use-interfaces-for-di.md`) で説明したように、依存関係をインターフェースで定義し、外部から注入する設計にしておくことが鍵となります。\n\n1.  **インターフェース定義:** 依存される側の機能（例: データストア）をインターフェース (`UserStore`) として定義します。\n2.  **依存する側の実装:** テスト対象のコンポーネント (`UserHandler`) は、具体的な実装ではなく、このインターフェース (`UserStore`) に依存するようにします。\n3.  **モック実装の作成:** テストコード (`_test.go` ファイル内) で、依存インターフェース (`UserStore`) を満たす**モック用の構造体** (`mockUserStore`) を定義し、テストに必要な振る舞い（例: 特定のIDに対して特定のユーザーを返す）を実装します。\n4.  **テスト実行:** テスト関数内でモックのインスタンスを作成し、それをテスト対象コンポーネントのコンストラクタなどに**注入**してテストを実行します。\n\n## テストコード例: `UserHandler` のテスト\n\n`UserStore` インターフェースに依存する `UserHandler` をテストする例です。\n\n**テストコード (`handler/user_handler_test.go` - 例):**",
        "code": "// テスト対象のコード (例: handler/user_handler.go)\npackage handler\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t// \"myproject/model\" // 仮のモデルパッケージ\n)\n\n// User モデル (仮)\ntype User struct { ID, Name string }\n\n// UserStore インターフェース (依存される側)\ntype UserStore interface {\n\tGetUser(id string) (*User, error)\n}\n\n// UserHandler (テスト対象、UserStore に依存)\ntype UserHandler struct {\n\tstore UserStore // ★ インターフェースに依存\n}\n\n// コンストラクタ\nfunc NewUserHandler(store UserStore) *UserHandler {\n\treturn &UserHandler{store: store}\n}\n\n// GetUser ハンドラメソッド (例)\nfunc (h *UserHandler) GetUser(id string) (*User, error) {\n\tif id == \"\" {\n\t\treturn nil, errors.New(\"ID が空です\")\n\t}\n\tuser, err := h.store.GetUser(id) // ★ インターフェース経由で呼び出し\n\tif err != nil {\n\t\t// エラーをラップするなど\n\t\treturn nil, fmt.Errorf(\"ユーザー取得失敗: %w\", err)\n\t}\n\treturn user, nil\n}",
        "tags": [
          "references",
          "testing",
          "mocking",
          "stub",
          "fake",
          "dependency injection",
          "interfaces",
          "テスト容易性"
        ]
      },
      {
        "title": "\"デザインパターン: 関数オプションパターン (Function Options Pattern)\"",
        "description": "Goで構造体のインスタンスを生成する際、特にその構造体が多くの設定可能なフィールド（オプション）を持つ場合、コンストラクタ関数に多数の引数を渡す必要が出てきて、コードが読みにくくなったり、将来的なオプション追加が難しくなったりすることがあります。\n\nこのような問題を解決するための一般的なデザインパターンが**関数オプションパターン (Function Options Pattern)** です。これは、オプションを設定するための関数（オプション関数）を定義し、コンストラクタに可変長引数として渡す方法です。\n\n## 関数オプションパターンの仕組み\n\n1.  **オプション関数の型を定義:** オプションを設定したい対象の構造体（例: `*MyType`）へのポインタを引数に取り、戻り値のない関数型を定義します。",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\n// --- 設定対象の構造体 ---\ntype Server struct {\n\tAddr    string        // 必須\n\tTimeout time.Duration // オプション (デフォルトあり)\n\tMaxConn int           // オプション (デフォルトあり)\n\tUseTLS  bool          // オプション (デフォルトあり)\n\tCertFile string       // TLS 用オプション\n\tKeyFile  string       // TLS 用オプション\n}\n\n// --- オプション関数の型 ---\ntype ServerOption func(*Server)\n\n// --- オプション設定関数 ---\n\n// WithTimeout はタイムアウトを設定するオプション関数を返す\nfunc WithTimeout(timeout time.Duration) ServerOption {\n\treturn func(s *Server) {\n\t\ts.Timeout = timeout\n\t}\n}\n\n// WithMaxConn は最大接続数を設定するオプション関数を返す\nfunc WithMaxConn(maxConn int) ServerOption {\n\treturn func(s *Server) {\n\t\ts.MaxConn = maxConn\n\t}\n}\n\n// WithTLS は TLS を有効にするオプション関数を返す\nfunc WithTLS(certFile, keyFile string) ServerOption {\n\treturn func(s *Server) {\n\t\ts.UseTLS = true\n\t\ts.CertFile = certFile\n\t\ts.KeyFile = keyFile\n\t}\n}\n\n// --- コンストラクタ ---\nfunc NewServer(addr string, opts ...ServerOption) *Server {\n\t// 1. デフォルト値で Server を初期化\n\tserver := &Server{\n\t\tAddr:    addr,\n\t\tTimeout: 30 * time.Second, // デフォルトタイムアウト\n\t\tMaxConn: 100,             // デフォルト最大接続数\n\t\tUseTLS:  false,            // デフォルトは TLS 無効\n\t}\n\n\t// 2. 渡されたオプションを適用\n\tfmt.Printf(\"Applying %d options...\\n\", len(opts))\n\tfor _, opt := range opts {\n\t\topt(server) // 各オプション関数を実行して server のフィールドを変更\n\t}\n\n\t// 3. 設定済みの Server を返す\n\treturn server\n}\n\nfunc main() {\n\t// --- サーバーの生成 ---\n\n\t// 例1: デフォルト設定 + タイムアウトのみ変更\n\tfmt.Println(\"--- Server 1 ---\")\n\tserver1 := NewServer(\":8080\", WithTimeout(10*time.Second))\n\tfmt.Printf(\"Server 1 config: %+v\\n\", *server1)\n\n\t// 例2: TLS を有効化 (タイムアウトと最大接続数はデフォルト)\n\tfmt.Println(\"\\n--- Server 2 ---\")\n\tserver2 := NewServer(\":443\", WithTLS(\"mycert.pem\", \"mykey.pem\"))\n\tfmt.Printf(\"Server 2 config: %+v\\n\", *server2)\n\n\t// 例3: すべてのオプションを設定\n\tfmt.Println(\"\\n--- Server 3 ---\")\n\tserver3 := NewServer(\"127.0.0.1:9000\",\n\t\tWithTLS(\"cert.pem\", \"key.pem\"), // 順番は任意\n\t\tWithMaxConn(500),\n\t\tWithTimeout(5*time.Second),\n\t)\n\tfmt.Printf(\"Server 3 config: %+v\\n\", *server3)\n\n\t// 例4: オプションなし (すべてデフォルト)\n\tfmt.Println(\"\\n--- Server 4 ---\")\n\tserver4 := NewServer(\":8888\") // オプションを渡さない\n\tfmt.Printf(\"Server 4 config: %+v\\n\", *server4)\n}\n\n/* 実行結果:\n--- Server 1 ---\nApplying 1 options...\nServer 1 config: {Addr::8080 Timeout:10s MaxConn:100 UseTLS:false CertFile: KeyFile:}\n\n--- Server 2 ---\nApplying 1 options...\nServer 2 config: {Addr::443 Timeout:30s MaxConn:100 UseTLS:true CertFile:mycert.pem KeyFile:mykey.pem}\n\n--- Server 3 ---\nApplying 3 options...\nServer 3 config: {Addr:127.0.0.1:9000 Timeout:5s MaxConn:500 UseTLS:true CertFile:cert.pem KeyFile:key.pem}\n\n--- Server 4 ---\nApplying 0 options...\nServer 4 config: {Addr::8888 Timeout:30s MaxConn:100 UseTLS:false CertFile: KeyFile:}\n*/",
        "tags": [
          "references",
          "design pattern",
          "function options",
          "constructor",
          "可読性",
          "柔軟性"
        ]
      },
      {
        "title": "\"デザインパターン: ワーカープールパターン (Worker Pool)\"",
        "description": "",
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\n// ダミーのジョブと結果\ntype Job int\ntype Result int\n\n// ワーカー関数\nfunc worker(id int, jobs <-chan Job, results chan<- Result, wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\tfor job := range jobs { // jobs が close されるまで受信\n\t\tfmt.Printf(\"ワーカー %d: ジョブ %d 開始\\n\", id, job)\n\t\ttime.Sleep(100 * time.Millisecond) // 処理をシミュレート\n\t\tresults <- Result(job * 2)         // 結果を送信\n\t\tfmt.Printf(\"ワーカー %d: ジョブ %d 完了\\n\", id, job)\n\t}\n\tfmt.Printf(\"ワーカー %d: 終了\\n\", id)\n}\n\nfunc main() {\n\tconst numJobs = 5\n\tconst numWorkers = 2\n\n\tjobs := make(chan Job, numJobs)\n\tresults := make(chan Result, numJobs)\n\tvar wg sync.WaitGroup\n\n\t// ワーカーを起動\n\tfmt.Printf(\"%d 個のワーカーを起動\\n\", numWorkers)\n\twg.Add(numWorkers)\n\tfor w := 1; w <= numWorkers; w++ {\n\t\tgo worker(w, jobs, results, &wg)\n\t}\n\n\t// ジョブを送信\n\tfmt.Printf(\"%d 個のジョブを送信\\n\", numJobs)\n\tfor j := 1; j <= numJobs; j++ {\n\t\tjobs <- Job(j)\n\t}\n\tclose(jobs) // ★ ジョブ送信完了後、jobs チャネルをクローズ\n\n\t// すべてのワーカーの終了を待つ\n\tfmt.Println(\"ワーカーの終了を待機...\")\n\twg.Wait()\n\tfmt.Println(\"すべてのワーカーが終了\")\n\n\t// 結果を収集 (結果チャネルもクローズするのが安全)\n\tclose(results) // ★ ワーカー終了後に results チャネルをクローズ\n\tfmt.Println(\"結果を収集:\")\n\tfor result := range results {\n\t\tfmt.Printf(\"結果受信: %d\\n\", result)\n\t}\n\tfmt.Println(\"収集完了\")\n}\n\n/* 実行結果の例:\n2 個のワーカーを起動\n5 個のジョブを送信\nワーカーの終了を待機...\nワーカー 1: ジョブ 1 開始\nワーカー 2: ジョブ 2 開始\nワーカー 1: ジョブ 1 完了\nワーカー 1: ジョブ 3 開始\nワーカー 2: ジョブ 2 完了\nワーカー 2: ジョブ 4 開始\nワーカー 1: ジョブ 3 完了\nワーカー 1: ジョブ 5 開始\nワーカー 2: ジョブ 4 完了\nワーカー 2: 終了\nワーカー 1: ジョブ 5 完了\nワーカー 1: 終了\nすべてのワーカーが終了\n結果を収集:\n結果受信: 2\n結果受信: 4\n結果受信: 6\n結果受信: 8\n結果受信: 10\n収集完了\n*/",
        "tags": [
          "references",
          "design pattern",
          "concurrency",
          "goroutine",
          "channel",
          "worker pool"
        ]
      }
    ]
  }
]