## タイトル
title: クロージャごとに独立した状態

## タグ
tags: ["functions", "func", "クロージャ", "関数リテラル", "スコープ", "状態"]

## コード
```go
package main

import "fmt"

// adder 関数 (再掲)
func adder() func(int) int {
	sum := 0
	return func(x int) int {
		sum += x
		return sum
	}
}

func main() {
	// 1つ目のクロージャ (内部に sum=0 を持つ)
	pos1 := adder()
	// 2つ目のクロージャ (別の独立した sum=0 を持つ)
	pos2 := adder()

	fmt.Println(pos1(10)) // pos1 の sum は 10
	fmt.Println(pos2(20)) // pos2 の sum は 20 (pos1 に影響なし)
	fmt.Println(pos1(40)) // pos1 の sum は 50 (10+40)
	fmt.Println(pos2(5))  // pos2 の sum は 25 (20+5)
}

```

## 解説
```text
クロージャの重要な特性は、それが定義された環境の変数を
「記憶」すること、そして**クロージャが生成されるたびに、
その記憶される状態は独立している**ことです。

**独立した状態:**
関数を返す関数（例: `adder`）を複数回呼び出すと、
そのたびに新しいクロージャが生成されます。
それぞれのクロージャは、自身がキャプチャした変数
(例: `sum`) に対して独立したコピー（または参照）を持ちます。
一方のクロージャが状態を変更しても、他のクロージャの
状態には影響しません。

**コード例:**
`pos1 := adder()` と `pos2 := adder()` は、
それぞれ独立した `adder` 関数の実行に対応します。
`pos1` が持つ `sum` と `pos2` が持つ `sum` は、
メモリ上の**異なる場所に存在する独立した変数**です。

*   `pos1(10)` は `pos1` の `sum` を `10` にしますが、
    `pos2` の `sum` は `0` のままです。
*   `pos2(20)` は `pos2` の `sum` を `20` にしますが、
    `pos1` の `sum` は `10` のままです。
*   以降の呼び出しも、それぞれのクロージャが持つ
    独立した `sum` の値を更新していきます。

**イメージ:**
adder() -> クロージャ pos1 (sum=0 -> 10 -> 50)
adder() -> クロージャ pos2 (sum=0 -> 20 -> 25)

このように、クロージャを使うことで、それぞれが
独立した状態を持つ「オブジェクト」のようなものを
関数だけで作成できます。