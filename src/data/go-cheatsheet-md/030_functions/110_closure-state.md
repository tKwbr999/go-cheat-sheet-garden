---
title: "関数: クロージャごとに独立した状態"
tags: ["functions", "func", "クロージャ", "関数リテラル", "スコープ", "状態"]
---

クロージャの重要な特性は、それが定義された環境の変数を「記憶」することですが、さらに重要なのは、**クロージャが生成されるたびに、その記憶される状態は独立している**ということです。

## 独立した状態を持つクロージャ

関数を返す関数（例: `adder`）を複数回呼び出すと、そのたびに新しいクロージャが生成されます。そして、それぞれのクロージャは、自身がキャプチャした変数に対して独立したコピー（または参照）を持ちます。一方のクロージャが状態を変更しても、他のクロージャの状態には影響しません。

```go title="独立した状態を持つクロージャの例"
package main

import "fmt"

// adder 関数 (再掲)
// 呼び出されるたびに、新しい sum 変数 (初期値 0) を持つクロージャを返す
func adder() func(int) int {
	sum := 0
	return func(x int) int {
		sum += x
		return sum
	}
}

func main() {
	// adder() を呼び出して、1つ目のクロージャを取得
	// pos1 は内部に sum=0 の状態を持つ
	pos1 := adder()

	// 再度 adder() を呼び出して、2つ目のクロージャを取得
	// pos2 は pos1 とは別の、独立した sum=0 の状態を持つ
	pos2 := adder()

	// pos1 を呼び出す -> pos1 の sum が更新される
	fmt.Printf("pos1(10) -> %d\n", pos1(10)) // pos1 の sum は 10 になる

	// pos2 を呼び出す -> pos2 の sum が更新される (pos1 の sum には影響しない)
	fmt.Printf("pos2(20) -> %d\n", pos2(20)) // pos2 の sum は 20 になる

	// 再度 pos1 を呼び出す -> pos1 の sum (現在 10) が更新される
	fmt.Printf("pos1(40) -> %d\n", pos1(40)) // pos1 の sum は 10 + 40 = 50 になる

	// 再度 pos2 を呼び出す -> pos2 の sum (現在 20) が更新される
	fmt.Printf("pos2(5) -> %d\n", pos2(5))   // pos2 の sum は 20 + 5 = 25 になる
}

/* 実行結果:
pos1(10) -> 10
pos2(20) -> 20
pos1(40) -> 50
pos2(5) -> 25
*/
```

**コード解説:**

*   `pos1 := adder()` と `pos2 := adder()` は、それぞれ独立した `adder` 関数の実行に対応します。
*   それぞれの `adder` 関数の実行時に、内部で `sum := 0` が実行され、その `sum` 変数をキャプチャしたクロージャが返されます。
*   したがって、`pos1` が参照する `sum` と `pos2` が参照する `sum` は、メモリ上の**異なる場所に存在する、独立した変数**です。
*   `pos1(10)` は `pos1` の `sum` を `10` にしますが、`pos2` の `sum` は `0` のままです。
*   `pos2(20)` は `pos2` の `sum` を `20` にしますが、`pos1` の `sum` は `10` のままです。
*   以降の呼び出しも、それぞれのクロージャが持つ独立した `sum` の値を更新していきます。

**イメージ図:**

```
adder() 呼び出し 1回目  ---->  クロージャ pos1 (内部状態: sum = 0)
  |
  +--> pos1(10)  ---->  pos1 (内部状態: sum = 10)
  |
  +--> pos1(40)  ---->  pos1 (内部状態: sum = 50)

adder() 呼び出し 2回目  ---->  クロージャ pos2 (内部状態: sum = 0)
  |
  +--> pos2(20)  ---->  pos2 (内部状態: sum = 20)
  |
  +--> pos2(5)   ---->  pos2 (内部状態: sum = 25)
```

このように、クロージャを使うことで、それぞれが独立した状態を持つ「オブジェクト」のようなものを関数だけで作成することができます。これはGoの強力な機能の一つです。