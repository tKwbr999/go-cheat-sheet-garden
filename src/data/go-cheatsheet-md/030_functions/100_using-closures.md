## タイトル
title: 関数: クロージャの使い方 (状態の保持)

## タグ
tags: ["functions", "func", "クロージャ", "関数リテラル", "スコープ", "状態"]

## コード
```go
package main

import "fmt"

// adder 関数は `func(int) int` 型のクロージャを返す (再掲)
func adder() func(int) int {
	sum := 0 // この sum が状態としてキャプチャされる
	return func(x int) int {
		sum += x
		return sum
	}
}

func main() {
	// pos は adder() が返したクロージャ (内部に sum=0 を保持)
	pos := adder()

	// pos を呼び出すたびに、pos が持つ sum が更新される
	fmt.Println(pos(1)) // -> 1
	fmt.Println(pos(8)) // -> 9 (1+8)
	fmt.Println(pos(3)) // -> 12 (9+3)

	// neg := adder() // 再度呼ぶと別の sum を持つクロージャが作られる
	// fmt.Println(neg(-2)) // neg の sum は -2
	// fmt.Println(pos(100)) // pos の sum は 12+100 = 112
}

```

## 解説
```text
クロージャの強力な特徴は、呼び出されるたびに
内部の状態（キャプチャした変数）を記憶し、
更新できることです。

**状態の保持:**
コード例の `adder` 関数は、呼び出されるたびに
内部変数 `sum` (初期値0) をキャプチャした
新しいクロージャを返します。

`pos := adder()` で得られたクロージャ `pos` は、
自身専用の `sum` 変数を内部に保持しています。
`pos(1)`, `pos(8)`, `pos(3)` と呼び出すたびに、
この `pos` が持つ `sum` の値が更新され、
その状態が記憶され続けます (0 -> 1 -> 9 -> 12)。

もし `neg := adder()` のように再度 `adder()` を
呼び出すと、`pos` とは**別の** `sum` 変数を持つ
**独立した**クロージャ `neg` が生成されます。
`neg` を呼び出しても `pos` の状態には影響しませんし、
逆も同様です。

**クロージャの用途例:**
このように状態を保持できるため、以下のような場面で役立ちます。
*   **カウンタ:** 呼び出すたびに数が増える関数。
*   **ジェネレータ:** 呼び出すたびに次の値を生成する関数。
*   **状態の隠蔽:** 外部から直接アクセスできない状態を持つ。
*   **コールバック関数:** イベント発生時のコンテキストを保持。

クロージャは関数が状態を持つことを可能にする強力な機能です。