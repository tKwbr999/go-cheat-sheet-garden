---
title: "関数: クロージャの使い方 (状態の保持)"
tags: ["functions", "func", "クロージャ", "関数リテラル", "スコープ", "状態"]
---

前のセクションで定義したクロージャは、呼び出されるたびに内部の状態（キャプチャした変数）を記憶し、更新することができます。これがクロージャの強力な特徴の一つです。

## クロージャによる状態の保持

`adder` 関数の例をもう一度見てみましょう。`adder` 関数は呼び出されるたびに、内部の `sum` 変数をキャプチャした新しいクロージャ（関数）を返します。

```go title="adder 関数の定義 (再掲)"
package main

import "fmt"

// adder 関数は「int を引数に取り int を返す関数」を返す
func adder() func(int) int {
	sum := 0 // この sum がクロージャによってキャプチャされる状態
	return func(x int) int {
		sum += x
		return sum
	}
}

func main() {
	// adder() を呼び出してクロージャを取得
	// pos は adder() が返した関数であり、内部に sum=0 の状態を持っている
	pos := adder()

	// pos を呼び出すたびに、pos が保持している sum が更新される
	fmt.Println("--- pos の呼び出し ---")
	fmt.Printf("pos(1) -> %d\n", pos(1)) // sum は 0+1 = 1 になる
	fmt.Printf("pos(8) -> %d\n", pos(8)) // sum は 1+8 = 9 になる
	fmt.Printf("pos(3) -> %d\n", pos(3)) // sum は 9+3 = 12 になる

	fmt.Println("--------------------")

	// 再度 adder() を呼び出すと、別の状態を持つ新しいクロージャが作られる
	neg := adder()
	// neg は pos とは別の sum=0 の状態を持っている
	fmt.Println("--- neg の呼び出し ---")
	fmt.Printf("neg(-2) -> %d\n", neg(-2)) // neg の sum は 0+(-2) = -2 になる
	fmt.Printf("neg(-5) -> %d\n", neg(-5)) // neg の sum は -2+(-5) = -7 になる

	fmt.Println("--------------------")

	// pos を再度呼び出すと、pos が保持している状態 (sum=12) から再開される
	fmt.Println("--- pos の再呼び出し ---")
	fmt.Printf("pos(100) -> %d\n", pos(100)) // pos の sum は 12+100 = 112 になる
}

/* 実行結果:
--- pos の呼び出し ---
pos(1) -> 1
pos(8) -> 9
pos(3) -> 12
--------------------
--- neg の呼び出し ---
neg(-2) -> -2
neg(-5) -> -7
--------------------
--- pos の再呼び出し ---
pos(100) -> 112
*/
```

**コード解説:**

*   `pos := adder()`: `adder` 関数が実行され、`sum = 0` という状態を持つクロージャが `pos` に代入されます。
*   `pos(1)`, `pos(8)`, `pos(3)`: `pos` を呼び出すたびに、`pos` が内部で保持している `sum` 変数が更新されます。`pos` はこの `sum` の値を記憶し続けています。
*   `neg := adder()`: **再び** `adder` 関数が実行され、**新しい** `sum = 0` という状態を持つ**別の**クロージャが `neg` に代入されます。`pos` が持つ `sum` と `neg` が持つ `sum` は完全に独立しています。
*   `neg(-2)`, `neg(-5)`: `neg` を呼び出すと、`neg` が内部で保持している `sum` が更新されます。
*   `pos(100)`: 再度 `pos` を呼び出すと、以前の呼び出しで `sum` が `12` になっていた状態から処理が再開され、`12 + 100 = 112` となります。

## クロージャの用途例

このように状態を保持できるクロージャは、様々な場面で役立ちます。

*   **カウンタ:** 呼び出すたびに数が増えるカウンタ関数。
*   **ジェネレータ:** 呼び出すたびに次の値を生成する関数（例: フィボナッチ数列）。
*   **状態の隠蔽:** 特定の状態（例: `sum` 変数）を関数の外部から直接アクセスできないように隠蔽し、関数を通じてのみ操作できるようにする。
*   **コールバック関数:** イベントが発生したときに実行される関数として、イベント発生時のコンテキスト（状態）を保持させる。

クロージャは少し複雑に感じるかもしれませんが、関数が状態を持つことを可能にする強力な機能であり、Goの表現力を高めています。