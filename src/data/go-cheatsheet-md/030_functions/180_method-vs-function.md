---
title: "関数 vs メソッド: 基本的な違い"
tags: ["functions", "func", "メソッド", "method", "レシーバ", "型"]
---

Go言語には、**関数 (Function)** と似ていますが、特定の**型**に関連付けられた**メソッド (Method)** という概念があります。オブジェクト指向プログラミングに馴染みのある方にとっては、クラスに属するメソッドのようなものと考えると理解しやすいかもしれません。

ここでは、関数とメソッドの基本的な違いと、それぞれの定義・呼び出し方を見ていきます。（メソッドの詳細は後のセクションで詳しく学びます）

## 関数 (Function)

*   特定の型に関連付けられず、**独立して**存在します。
*   通常、パッケージレベルで定義されます（または関数リテラルとして）。
*   呼び出す際は、`パッケージ名.関数名(引数)` または（同じパッケージ内なら） `関数名(引数)` のように呼び出します。

## メソッド (Method)

*   特定の型（**レシーバ型**と呼ばれる）に**関連付け**られます。
*   レシーバ型は、構造体 (struct) であることが多いですが、構造体以外の型（例: `int` や `string` に `type` で別名を付けた型）にも定義できます。
*   メソッド定義では、`func` キーワードとメソッド名の間に、**レシーバ**と呼ばれる特別な引数を指定します。レシーバは、そのメソッドがどの型の値に対して操作を行うかを示します。
    **構文:** `func (レシーバ名 レシーバ型) メソッド名(引数リスト) 戻り値リスト { ... }`
*   呼び出す際は、レシーバ型の**値**（変数）の後ろにドット `.` を付け、`メソッド名(引数)` のように呼び出します (`変数.メソッド名(引数)`)。メソッド本体の中では、レシーバ名を使ってその値のフィールドなどにアクセスできます。

## コード例: 点 (Point) の距離計算

2点間の距離を計算する処理を、関数とメソッドの両方で実装してみましょう。

```go title="関数とメソッドの比較"
package main

import (
	"fmt"
	"math"
)

// --- Point 型の定義 ---
type Point struct {
	X, Y float64 // X座標, Y座標
}

// --- 関数バージョン ---
// 2つの Point を引数として受け取り、その間の距離を返す関数
func distanceFunc(p1, p2 Point) float64 {
	// 2点間の座標の差を計算
	dx := p2.X - p1.X
	dy := p2.Y - p1.Y
	// ピタゴラスの定理で距離を計算: sqrt(dx^2 + dy^2)
	return math.Sqrt(dx*dx + dy*dy)
}

// --- メソッドバージョン ---
// Point 型に関連付けられた Distance メソッド
// レシーバ p は Point 型
// このメソッドは Point 型の値に対して呼び出される
func (p Point) Distance(q Point) float64 {
	// レシーバ p の座標と、引数 q の座標を使って距離を計算
	dx := q.X - p.X // p.X はレシーバ p の X 座標
	dy := q.Y - p.Y // p.Y はレシーバ p の Y 座標
	return math.Sqrt(dx*dx + dy*dy)
}

func main() {
	p1 := Point{1, 2}
	p2 := Point{4, 6}

	fmt.Printf("点 p1: %+v\n", p1)
	fmt.Printf("点 p2: %+v\n", p2)

	// --- 関数呼び出し ---
	// distanceFunc 関数に2つの Point を渡す
	dist1 := distanceFunc(p1, p2)
	fmt.Printf("関数 distanceFunc(p1, p2) で計算した距離: %f\n", dist1)

	// --- メソッド呼び出し ---
	// Point 型の変数 p1 に対して Distance メソッドを呼び出す
	// p1 がレシーバとなり、p2 が引数として渡される
	dist2 := p1.Distance(p2)
	fmt.Printf("メソッド p1.Distance(p2) で計算した距離: %f\n", dist2)

	// メソッドはレシーバの型に関連付けられている
	// dist3 := Point.Distance(p1, p2) // このような呼び出し方はできない
}

/* 実行結果:
点 p1: {X:1 Y:2}
点 p2: {X:4 Y:6}
関数 distanceFunc(p1, p2) で計算した距離: 5.000000
メソッド p1.Distance(p2) で計算した距離: 5.000000
*/
```

**コード解説:**

*   `distanceFunc` は独立した関数で、2つの `Point` を引数に取ります。呼び出す際は `distanceFunc(p1, p2)` とします。
*   `Distance` は `Point` 型に**関連付けられたメソッド**です。`func (p Point) ...` の `(p Point)` がレシーバ定義です。
    *   `p` はレシーバ変数名（慣習的に型の頭文字の小文字などが使われる）。
    *   `Point` はレシーバ型。
*   メソッド `Distance` は、`Point` 型の変数（この例では `p1`）に対して `p1.Distance(p2)` のように呼び出します。
*   メソッドの内部では、レシーバ変数 `p` を通して、メソッドが呼び出された値（この例では `p1`）のフィールド (`p.X`, `p.Y`) にアクセスできます。

## 関数とメソッドの使い分け

*   **関数:** 特定の型に強く関連しない、汎用的な処理やユーティリティ的な処理に適しています。
*   **メソッド:** 特定の型のデータに対する操作や、その型の振る舞いを定義する場合に適しています。オブジェクト指向的な考え方を取り入れる際に中心的な役割を果たします。

メソッドはGoの重要な機能であり、型に振る舞いを持たせることで、より構造化され、理解しやすいコードを書くことができます。詳細はメソッドのセクションでさらに詳しく学びます。