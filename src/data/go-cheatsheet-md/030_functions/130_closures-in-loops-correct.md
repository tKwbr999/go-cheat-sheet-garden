## タイトル
title: ループ内クロージャの落とし穴の解決策

## タグ
tags: ["functions", "func", "クロージャ", "関数リテラル", "スコープ", "ループ", "for"]

## コード
```go
package main

import "fmt"

func main() {
	var funcs []func()

	fmt.Println("ループ内でクロージャ作成 (解決策1)...")
	for i := 0; i < 3; i++ {
		// ループごとに新しい変数 i を宣言し、値をコピー
		i := i // この内側の i をクロージャがキャプチャする

		funcs = append(funcs, func() {
			fmt.Printf("i の値: %d\n", i) // 内側の i を参照
		})
		fmt.Printf("  ループ %d 回目 (内側の i = %d)\n", i, i)
	}

	fmt.Println("\nクロージャ実行...")
	for j := 0; j < len(funcs); j++ {
		fmt.Printf("funcs[%d]() -> ", j)
		funcs[j]() // 期待通り 0, 1, 2 が出力される
	}
}

```

## 解説
```text
`for` ループ内でクロージャがループ変数の参照を共有してしまう
問題を解決し、各反復時点での値を正しくキャプチャする
一般的な方法が2つあります。

**解決策1: ループ内で新しい変数を作成 (コード例)**
ループの各反復の**内部**で、ループ変数と同じ名前の
**新しい変数**を宣言し (`i := i`)、ループ変数の
現在の値をコピーします。
クロージャ内ではこの**新しい変数**を参照します。

*   `i := i`: これは**シャドーイング**と呼ばれ、
    ループの反復ごとに新しい変数 `i` が作られます。
*   クロージャ `func() { fmt.Println(i) }` は、
    この**内側の `i`** への参照をキャプチャします。
*   各クロージャは、作成された時点のループ変数の値を
    持つ独立した変数を参照するため、期待通りの結果になります。

この `i := i` は Go 1.22 より前のバージョンで一般的な
解決策でした。(Go 1.22 からはループ変数の扱いが変わり、
この問題は発生しにくくなりましたが、パターンとして有効な場面もあります。)

**解決策2: ループ変数を引数として渡す**
もう一つの方法は、ループ変数の値をクロージャ生成時に
**引数**として渡すことです。
```go
for i := 0; i < 3; i++ {
    val := i // 各反復の i の値を val にコピー
    funcs = append(funcs, func() {
        fmt.Println(val) // val をキャプチャ
    })
}
```
または、関数リテラルを即時実行して引数で渡します。
```go
for i := 0; i < 3; i++ {
    funcs = append(funcs, func(val int) func() {
        return func() { fmt.Println(val) }
    }(i)) // i の値を val にコピーして渡す
}
```
どちらの方法でも、各反復時点での値がクロージャに
正しくキャプチャされます。一般的には解決策1が簡潔です。