---
title: "関数: ループ内クロージャの落とし穴の解決策"
tags: ["functions", "func", "クロージャ", "関数リテラル", "スコープ", "ループ", "for"]
---

前のセクションで見たように、`for` ループ内でクロージャを作成し、その中でループ変数を直接参照すると、すべてのクロージャがループ終了後の同じ変数を参照してしまうという問題がありました。

この問題を解決し、ループの各反復時点での値をクロージャに正しくキャプチャさせるための一般的な方法が2つあります。

## 解決策1: ループ内で新しい変数を作成する

ループの各反復処理の**内部**で、ループ変数と同じ名前の**新しい変数**を宣言し、ループ変数の現在の値をコピーします。そして、クロージャ内ではこの**新しい変数**を参照するようにします。

```go title="解決策1: ループ内での変数再宣言"
package main

import "fmt"

func main() {
	var funcs []func()

	fmt.Println("ループ内でクロージャを作成 (解決策1)...")
	for i := 0; i < 3; i++ {
		// ★★★ 解決策 ★★★
		// ループの各反復ごとに、新しい変数 i を宣言し、
		// 外側のループ変数 i の現在の値をコピーする。
		// この内側の i は、ループの反復ごとに異なる変数となる。
		i := i // シャドーイング (Shadowing) と呼ばれることもある

		// クロージャはこの「内側の i」への参照をキャプチャする
		funcs = append(funcs, func() {
			fmt.Printf("i の値: %d\n", i) // 内側の i を参照
		})
		fmt.Printf("  ループ %d 回目: クロージャを追加 (内側の i = %d)\n", i, i)
	}

	fmt.Println("\n作成したクロージャを実行します...")
	for j := 0; j < len(funcs); j++ {
		fmt.Printf("funcs[%d]() を実行 -> ", j)
		funcs[j]() // 各クロージャは、作成された時点の内側の i の値を表示する
	}
}

/* 実行結果:
ループ内でクロージャを作成 (解決策1)...
  ループ 0 回目: クロージャを追加 (内側の i = 0)
  ループ 1 回目: クロージャを追加 (内側の i = 1)
  ループ 2 回目: クロージャを追加 (内側の i = 2)

作成したクロージャを実行します...
funcs[0]() を実行 -> i の値: 0
funcs[1]() を実行 -> i の値: 1
funcs[2]() を実行 -> i の値: 2
*/
```

**コード解説:**

*   `i := i`: `for` ループの内側で、外側のループ変数 `i` と同じ名前で新しい変数 `i` を宣言し、その時点での外側の `i` の値を代入しています。これは**シャドーイング**と呼ばれるテクニックです。ループの反復ごとに、この内側の `i` は**新しい別の変数**として扱われます。
*   `func() { fmt.Printf("i の値: %d\n", i) }`: このクロージャは、直前で宣言された**内側の変数 `i`** への参照をキャプチャします。
*   結果として、各クロージャは、それが作成された時点でのループ変数の値を持つ独立した変数を参照するため、期待通り 0, 1, 2 が出力されます。

この `i := i` という書き方は、Go 1.22 より前のバージョンでループ内クロージャの問題を解決するための一般的なイディオムでした。

**Go 1.22 以降:** Go 1.22 からは `for` ループの仕様が変更され、ループ変数が各反復で新しい変数として扱われるようになったため、この問題は発生しにくくなりました。しかし、古いコードや、`for range` でポインタを扱う場合など、依然としてこのパターンが有効な場面もあります。

## 解決策2: ループ変数を引数として渡す

もう一つの方法は、ループ変数の値を、クロージャを生成する際に**引数**として渡すことです。

```go title="解決策2: 引数として値を渡す"
package main

import "fmt"

func main() {
	var funcs []func()

	fmt.Println("ループ内でクロージャを作成 (解決策2)...")
	for i := 0; i < 3; i++ {
		// ★★★ 解決策 ★★★
		// ループ変数の現在の値 (i) を、
		// 即時実行される関数リテラルの引数 val にコピーする。
		// クロージャはその引数 val をキャプチャする。
		val := i // ループの各反復で val は 0, 1, 2 となる
		funcs = append(funcs, func() {
			fmt.Printf("val の値: %d\n", val) // val を参照
		})

		// または、関数リテラルを定義し、その場で呼び出して引数を渡す方法もある
		// funcs = append(funcs, func(val int) func() {
		// 	return func() {
		// 		fmt.Printf("val の値: %d\n", val)
		// 	}
		// }(i)) // ここで i の現在の値を val にコピーして渡す

		fmt.Printf("  ループ %d 回目: クロージャを追加 (現在の i = %d, val = %d)\n", i, i, val)
	}

	fmt.Println("\n作成したクロージャを実行します...")
	for j := 0; j < len(funcs); j++ {
		fmt.Printf("funcs[%d]() を実行 -> ", j)
		funcs[j]()
	}
}

/* 実行結果:
ループ内でクロージャを作成 (解決策2)...
  ループ 0 回目: クロージャを追加 (現在の i = 0, val = 0)
  ループ 1 回目: クロージャを追加 (現在の i = 1, val = 1)
  ループ 2 回目: クロージャを追加 (現在の i = 2, val = 2)

作成したクロージャを実行します...
funcs[0]() を実行 -> val の値: 0
funcs[1]() を実行 -> val の値: 1
funcs[2]() を実行 -> val の値: 2
*/
```

**コード解説:**

*   `val := i`: ループの各反復で、新しい変数 `val` を作成し、その時点での `i` の値をコピーします。
*   `func() { fmt.Printf("val の値: %d\n", val) }`: クロージャは、ループ変数 `i` ではなく、各反復で作成された `val` をキャプチャします。
*   コメントアウトされている部分は、関数リテラルを定義してその場で呼び出す (`func(val int){...}(i)`) ことで、引数 `val` に `i` の値をコピーし、その `val` をキャプチャするクロージャを返す、という少し複雑ですが同様の効果を持つ方法です。

どちらの解決策も、ループの各反復時点での値をクロージャに正しくキャプチャさせることができます。一般的には、解決策1 (`i := i`) の方が簡潔でよく使われます（特に Go 1.22 より前）。