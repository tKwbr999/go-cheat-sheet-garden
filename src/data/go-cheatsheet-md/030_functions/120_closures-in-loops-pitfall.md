## タイトル
title: 関数: ループ内でのクロージャの落とし穴

## タグ
tags: ["functions", "func", "クロージャ", "関数リテラル", "スコープ", "ループ", "for", "落とし穴"]

## コード
```go
package main

import "fmt"

func main() {
	var funcs []func()

	fmt.Println("ループ内でクロージャ作成...")
	for i := 0; i < 3; i++ {
		// このクロージャは変数 i への参照をキャプチャする
		funcs = append(funcs, func() {
			// 実行されるのはループ終了後なので、i は 3 になっている
			fmt.Printf("i の値: %d\n", i)
		})
		fmt.Printf("  ループ %d 回目 (現在の i = %d)\n", i, i)
	}

	fmt.Println("\nクロージャ実行...")
	for j := 0; j < len(funcs); j++ {
		fmt.Printf("funcs[%d]() -> ", j)
		funcs[j]() // すべて i=3 と出力される
	}
}

```

## 解説
```text
`for` ループの中で関数リテラル（クロージャ）を作成し、
その中でループ変数（例: `i`）を参照する場合、
**陥りやすい落とし穴**があります。

**問題点: ループ変数の共有**
ループ内で生成されたクロージャは、ループ変数の
**その時点での値**をキャプチャするのではなく、
**ループ変数そのものへの参照**をキャプチャします。

ループ変数はループの各反復で使い回されるため、
ループが終了した時点での変数の値を、
**すべてのクロージャが共有**してしまいます。

**コード例:**
1. `for i := 0; i < 3; i++` ループ内で、
   `func() { fmt.Println(i) }` というクロージャを
   `funcs` スライスに追加しています。
2. このクロージャは変数 `i` への参照を保持します。
3. ループ終了時、`i` の値は `3` になっています。
4. その後、`funcs` 内のクロージャを実行すると、
   すべてのクロージャが参照している `i` の値は `3` なので、
   すべて `i の値: 3` と出力されてしまいます。
   (期待する 0, 1, 2 とは異なる結果)

これは、ループの各反復時点での値をクロージャに
キャプチャさせたい場合に意図しない結果となります。
(解決策は次のセクションで説明します)