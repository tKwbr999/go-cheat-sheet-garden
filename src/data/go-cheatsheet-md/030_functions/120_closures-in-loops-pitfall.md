---
title: "関数: ループ内でのクロージャの落とし穴"
tags: ["functions", "func", "クロージャ", "関数リテラル", "スコープ", "ループ", "for", "落とし穴"]
---

`for` ループの中で関数リテラル（クロージャ）を作成し、その中でループ変数（例: `for i := ...` の `i`）を参照する場合、**非常に陥りやすい落とし穴**があります。

## 問題点: ループ変数の共有

ループ内で生成されたクロージャは、ループ変数の**その時点での値**をキャプチャするのではなく、**ループ変数そのものへの参照**をキャプチャします。ループ変数はループの各反復で使い回されるため、ループが終了した時点での変数の値を、すべてのクロージャが共有してしまうことになります。

特に、Goroutine と組み合わせて使う場合にこの問題が顕著になりますが、単純なループでも発生します。

```go title="ループ変数共有の落とし穴の例"
package main

import "fmt"

func main() {
	// 関数を格納するためのスライスを作成
	var funcs []func() // func() 型のスライス

	fmt.Println("ループ内でクロージャを作成します...")
	for i := 0; i < 3; i++ {
		// この関数リテラルは変数 i への参照をキャプチャする
		funcs = append(funcs, func() {
			// ★★★ 問題点 ★★★
			// この fmt.Println(i) が実行されるのは、
			// ループがすべて完了した後、下の for ループで funcs[j]() が呼び出された時。
			// その時点では、変数 i の値はループ終了後の値 (この例では 3) になっている。
			fmt.Printf("i の値: %d\n", i)
		})
		fmt.Printf("  ループ %d 回目: クロージャを追加 (現在の i = %d)\n", i, i)
	}

	fmt.Println("\n作成したクロージャを実行します...")
	// スライスに格納された関数を順番に実行
	for j := 0; j < len(funcs); j++ {
		fmt.Printf("funcs[%d]() を実行 -> ", j)
		funcs[j]() // クロージャを実行
	}

	// 期待する結果 (0, 1, 2) とは異なり、すべてループ終了後の i の値 (3) が表示される！
}

/* 実行結果:
ループ内でクロージャを作成します...
  ループ 0 回目: クロージャを追加 (現在の i = 0)
  ループ 1 回目: クロージャを追加 (現在の i = 1)
  ループ 2 回目: クロージャを追加 (現在の i = 2)

作成したクロージャを実行します...
funcs[0]() を実行 -> i の値: 3
funcs[1]() を実行 -> i の値: 3
funcs[2]() を実行 -> i の値: 3
*/
```

**コード解説:**

1.  `for i := 0; i < 3; i++` ループの中で、`func() { fmt.Println(i) }` という関数リテラルを作成し、`funcs` スライスに追加しています。
2.  この関数リテラルは、ループ変数 `i` を参照しています。重要なのは、このクロージャは `i` の**現在の値** (0, 1, 2) をコピーして保持するのではなく、変数 `i` **そのもの**を指し示す参照を保持する点です。
3.  `for` ループが終了した時点で、変数 `i` の最終的な値は `3` になっています（`i < 3` が `false` になったためループを抜けた）。
4.  その後、下の `for j := ...` ループで `funcs` スライスに格納された各クロージャ (`funcs[j]()`) を実行します。
5.  各クロージャが実行される際、それらが参照している変数 `i` の値は、ループ終了後の**共通の値である `3`** になっています。
6.  そのため、すべてのクロージャが `i の値: 3` と出力してしまいます。

これは、ループの各反復で期待される値 (0, 1, 2) をクロージャにキャプチャさせたい場合に、意図しない結果を引き起こします。

次のセクションでは、この問題を解決するための一般的な方法を説明します。