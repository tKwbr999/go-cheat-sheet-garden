---
title: "関数: クロージャ (Closure) の定義"
tags: ["functions", "func", "クロージャ", "関数リテラル", "スコープ", "状態"]
---

Go言語では、関数は「第一級オブジェクト」として扱われます。これは、関数を変数に代入したり、他の関数の引数として渡したり、そして**関数の戻り値として返す**ことができる、という意味です。

関数を返す関数を作る際に、返される関数が、それが定義された環境（スコープ）にある変数（自由変数）への参照を保持している場合、その返された関数を**クロージャ (Closure)** と呼びます。クロージャは、自身が定義された場所の「状態」を記憶し、後で呼び出されたときにもその状態にアクセスしたり変更したりできます。

## クロージャの定義方法

Goでは、**関数リテラル（無名関数）** を使ってクロージャを簡単に作成できます。関数リテラルが、その外側で定義されている変数を参照すると、その変数はクロージャによって「キャプチャ」され、関数リテラルが後で実行されるときにもアクセス可能になります。

```go title="クロージャを返す関数の例: adder"
package main

import "fmt"

// adder 関数は「int を引数に取り int を返す関数」を返す関数
// func(int) int が戻り値の型
func adder() func(int) int {
	// sum 変数は adder 関数のローカル変数だが、
	// 返される関数リテラルによって「キャプチャ」される
	sum := 0
	fmt.Println("adder 関数が呼び出されました。sum の初期値:", sum)

	// 関数リテラル (無名関数) を定義して返す
	// この関数リテラルは、外側の sum 変数を参照している -> これがクロージャ
	return func(x int) int {
		// キャプチャした sum 変数にアクセスし、変更する
		sum += x
		fmt.Printf("  内部関数: x=%d を加算、現在の sum=%d\n", x, sum)
		return sum // 変更後の sum を返す
	}
}

func main() {
	// adder() を呼び出すと、新しいクロージャ (内部関数) が返される
	// このクロージャは、自身専用の sum 変数 (初期値 0) を持っている
	pos := adder()

	fmt.Println("\npos クロージャを呼び出します:")
	fmt.Printf("pos(1) = %d\n", pos(1)) // sum は 0 + 1 = 1 になる
	fmt.Printf("pos(10) = %d\n", pos(10)) // sum は 1 + 10 = 11 になる
	fmt.Printf("pos(5) = %d\n", pos(5)) // sum は 11 + 5 = 16 になる

	fmt.Println("--------------------")

	// もう一度 adder() を呼び出すと、別の新しいクロージャが返される
	// このクロージャも、自身専用の sum 変数 (初期値 0) を持っている
	neg := adder()

	fmt.Println("\nneg クロージャを呼び出します:")
	fmt.Printf("neg(-1) = %d\n", neg(-1)) // sum は 0 + (-1) = -1 になる
	fmt.Printf("neg(-5) = %d\n", neg(-5)) // sum は -1 + (-5) = -6 になる

	fmt.Println("\n再度 pos クロージャを呼び出します:")
	// pos が持つ sum は neg の sum とは独立している
	fmt.Printf("pos(100) = %d\n", pos(100)) // sum は 16 + 100 = 116 になる
}

/* 実行結果:
adder 関数が呼び出されました。sum の初期値: 0

pos クロージャを呼び出します:
  内部関数: x=1 を加算、現在の sum=1
pos(1) = 1
  内部関数: x=10 を加算、現在の sum=11
pos(10) = 11
  内部関数: x=5 を加算、現在の sum=16
pos(5) = 16
--------------------
adder 関数が呼び出されました。sum の初期値: 0

neg クロージャを呼び出します:
  内部関数: x=-1 を加算、現在の sum=-1
neg(-1) = -1
  内部関数: x=-5 を加算、現在の sum=-6
neg(-5) = -6

再度 pos クロージャを呼び出します:
  内部関数: x=100 を加算、現在の sum=116
pos(100) = 116
*/
```

**コード解説:**

1.  `adder` 関数は、内部で `sum` というローカル変数を `0` で初期化します。
2.  `adder` 関数は、`func(x int) int { ... }` という**関数リテラル**を返します。
3.  この関数リテラルは、その外側にある `sum` 変数を参照し、`sum += x` という形で変更しています。この時点で、この関数リテラルは `sum` 変数を**キャプチャ**した**クロージャ**となります。
4.  `main` 関数で `pos := adder()` を実行すると、`adder` 関数が呼び出され、新しい `sum` 変数（値は0）が作られ、それをキャプチャしたクロージャが `pos` に代入されます。
5.  `pos(1)`, `pos(10)`, `pos(5)` と呼び出すたびに、`pos` がキャプチャしている `sum` 変数が更新されていきます。
6.  `neg := adder()` を実行すると、**再び** `adder` 関数が呼び出され、**別の**新しい `sum` 変数（値は0）が作られ、それをキャプチャした**別の**クロージャが `neg` に代入されます。
7.  `neg(-1)`, `neg(-5)` の呼び出しは、`neg` が持つ `sum` を更新します。これは `pos` が持つ `sum` とは**完全に独立**しています。
8.  最後に `pos(100)` を呼び出すと、`pos` が最初にキャプチャした `sum` がさらに更新されます。

## クロージャのポイント

*   クロージャは、それが定義されたスコープ（環境）にある変数への参照を保持します。
*   クロージャはその環境を「閉じ込める (close over)」ことから、クロージャと呼ばれます。
*   これにより、関数が状態（例: `sum` 変数）を持つことが可能になります。
*   関数を返す関数を呼び出すたびに、通常は新しい独立した状態を持つクロージャが生成されます。

クロージャは、状態を持つ関数を作成したり、コールバック関数を実装したり、様々な場面で使われる強力な機能です。