---
title: "インターフェース: 型アサーション (Type Assertion)"
tags: ["interfaces", "interface", "型アサーション", "type assertion", "カンマOK", "panic"]
---

インターフェース型の変数は、そのインターフェースを実装する様々な具体的な型の値を保持できます。しかし、時にはインターフェース変数に**実際に格納されている値の具体的な型**を知り、その型が持つ固有のフィールドやメソッドにアクセスしたい場合があります。

このような場合に使うのが**型アサーション (Type Assertion)** です。型アサーションは、インターフェース変数に対して「この変数は、実際にはこの具体的な型 `T` を持っているはずだ」と表明し、その具体的な型の値を取り出す操作です。

## 型アサーションの構文: `変数.(型)`

**構文:** `インターフェース変数.(具体的な型)`

*   `インターフェース変数`: 型をアサートしたいインターフェース型の変数。
*   `.(具体的な型)`: ドット `.` の後に括弧 `()` で囲んで、インターフェース変数が実際に持っていると期待される具体的な型を指定します。

型アサーションには、結果の受け取り方によって2つの形式があります。

### 形式1: 1つの値を受け取る (パニックの可能性あり)

`value := インターフェース変数.(具体的な型)`

*   もしインターフェース変数が**指定した具体的な型**の値を保持していれば、その具体的な型の値が `value` に代入されます。
*   もしインターフェース変数が `nil` であるか、または**指定した型とは異なる型**の値を保持していた場合、この操作は**パニック (panic)** を引き起こします。

この形式は、型が確実に分かっている場合にのみ使うべきで、通常は次に説明するカンマOK形式の方が安全です。

### 形式2: カンマOKイディオム (安全)

`value, ok := インターフェース変数.(具体的な型)`

*   マップのキー存在確認と同様に、2つの値を返します。
*   `value`:
    *   アサーションが**成功**した場合（インターフェース変数が指定した型の値を持っていた場合）、その具体的な型の値が代入されます。
    *   アサーションが**失敗**した場合（`nil` または型が異なる場合）、`value` には指定した**具体的な型のゼロ値**が代入されます。
*   `ok`:
    *   アサーションが**成功**した場合は **`true`** が代入されます。
    *   アサーションが**失敗**した場合は **`false`** が代入されます。

この形式では、アサーションが失敗しても**パニックは発生しません**。`ok` の値を見ることで、アサーションが成功したかどうかを安全に確認できます。**通常はこちらの形式を使うことが推奨されます。**

## コード例

```go title="型アサーションの例"
package main

import "fmt"

func main() {
	// any (interface{}) 型の変数に様々な型の値を代入
	var i any // interface{} と同じ

	i = "Hello"

	// --- 形式1: パニックする可能性のあるアサーション ---
	// i が string であるとアサートし、値を取り出す
	s1 := i.(string)
	fmt.Printf("形式1 (成功): s1 = \"%s\" (%T)\n", s1, s1)

	// i が int であるとアサートしようとする (実際は string なので panic)
	// num1 := i.(int) // この行のコメントを外すと panic する
	// panic: interface conversion: interface {} is string, not int

	// --- 形式2: カンマOKイディオム (安全) ---
	fmt.Println("\n--- 形式2 (カンマOK) ---")

	// i が string であるかチェック
	s2, ok1 := i.(string)
	if ok1 {
		fmt.Printf("i は string 型です: \"%s\"\n", s2)
	} else {
		fmt.Println("i は string 型ではありません。")
	}

	// i が int であるかチェック
	num2, ok2 := i.(int)
	if ok2 {
		fmt.Printf("i は int 型です: %d\n", num2)
	} else {
		// ok2 は false になる
		// num2 には int のゼロ値 0 が入る
		fmt.Printf("i は int 型ではありません。(ok=%t, num2=%d)\n", ok2, num2)
	}

	// --- nil インターフェースに対するアサーション ---
	var nilVal any = nil // nil インターフェース
	_, ok3 := nilVal.(string)
	if !ok3 {
		fmt.Println("nil インターフェースに対する型アサーションは失敗します (ok=false)")
	}
	// val := nilVal.(string) // panic: interface conversion: interface {} is nil, not string

	// --- if 文の初期化ステートメントと組み合わせる ---
	fmt.Println("\n--- if 文との組み合わせ ---")
	i = 123 // i に int を代入
	if num, ok := i.(int); ok {
		// アサーション成功時のみ実行される
		// num は int 型として使える
		fmt.Printf("i は int 型で、値は %d です。\n", num)
	} else {
		fmt.Println("i は int 型ではありません。")
	}
}

/* 実行結果:
形式1 (成功): s1 = "Hello" (string)

--- 形式2 (カンマOK) ---
i は string 型です: "Hello"
i は int 型ではありません。(ok=false, num2=0)
nil インターフェースに対する型アサーションは失敗します (ok=false)

--- if 文との組み合わせ ---
i は int 型で、値は 123 です。
*/
```

**コード解説:**

*   `s1 := i.(string)`: `i` が `string` なので成功し、`s1` に `"Hello"` が代入されます。
*   `num1 := i.(int)`: `i` は `string` なので `int` へのアサーションは失敗し、パニックが発生します（コメントアウトされています）。
*   `s2, ok1 := i.(string)`: `i` は `string` なので成功し、`s2` に `"Hello"`、`ok1` に `true` が代入されます。
*   `num2, ok2 := i.(int)`: `i` は `string` なので `int` へのアサーションは失敗し、`num2` に `int` のゼロ値 `0`、`ok2` に `false` が代入されます。
*   `_, ok3 := nilVal.(string)`: `nil` インターフェースに対する型アサーションは常に失敗し、`ok3` は `false` になります。
*   `if num, ok := i.(int); ok { ... }`: `if` の初期化ステートメントでカンマOK形式の型アサーションを行い、`ok` が `true` の場合のみ `if` ブロックを実行する、という書き方が一般的です。

型アサーションは、インターフェース変数に格納された具体的な値を利用したい場合に不可欠な機能ですが、パニックを避けるためにカンマOKイディオムを使うことが強く推奨されます。次のセクションでは、複数の型に対して分岐を行う型スイッチについて説明します。