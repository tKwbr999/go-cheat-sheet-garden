## タイトル
title: インターフェースのベストプラクティス: 小さく保つ (単一責任)

## タグ
tags: ["interfaces", "interface", "ベストプラクティス", "設計原則", "単一責任の原則"]

## コード
```go
// 良い例: io.Reader (読み取り責務のみ)
type Reader interface {
	Read(p []byte) (n int, err error)
}

// 良い例: io.Writer (書き込み責務のみ)
type Writer interface {
	Write(p []byte) (n int, err error)
}

// 良い例: io.Closer (クローズ責務のみ)
type Closer interface {
	Close() error
}

// 組み合わせ例: io.ReadWriter (Reader と Writer を埋め込み)
// type ReadWriter interface {
//     Reader
//     Writer
// }
```

## 解説
```text
Goインターフェースの重要なベストプラクティスは
**インターフェースを小さく保つ**ことです。
理想的には、**一つのことだけ**を行う
**最小限のメソッド**を持つべきです
(単一責任の原則)。

**なぜ小さく保つか？**
*   **実装しやすい:** 要求メソッドが少ないほど実装が容易。
*   **利用しやすい:** 関数等がインターフェースを引数に取る際、
    要求する機能が明確になる。
*   **組み合わせやすい:** 小さなインターフェースを埋め込んで
    より複雑なインターフェースを柔軟に構築できる。
*   **疎結合:** 依存関係を最小限にし、変更や拡張を容易にする。

**良い例: `io` パッケージ**
コード例の `io.Reader`, `io.Writer`, `io.Closer` は
それぞれ「読み取り」「書き込み」「クローズ」という
単一の責任を持つ小さなインターフェースです。
これらを `io.ReadWriter` のように組み合わせて使います。

**悪い例: 大きすぎるインターフェース**
もし `Read`, `Write`, `Close`, `Seek` など多くのメソッドを
持つ巨大な `BadFile` インターフェースがあったら、
実装が大変で、読み取りだけしたい関数にも過剰な要求となり、
一部メソッドしか実装できない型は使えなくなります。

**まとめ:**
Goでは「大きいインターフェースより小さい方が良い」が基本。
インターフェース設計時は、本当に必要な最小限のメソッドに
絞り込みましょう。必要なら後で組み合わせます。

**「インターフェースは、使う側が必要とする振る舞いを定義する」**
という視点が重要です。利用者が必要とする最小限のメソッドセットを
定義することで、柔軟で疎結合な設計が可能になります。