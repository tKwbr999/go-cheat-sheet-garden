---
title: "インターフェース: 振る舞いの契約を定義する"
tags: ["interfaces", "interface", "メソッドシグネチャ", "契約", "ポリモーフィズム"]
---

Go言語における**インターフェース (Interface)** は、非常に重要で強力な概念です。インターフェースは、具体的な実装（データ構造や処理内容）を持つのではなく、**どのようなメソッドを持っているべきか**という**メソッドシグネチャの集まり**だけを定義します。これは、型が満たすべき**契約 (Contract)** や**仕様 (Specification)** のようなものと考えることができます。

## インターフェースとは？

*   **メソッドシグネチャの集まり:** インターフェースは、一つ以上のメソッドの名前、引数の型、戻り値の型を定義します。メソッドの具体的な処理内容は定義しません。
*   **振る舞いの定義:** インターフェースは、特定の型が「何ができるか」（どのような振る舞いを持つべきか）を定義します。
*   **抽象型:** インターフェースは具体的なデータを持たないため、抽象的な型と見なされます。
*   **ポリモーフィズムの実現:** 同じインターフェースを満たす異なる型の値を、そのインターフェース型の変数として統一的に扱うことを可能にします（ポリモーフィズム、多態性）。

## インターフェースの定義

`type` キーワードと `interface` キーワードを使ってインターフェースを定義します。

**構文:**
```go
type インターフェース名 interface {
	メソッド名1(引数リスト1) 戻り値リスト1
	メソッド名2(引数リスト2) 戻り値リスト2
	// ...
}
```

*   `type`: 新しい型を定義するキーワード。
*   `インターフェース名`: 定義するインターフェースの名前。Goの命名規則に従います。単一メソッドの場合は `-er` サフィックスがよく使われます（例: `Reader`, `Writer`）。
*   `interface`: これがインターフェース型であることを示すキーワード。
*   `{ ... }`: 中括弧の中に、このインターフェースが要求するメソッドのシグネチャ（メソッド名、引数リスト、戻り値リスト）を一行ずつ記述します。

## コード例

例として、図形を表す型が共通して持つべき振る舞いとして、「面積を計算する (`Area`)」と「周長を計算する (`Perimeter`)」というメソッドを要求する `Shape` インターフェースを定義してみましょう。

```go title="インターフェースの定義例"
package main

import "fmt"

// --- インターフェースの定義 ---

// Shape インターフェース: Area() と Perimeter() メソッドを持つことを要求する
type Shape interface {
	Area() float64      // 面積を float64 で返すメソッド
	Perimeter() float64 // 周長を float64 で返すメソッド
}

// --- インターフェースを満たす具体的な型の定義 (例) ---
// (これらの型の実装は次のセクションで詳しく見ます)

// Rectangle 構造体 (長方形)
type Rectangle struct {
	Width, Height float64
}

// Circle 構造体 (円)
type Circle struct {
	Radius float64
}

// --- インターフェースの利用 (概要) ---
// (具体的な使い方は後のセクションで詳しく見ます)

// Shape インターフェース型の引数を受け取る関数 (例)
// この関数は、具体的な図形が Rectangle か Circle かを知らなくても、
// Area() と Perimeter() メソッドさえ持っていればどんな Shape でも扱える
func printShapeInfo(s Shape) {
	fmt.Printf("図形情報: %+v\n", s) // s の具体的な型情報が表示される
	fmt.Printf("  面積: %.2f\n", s.Area())
	fmt.Printf("  周長: %.2f\n", s.Perimeter())
}

// main 関数 (ここではインターフェース定義のみを示すため空)
func main() {
	fmt.Println("Shape インターフェースが定義されました。")
	// 次のセクションで、このインターフェースを実装し、利用します。

	// インターフェース型のゼロ値は nil
	var s Shape
	if s == nil {
		fmt.Println("インターフェース変数 s は現在 nil です。")
	}
	// s.Area() // panic: runtime error: invalid memory address or nil pointer dereference
}

/* 実行結果:
Shape インターフェースが定義されました。
インターフェース変数 s は現在 nil です。
*/
```

**コード解説:**

*   `type Shape interface { ... }`: `Shape` という名前のインターフェースを定義しています。
*   `Area() float64`: `Shape` インターフェースを満たす型は、引数なしで `float64` を返す `Area` という名前のメソッドを持たなければならない、という契約を定義しています。
*   `Perimeter() float64`: 同様に、`Perimeter` という名前のメソッドも持たなければならない、という契約を定義しています。
*   `printShapeInfo` 関数は、引数として `Shape` インターフェース型の値 `s` を受け取ります。これは、「`Area()` と `Perimeter()` メソッドを持っている任意の型の値」を受け取れることを意味します。関数内では、`s` が具体的にどの型（`Rectangle` や `Circle` など）かは気にせず、`Shape` インターフェースが保証する `Area()` と `Perimeter()` メソッドを呼び出すことができます。
*   インターフェース型の変数を宣言しただけの場合、そのゼロ値は `nil` です。`nil` のインターフェース変数に対してメソッドを呼び出そうとするとパニックが発生します。

インターフェースは、型の具体的な実装から**振る舞いを分離**するための強力な抽象化メカニズムです。これにより、柔軟で拡張性の高いコードを書くことが可能になります。次のセクションでは、定義したインターフェースを具体的な型がどのように実装するかを見ていきます。