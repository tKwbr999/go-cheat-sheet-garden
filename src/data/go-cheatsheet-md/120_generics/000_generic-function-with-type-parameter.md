## タイトル
title: ジェネリクス: 型パラメータを持つジェネリック関数

## タグ
tags: ["generics", "ジェネリクス", "型パラメータ", "type parameter", "関数", "any", "型推論", "Go1.18"]

## コード
```go
package main

import "fmt"

// ジェネリック関数 Print の定義
// [T any] で型パラメータ T (任意の型) を宣言
func Print[T any](value T) {
	fmt.Printf("Type: %T, Value: %v\n", value, value)
}

func main() {
	// 型推論による呼び出し
	Print(42)      // T は int と推論される
	Print("hello") // T は string と推論される

	// 型の明示的な指定 (通常は不要)
	// Print[bool](true)
}

```

## 解説
```text
Go 1.18 で導入された**ジェネリクス**は、**型パラメータ**を使い、
特定の型に依存しない汎用的なコードを書く機能です。
型安全性を保ちつつコードの重複を減らせます。

**ジェネリック関数:**
具体的な型ではなく**型パラメータ**を使って定義される関数。
呼び出し時に型を指定（または推論）し、様々な型に同じロジックを適用。

**定義構文:**
`func 関数名[型パラメータ名 型制約, ...] (引数) (戻り値) { ... }`
*   **`[型パラメータ名 型制約]`**: 関数名の直後に角括弧で定義。
    *   `型パラメータ名`: 型を表す名前 (例: `T`)。
    *   `型制約`: 受け入れ可能な型 (インターフェース)。
        *   **`any`**: 任意の型 (`interface{}`)。最も緩い制約。
        *   (特定のメソッドや演算を要求する制約も可能: 後述)
*   引数や戻り値の型として型パラメータ (例: `T`) を使用可能。

コード例の `func Print[T any](value T)` は、任意の型 `T` の
値 `value` を受け取り、その型と値を表示します。

**呼び出しと型推論:**
`Print(42)` のように呼び出すと、コンパイラは引数 `42` から
`T` が `int` であると**推論**します。そのため、通常は
`Print[int](42)` のように型を明示的に指定する必要はありません。
文字列、スライス、構造体など他の型でも同様に推論されます。

**(型の明示指定)**
`Print[bool](true)` のように `[型]` を付けて型を明示することも可能です
(型推論が効かない稀なケース等)。

ジェネリクスにより、型ごとに類似関数を定義する手間が省けます。
`any` 制約は最も単純ですが、より具体的な制約も可能です (後述)。