---
title: "ジェネリクス: 型パラメータを持つジェネリック関数"
tags: ["generics", "ジェネリクス", "型パラメータ", "type parameter", "関数", "any", "型推論", "Go1.18"]
---

Go 1.18 で導入された**ジェネリクス (Generics)** は、**型パラメータ (Type Parameters)** を使って、特定の型に依存しない、より汎用的なコードを書くための機能です。これにより、以前はインターフェース (`interface{}`) やリフレクションを使っていた場面で、型安全性を保ちつつコードの重複を減らすことができます。

## ジェネリック関数とは？

ジェネリック関数は、具体的な型ではなく、**型パラメータ**を使って定義される関数です。関数を呼び出す際に、型パラメータに具体的な型を指定（または型推論に任せる）ことで、様々な型に対して同じロジックを適用できます。

## ジェネリック関数の定義構文

ジェネリック関数を定義するには、関数名の**直後**に角括弧 `[]` で**型パラメータリスト**を記述します。

**構文:** `func 関数名[型パラメータ名 型制約, ...] (引数リスト) (戻り値リスト) { ... }`

*   **`[型パラメータ名 型制約, ...]`**:
    *   `型パラメータ名`: 関数内で型を表すために使う名前（通常は大文字1文字、例: `T`, `K`, `V`）。
    *   `型制約 (Type Constraint)`: この型パラメータとして受け入れ可能な型を制限する条件。インターフェース型を指定します。
        *   **`any`**: 最も緩い制約で、**任意の型**を受け入れることを意味します (`any` は `interface{}` のエイリアスです)。
        *   特定のメソッドを持つ型に制限したり、特定の演算が可能な型に制限したりすることもできます（後のセクションで説明）。
*   **引数リスト / 戻り値リスト:** 定義した型パラメータ（例: `T`）を、引数や戻り値の型として使用できます。

## コード例: 任意の型の値を表示する関数

```go title="ジェネリック関数 Print の定義と使用"
package main

import "fmt"

// --- ジェネリック関数の定義 ---
// 型パラメータ T を持つジェネリック関数 Print
// [T any] は、型パラメータ T が任意の型 (any) であることを示す
// 引数 value の型として T を使う
func Print[T any](value T) {
	fmt.Printf("型: %T, 値: %v\n", value, value)
}

// --- ジェネリック関数の呼び出し ---
func main() {
	fmt.Println("--- ジェネリック関数の呼び出し ---")

	// 1. int 型で呼び出し
	// コンパイラが引数 42 から T が int であると推論する
	Print(42)

	// 2. string 型で呼び出し
	// コンパイラが引数 "hello" から T が string であると推論する
	Print("hello")

	// 3. float64 のスライス型で呼び出し
	floatSlice := []float64{1.1, 2.2, 3.3}
	// コンパイラが引数 floatSlice から T が []float64 であると推論する
	Print(floatSlice)

	// 4. 構造体型で呼び出し
	type Person struct { Name string }
	p := Person{Name: "Alice"}
	// コンパイラが引数 p から T が main.Person であると推論する
	Print(p)

	// --- 型を明示的に指定することも可能 (通常は不要) ---
	fmt.Println("\n--- 型の明示的な指定 ---")
	// 関数名の後に角括弧で型を指定する
	Print[int](100)
	Print[string]("world")
}

/* 実行結果:
--- ジェネリック関数の呼び出し ---
型: int, 値: 42
型: string, 値: hello
型: []float64, 値: [1.1 2.2 3.3]
型: main.Person, 値: {Alice}

--- 型の明示的な指定 ---
型: int, 値: 100
型: string, 値: world
*/
```

**コード解説:**

*   `func Print[T any](value T)`:
    *   `[T any]` で、`T` という名前の型パラメータを定義し、それが任意の型 (`any`) であることを指定しています。
    *   引数 `value` の型を `T` とすることで、この関数が `T` 型の値を受け取ることを示します。
    *   関数内では、`value` を `fmt.Printf` に渡しています。`%T` で具体的な型、`%v` で値を出力しています。
*   **呼び出し時の型推論:**
    *   `Print(42)` のように関数を呼び出すと、Goコンパイラは引数 `42` の型 (`int`) を見て、型パラメータ `T` が `int` であると**推論 (Inference)** します。そのため、`Print[int](42)` のように型を明示的に指定する必要は通常ありません。
    *   同様に、`"hello"` から `T` は `string`、`floatSlice` から `T` は `[]float64`、`p` から `T` は `main.Person` と推論されます。
*   **型の明示的な指定:** `Print[int](100)` のように、関数名の直後に `[具体的な型]` を記述することで、型パラメータに使う型を明示的に指定することも可能です。これは、型推論がうまく機能しない稀なケースや、コードの意図を明確にしたい場合に役立ちます。

ジェネリック関数を使うことで、様々な型に対して共通の処理を行う関数を、型ごとに個別の関数を定義することなく、一つで表現できるようになります。`any` 制約は最も単純ですが、次のセクションでは、より具体的な制約を使って型パラメータに制限を加える方法を見ていきます。