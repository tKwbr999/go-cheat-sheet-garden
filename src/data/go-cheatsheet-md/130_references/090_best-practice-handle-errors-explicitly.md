---
title: "ベストプラクティス: エラーを明示的に処理する"
tags: ["references", "best practice", "error handling", "error", "if err != nil"]
---

Goの設計思想における最も重要な原則の一つは、**エラーを無視せず、明示的に処理する**ことです。

エラー処理の基本的なスタイルについては、**「コードスタイル: エラーハンドリング」** (`130_references/060_code-style-error-handling.md`) で説明しました。

## なぜエラーを無視してはいけないのか？

Goには例外処理 (`try-catch`) がないため、関数が返した `error` 値をチェックしないと、エラーが発生したことに気づかないままプログラムの実行が続いてしまう可能性があります。これにより、

*   予期しない動作や不正な状態
*   データの破損
*   プログラムのクラッシュ
*   デバッグの困難化

などを引き起こす可能性があります。

## 基本パターン（再確認）

エラーを返す可能性のある関数を呼び出した後は、**必ず** `if err != nil` でエラーをチェックし、適切な処理を行います。

```go
package main

import (
	"fmt"
	"log"
	"os"
)

func main() {
	fileName := "my_data.txt"

	// --- 悪い例: エラーを無視 ---
	// file, _ := os.Create(fileName) // エラーを変数 _ で受け取り、無視している
	// if file == nil {
	// 	// これではエラーの原因がわからない
	// 	log.Println("ファイルの作成に失敗しました (原因不明)")
	// 	return
	// }
	// defer file.Close()
	// _, _ = file.WriteString("...") // 書き込みエラーも無視

	// --- 良い例: エラーを明示的にチェック ---
	file, err := os.Create(fileName)
	// ★ 必ずエラーをチェック ★
	if err != nil {
		log.Printf("ファイルの作成に失敗しました: %v", err)
		return // または他の適切なエラー処理
	}
	defer file.Close()

	_, err = file.WriteString("ファイルに書き込むデータ。\n")
	// ★ 書き込みエラーもチェック ★
	if err != nil {
		log.Printf("ファイルへの書き込みに失敗しました: %v", err)
		// 必要であれば、エラーをラップして呼び出し元に返すなども検討
		// return fmt.Errorf("書き込み失敗: %w", err)
	}

	fmt.Println("ファイル操作が（おそらく）成功しました。")

	// 後片付け
	os.Remove(fileName)
}
```

**ブランク識別子 (`_`) でのエラー無視は避ける:**
エラー値を `_` で受け取ることは、そのエラーを意図的に無視することを意味します。これは、エラーが発生しても問題ないことが**絶対に確実**である場合（例えば、`Close` のエラーを意図的に無視する場合など、ただしそれも議論の余地あり）を除き、**避けるべき**です。

Goの堅牢性は、この明示的なエラーチェックの文化によって支えられています。面倒に感じるかもしれませんが、エラーを常にチェックし、適切に処理する習慣をつけましょう。