---
title: "基本の型: 文字列とバイトスライス (`[]byte`) の変換"
tags: ["basic-types", "型変換", "文字列", "string", "バイトスライス", "byte", "[]byte"]
---

Go言語では、文字列 (`string`) と**バイトスライス (`[]byte`)** は密接に関連しており、相互に変換することがよくあります。文字列が不変なバイトシーケンスであるのに対し、バイトスライスは**変更可能なバイトシーケンス**です。

この変換は、ファイルの内容を読み書きしたり、ネットワーク経由でデータを送受信したり、文字列の内容を部分的に変更したりする際によく使われます。

## 文字列 (`string`) から バイトスライス (`[]byte`) へ

文字列 `s` をバイトスライスに変換するには、`[]byte(s)` という構文を使います。この変換により、文字列 `s` の内容（バイトシーケンス）をコピーした**新しいバイトスライス**が生成されます。

```go title="string から []byte への変換"
package main

import "fmt"

func main() {
	s := "Hello Go!"
	fmt.Printf("元の文字列: \"%s\" (%T)\n", s, s)

	// 文字列をバイトスライスに変換
	byteSlice := []byte(s)

	// byteSlice は []uint8 型
	fmt.Printf("変換後のバイトスライス: %v (%T)\n", byteSlice, byteSlice)

	// バイトスライスの内容を表示 (各要素はバイト値)
	fmt.Print("バイトスライスの各要素: ")
	for _, b := range byteSlice {
		fmt.Printf("%d ", b) // ASCII コードが表示される
	}
	fmt.Println()

	// バイトスライスは変更可能
	// 例えば、最初の文字 'H' (ASCII 72) を 'J' (ASCII 74) に変更
	if len(byteSlice) > 0 {
		byteSlice[0] = 'J' // ASCII 74
	}
	fmt.Printf("変更後のバイトスライス: %v\n", byteSlice)

	// 元の文字列 s は変更されていない (不変性)
	fmt.Printf("元の文字列は不変: \"%s\"\n", s)
}

/* 実行結果:
元の文字列: "Hello Go!" (string)
変換後のバイトスライス: [72 101 108 108 111 32 71 111 33] ([]uint8)
バイトスライスの各要素: 72 101 108 108 111 32 71 111 33
変更後のバイトスライス: [74 101 108 108 111 32 71 111 33]
元の文字列は不変: "Hello Go!"
*/
```

**ポイント:**

*   `[]byte(s)` は、文字列 `s` のバイトデータをコピーして新しい `[]byte` を作ります。
*   生成されたバイトスライスは、元の文字列とは独立しており、内容を変更することができます (`byteSlice[0] = 'J'`)。
*   元の文字列 `s` は不変なので、バイトスライスを変更しても影響を受けません。

## バイトスライス (`[]byte`) から 文字列 (`string`) へ

バイトスライス `b` を文字列に変換するには、`string(b)` という構文を使います。この変換により、バイトスライス `b` の内容（バイトシーケンス）をコピーした**新しい文字列**が生成されます。

```go title="[]byte から string への変換"
package main

import "fmt"

func main() {
	byteSlice := []byte{74, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100} // "Jello World" のバイト表現
	fmt.Printf("元のバイトスライス: %v (%T)\n", byteSlice, byteSlice)

	// バイトスライスを文字列に変換
	s := string(byteSlice)

	fmt.Printf("変換後の文字列: \"%s\" (%T)\n", s, s)

	// バイトスライスを変更しても、変換後の文字列には影響しない
	if len(byteSlice) > 6 {
		byteSlice[6] = 'G' // 'W' (87) を 'G' (71) に変更
	}
	fmt.Printf("変更後のバイトスライス: %v\n", byteSlice)
	fmt.Printf("文字列は不変: \"%s\"\n", s) // s は "Jello World" のまま
}

/* 実行結果:
元のバイトスライス: [74 101 108 108 111 32 87 111 114 108 100] ([]uint8)
変換後の文字列: "Jello World" (string)
変更後のバイトスライス: [74 101 108 108 111 32 71 111 114 108 100]
文字列は不変: "Jello World"
*/
```

**ポイント:**

*   `string(b)` は、バイトスライス `b` のデータをコピーして新しい `string` を作ります。
*   生成された文字列は不変です。元のバイトスライス `b` を後から変更しても、一度作成された文字列 `s` には影響しません。

## なぜ変換が必要か？

*   **データの読み書き:** ファイルやネットワークから読み込んだデータは、通常 `[]byte` として扱われます。これを文字列として処理したい場合に `string()` で変換します。逆に、文字列データをファイルやネットワークに書き込む際には `[]byte()` で変換することがあります。
*   **文字列の部分的な変更:** 文字列は不変ですが、バイトスライスは変更可能です。文字列の一部を変更したい場合、一度 `[]byte` に変換し、目的のバイトを変更してから、再度 `string()` で文字列に戻す、という手順を踏むことがあります（ただし、UTF-8のマルチバイト文字を壊さないように注意が必要です）。

文字列とバイトスライスはGoでデータを扱う上で基本的な型であり、これらの変換は頻繁に利用されます。それぞれの特性（不変性 vs 可変性）と、変換時にデータコピーが発生することを理解しておくことが重要です。