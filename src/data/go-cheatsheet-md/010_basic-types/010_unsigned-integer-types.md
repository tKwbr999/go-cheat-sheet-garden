---
title: "基本の型: 符号なし整数 (Unsigned Integer)"
tags: ["basic-types", "整数", "uint", "byte", "uintptr"]
---

前のセクションでは符号付き整数（マイナスの値も扱える）を見ましたが、Goには**符号なし整数 (Unsigned Integer)** も用意されています。これは **0 または正の整数**のみを扱うための型です。

## 符号なし整数型とは？

符号なし整数は、マイナスの値を表現する必要がない場合に利用されます。例えば、物の個数、データのサイズ、配列のインデックスなど、負の値になることがありえない数値を扱う際に適しています。

符号付き整数と同じビット数であっても、マイナスの範囲を表現しない分、より大きな正の値を格納できます。

## Goの主な符号なし整数型

Goには、符号付き整数と同様に、様々なサイズの符号なし整数型があります。

```go title="主な符号なし整数型の宣言例"
package main

import (
	"fmt"
	"math" // 各整数型の最大値などを定義した定数を含む
	"reflect" // 型情報を調べるためのパッケージ (説明用)
	"unsafe" // uintptr のサイズ確認用 (通常は使わない)
)

func main() {
	// --- 符号なし整数 (Unsigned Integers) ---
	// 0 または 正の値を扱える

	// uint: プラットフォーム依存 (通常 32 or 64 ビット)
	// 符号なし整数の一般的な用途にはこれを使うことが多い
	var u uint = 100
	fmt.Printf("uint 型変数 u: 値=%d, 型=%s\n", u, reflect.TypeOf(u).String())

	// uint8: 8ビット (0 〜 255)
	var u8 uint8 = 255 // math.MaxUint8
	fmt.Printf("uint8 型変数 u8: 値=%d (範囲: 0 〜 %d)\n", u8, math.MaxUint8)

	// uint16: 16ビット (0 〜 65535)
	var u16 uint16 = 65535 // math.MaxUint16
	fmt.Printf("uint16 型変数 u16: 値=%d (範囲: 0 〜 %d)\n", u16, math.MaxUint16)

	// uint32: 32ビット (0 〜 4294967295)
	var u32 uint32 = 4294967295 // math.MaxUint32
	fmt.Printf("uint32 型変数 u32: 値=%d (範囲: 0 〜 %d)\n", u32, math.MaxUint32)

	// uint64: 64ビット (0 〜 18446744073709551615)
	var u64 uint64 = 18446744073709551615 // math.MaxUint64
	fmt.Printf("uint64 型変数 u64: 値=%d (範囲: 0 〜 %d)\n", u64, uint64(math.MaxUint64)) // MaxUint64 は型なし定数なのでキャスト

	// --- byte 型 ---
	// uint8 の別名 (エイリアス)
	// バイトデータを扱う際に非常によく使われる
	var b byte = 'A' // 文字 'A' の ASCII コード (65) が格納される
	fmt.Printf("\nbyte 型変数 b: 値=%d (文字='%c'), 型=%s (実体は uint8)\n", b, b, reflect.TypeOf(b).String())

	// --- uintptr 型 ---
	// ポインタ (メモリ上のアドレス) を格納するのに十分な大きさを持つ符号なし整数
	// サイズはプラットフォーム依存 (32 or 64 ビット)
	// 通常のプログラミングでは直接使うことは少ない (unsafe パッケージなど低レベルな操作で使われる)
	var ptr uintptr = 0xdeadbeef // 16進数の例 (アドレスを表すことが多い)
	fmt.Printf("\nuintptr 型変数 ptr: 値=%x, サイズ=%d バイト\n", ptr, unsafe.Sizeof(ptr))
}

/* 実行結果 (uint, uintptr のサイズは環境による):
uint 型変数 u: 値=100, 型=uint
uint8 型変数 u8: 値=255 (範囲: 0 〜 255)
uint16 型変数 u16: 値=65535 (範囲: 0 〜 65535)
uint32 型変数 u32: 値=4294967295 (範囲: 0 〜 4294967295)
uint64 型変数 u64: 値=18446744073709551615 (範囲: 0 〜 18446744073709551615)

byte 型変数 b: 値=65 (文字='A'), 型=uint8 (実体は uint8)

uintptr 型変数 ptr: 値=deadbeef, サイズ=8 バイト (64ビット環境の場合)
*/
```

**コード解説:**

*   **符号なし整数:** `uint`, `uint8`, `uint16`, `uint32`, `uint64` があります。
    *   `uint`: `int` と同様に、サイズが実行環境によって変わります。負の値にならないことが分かっている整数の一般的な用途に使われます。
    *   `uint8`, `uint16`, `uint32`, `uint64`: サイズが固定されています。扱える最大値が対応する符号付き整数型の約2倍になります。
*   **`byte`:** `uint8` の**別名（エイリアス）**です。Goでは、バイト列（ファイルのデータ、ネットワーク通信のデータなど）を扱う際に `[]byte` (byteのスライス) の形で非常によく使われます。`byte` は `uint8` と全く同じもので、0から255までの値を表現します。
*   **`uintptr`:** ポインタ（メモリ上のアドレス）を整数として表現するための特殊な型です。サイズはポインタと同じ（32ビット環境なら32ビット、64ビット環境なら64ビット）になります。`unsafe` パッケージを使った低レベルなメモリ操作などで使われますが、**通常のアプリケーション開発で直接使うことはほとんどありません**。

**どの型を選ぶべきか？**

*   負の値を取らないことが保証されている一般的な整数には `uint` を使います。
*   バイトデータを扱う場合は `byte` (`uint8`) を使います。
*   ビット演算や特定のビット数が必要な場合、または非常に大きな正の整数が必要な場合は、`uint16`, `uint32`, `uint64` を検討します。
*   `uintptr` は通常は使用しません。

符号付き整数と符号なし整数を適切に使い分けることで、より安全で効率的なコードを書くことができます。