## タイトル
title: 浮動小数点数 (Floating-Point)

## タグ
tags: ["basic-types", "浮動小数点数", "float32", "float64", "精度"]

## コード
```go
package main

import "fmt"

func main() {
	// float64 (デフォルト)
	var pi float64 = 3.14159
	radius := 5.0 // 型推論で float64
	area := pi * radius * radius
	fmt.Printf("Area (float64): %.5f\n", area)

	// float32
	var gravity float32 = 9.81
	mass := float32(10.0) // 型変換
	force := mass * gravity
	fmt.Printf("Force (float32): %.3f\n", force)

	// 誤差の注意点
	sum := 0.1 + 0.2
	fmt.Printf("0.1 + 0.2 = %.17f\n", sum) // 正確に 0.3 にならない可能性
	fmt.Printf("sum == 0.3 is %t\n", sum == 0.3)
}
```

## 解説
```text
**浮動小数点数 (Floating-Point Number)** は、
小数点を含む数値を表現するための型です。
非常に大きな数や小さな数も扱えます。
Goには **IEEE 754** 規格に基づいた
2種類があります。

**Goの浮動小数点数型:**
*   **`float32`**: 32ビット (単精度)。
    メモリ使用量は少ないが、精度や範囲は `float64` より劣る。
*   **`float64`**: 64ビット (倍精度)。
    より高い精度と広い範囲を持つ。
    **小数点を含む数値リテラル (例: `3.14`) は
    デフォルトで `float64`** になります。
    **特別な理由がなければ `float64` を使うのが一般的**です。

**型変換:**
`float32(10.0)` のように、型名を関数のように使って
明示的に型変換（キャスト）できます。

**誤差に関する注意点:**
浮動小数点数は内部的に2進数で近似されるため、
`0.1` のような10進小数でも誤差が生じることがあります。
そのため、`0.1 + 0.2` が正確に `0.3` になるとは限らず、
**浮動小数点数同士を `==` で比較するのは
一般的に避けるべき**です。
比較する際は、差の絶対値が非常に小さい値
(イプシロン) 以下かを確認するなどの方法を取ります。

**使い分け:**
*   **`float64`**: ほとんどの場合に推奨。
*   **`float32`**: メモリ節約が必要な場合や
    外部システムとの互換性のためなど、限定的に使用。