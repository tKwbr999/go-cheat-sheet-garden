---
title: "基本の型: 文字列の基本操作 (長さ, アクセス, 部分文字列)"
tags: ["basic-types", "文字列", "string", "len", "インデックス", "スライス"]
---

Goの文字列 (`string`) は、テキストデータを扱うための基本的な型ですが、その内部表現（バイトシーケンス）と不変性（変更不可）を理解することが重要です。ここでは、文字列の長さの取得、特定の位置へのアクセス、部分文字列の取得といった基本的な操作を見ていきましょう。

## 文字列の長さ: `len()` 関数

組み込み関数の `len()` を使うと、文字列の**バイト数**を取得できます。

**注意:** Goの文字列はUTF-8エンコーディングされているため、日本語のようなマルチバイト文字が含まれる場合、`len()` が返すバイト数は**文字数とは一致しません**。

```go title="len() による文字列の長さ（バイト数）取得"
package main

import "fmt"

func main() {
	s1 := "hello"
	s2 := "こんにちは" // 日本語はマルチバイト文字

	// len() はバイト数を返す
	len1 := len(s1) // "h", "e", "l", "l", "o" はそれぞれ 1 バイト
	len2 := len(s2) // "こ", "ん", "に", "ち", "は" は UTF-8 ではそれぞれ 3 バイト

	fmt.Printf("文字列 \"%s\" の長さ (バイト数): %d\n", s1, len1) // 5
	fmt.Printf("文字列 \"%s\" の長さ (バイト数): %d\n", s2, len2) // 15 (5文字 * 3バイト/文字)

	// 文字数を数える場合は utf8.RuneCountInString を使う (後のセクションで解説)
	// import "unicode/utf8"
	// fmt.Printf("文字列 \"%s\" の文字数: %d\n", s2, utf8.RuneCountInString(s2)) // 5
}

/* 実行結果:
文字列 "hello" の長さ (バイト数): 5
文字列 "こんにちは" の長さ (バイト数): 15
*/
```

## 文字列へのインデックスアクセス: `s[i]`

文字列 `s` に対して `s[i]` のようにインデックス（`i` は 0 から始まる位置）を指定すると、その位置にある**バイト (byte)** にアクセスできます。

**注意:** これは**文字**へのアクセスではありません。特にマルチバイト文字の場合、`s[i]` は文字の一部（1バイト目など）を返すだけであり、文字そのものではありません。また、文字列は不変なので、`s[i] = 'a'` のような代入はできません。

```go title="インデックスによるバイトアクセス"
package main

import "fmt"

func main() {
	s := "hello"

	// インデックスは 0 から始まる
	byte1 := s[0] // 0番目のバイト ('h' の ASCII コード)
	byte2 := s[1] // 1番目のバイト ('e' の ASCII コード)

	fmt.Printf("s[0]: 値=%d (文字='%c'), 型=%T\n", byte1, byte1, byte1) // byte (uint8)
	fmt.Printf("s[1]: 値=%d (文字='%c'), 型=%T\n", byte2, byte2, byte2) // byte (uint8)

	// マルチバイト文字の場合
	jp := "Go言語"
	fmt.Printf("\n文字列 \"%s\" のバイト表現:\n", jp)
	for i := 0; i < len(jp); i++ {
		fmt.Printf("  インデックス %d: %d (16進: %x)\n", i, jp[i], jp[i])
	}
	// 'G' は 1 バイト (71)
	// 'o' は 1 バイト (111)
	// '言' は 3 バイト (e8 a8 80)
	// '語' は 3 バイト (e8 aa 9e)
	// jp[2] は '言' の1バイト目 (e8) であり、文字 '言' ではないことに注意

	// 文字単位でアクセスするには for range を使う (後のセクションで解説)
}

/* 実行結果:
s[0]: 値=104 (文字='h'), 型=uint8
s[1]: 値=101 (文字='e'), 型=uint8

文字列 "Go言語" のバイト表現:
  インデックス 0: 71 (16進: 47)
  インデックス 1: 111 (16進: 6f)
  インデックス 2: 232 (16進: e8)
  インデックス 3: 168 (16進: a8)
  インデックス 4: 128 (16進: 80)
  インデックス 5: 232 (16進: e8)
  インデックス 6: 170 (16進: aa)
  インデックス 7: 158 (16進: 9e)
*/
```

## 部分文字列の取得 (スライス): `s[i:j]`

文字列 `s` に対して `s[i:j]` のように範囲を指定すると、インデックス `i` から `j-1` までのバイトシーケンスからなる**新しい部分文字列**を取得できます。これを**スライス (slice)** 操作と呼びます。

*   `i` は開始インデックス（この位置のバイトは含まれる）。省略すると `0` になります (`s[:j]`)。
*   `j` は終了インデックス（この位置のバイトは含まれない）。省略すると文字列の最後までになります (`s[i:]`)。
*   元の文字列 `s` は変更されません（不変性）。

```go title="スライスによる部分文字列取得"
package main

import "fmt"

func main() {
	s := "abcdefg"

	// インデックス 1 から 3-1=2 まで ("bc")
	sub1 := s[1:3]
	fmt.Printf("s[1:3] = \"%s\"\n", sub1)

	// インデックス 0 から 4-1=3 まで ("abcd")
	sub2 := s[:4] // 開始インデックス 0 は省略可能
	fmt.Printf("s[:4]  = \"%s\"\n", sub2)

	// インデックス 2 から最後まで ("cdefg")
	sub3 := s[2:] // 終了インデックスは省略可能
	fmt.Printf("s[2:]  = \"%s\"\n", sub3)

	// 全体 ("abcdefg")
	sub4 := s[:]
	fmt.Printf("s[:]   = \"%s\"\n", sub4)

	// 元の文字列は変わらない
	fmt.Printf("元の文字列 s = \"%s\"\n", s)
}

/* 実行結果:
s[1:3] = "bc"
s[:4]  = "abcd"
s[2:]  = "cdefg"
s[:]   = "abcdefg"
元の文字列 s = "abcdefg"
*/
```

これらの基本操作は、文字列データを扱う上で頻繁に利用されます。ただし、Goの文字列がバイトシーケンスであり、特にマルチバイト文字を扱う際には注意が必要であることを覚えておきましょう。文字単位での操作については、後のセクションで詳しく説明します。