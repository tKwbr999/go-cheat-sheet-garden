## タイトル
title: 数値型間の明示的な変換

## タグ
tags: ["basic-types", "型変換", "キャスト", "int", "float64", "uint"]

## コード
```go
package main

import "fmt"

func main() {
	var i int = 100
	var f float64 = 3.14

	// 異なる型同士の演算には変換が必要
	// fmt.Println(i + f) // コンパイルエラー

	// int を float64 に変換
	result1 := float64(i) + f
	fmt.Printf("float64(%d) + %f = %f\n", i, f, result1)

	// float64 を int に変換 (小数点以下切り捨て)
	result2 := i + int(f) // int(3.14) は 3
	fmt.Printf("%d + int(%f) = %d\n", i, f, result2)

	// 異なる型への代入にも変換が必要
	var f2 float64 = float64(i)
	fmt.Printf("int -> float64: %f\n", f2)

	// 精度低下の例
	var largeF float64 = 123.789
	var intFromF int = int(largeF) // 123 になる
	fmt.Printf("int(%.3f) = %d\n", largeF, intFromF)

	// オーバーフローの可能性 (例: int64 -> int8)
	// var big int64 = 1000
	// var small int8 = int8(big) // 範囲外だと予期しない値に
}
```

## 解説
```text
Goは**静的型付け言語**であり、異なる数値型
(例: `int`, `float64`, `uint`) 間での
値の代入や演算には**明示的な型変換**が必要です。
自動的な型変換（暗黙の型変換）はありません。

**なぜ明示的か？**
意図しないデータの損失（精度低下やオーバーフロー）や
予期せぬ挙動を防ぐためです。プログラマが
変換を意識的に行うことを要求します。

**変換構文: `T(v)`**
値 `v` を型 `T` に変換するには `T(v)` と書きます。

**例:**
*   `float64(i)`: `int` 型の `i` を `float64` に変換。
*   `int(f)`: `float64` 型の `f` を `int` に変換。
    **小数点以下は切り捨てられます**。

**異なる型同士の演算/代入:**
コード例のように、`int` と `float64` を直接足したり、
`int` 型の値を `float64` 型の変数に直接代入
しようとするとコンパイルエラーになります。
演算や代入の前に、型を合わせるための
明示的な変換が必要です。

**変換時の注意点:**
*   **精度低下:** 浮動小数点数を整数に変換すると
    小数点以下が切り捨てられます。
*   **オーバーフロー:** 大きなサイズの型
    (例: `int64`) から小さなサイズの型
    (例: `int8`) へ変換する際、元の値が
    変換先の型の範囲を超えていると、
    値がラップアラウンドしたり未定義の動作に
    なったりする可能性があります。
    必要に応じて変換前に値の範囲チェックを行います。

明示的な型変換によりコードの意図が明確になり、
型の不一致によるバグを減らせますが、
データ損失の可能性には注意が必要です。