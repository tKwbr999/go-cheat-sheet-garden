---
title: "メソッド: 値レシーバ (Value Receiver)"
tags: ["methods", "レシーバ", "値レシーバ", "値渡し", "コピー", "不変"]
---

メソッドを定義する際、レシーバの型を**値**（例: `T`) で指定するか、**ポインタ**（例: `*T`) で指定するかを選択できます。ここでは、**値レシーバ (Value Receiver)** について詳しく見ていきます。

## 値レシーバとは？

メソッド定義でレシーバの型を値（非ポインタ）で指定すると、そのメソッドは**値レシーバ**を持ちます。

**構文:** `func (レシーバ変数名 レシーバ型) メソッド名(...) ...` (例: `func (r Rectangle) Area() ...`)

値レシーバを持つメソッドが呼び出されると、レシーバの値（メソッドを呼び出した変数）の**コピー**がメソッドに渡されます。これは、関数に値を引数として渡す際の**値渡し**と同じ挙動です。

## 値レシーバの特徴

*   **元の値は変更されない:** メソッド内でレシーバ変数（のフィールドなど）を変更しても、それは**コピーに対する変更**であり、メソッドの呼び出し元にある元の値には**影響しません**。
*   **安全性:** 意図せずに元の値を変更してしまう心配がありません。
*   **コピーコスト:** レシーバの型（特に構造体）が大きい場合、メソッド呼び出しのたびに値全体のコピーが発生するため、パフォーマンスに影響を与える可能性があります。

## コード例

```go title="値レシーバの挙動"
package main

import "fmt"

type Point struct {
	X, Y int
}

// --- 値レシーバを持つメソッド ---

// Display メソッド: Point の座標を表示する (レシーバを変更しない)
// レシーバ p は Point 型 (値)
func (p Point) Display() {
	fmt.Printf("[%d, %d]", p.X, p.Y)
	// メソッド内で p.X や p.Y を変更しても、呼び出し元の値には影響しない
	// p.X = 999 // この変更は呼び出し元には反映されない
}

// Shift メソッド: Point の座標をずらそうとするが... (値レシーバ)
// このメソッドは期待通りに動作しない！
func (p Point) Shift(dx, dy int) {
	fmt.Printf("  (Shiftメソッド内: 変更前 p=%+v)\n", p)
	// ここでの変更はレシーバ p のコピーに対して行われる
	p.X += dx
	p.Y += dy
	fmt.Printf("  (Shiftメソッド内: 変更後 p=%+v)\n", p)
}

// Shifted メソッド: 座標をずらした「新しい」Point を返す (値レシーバ)
// こちらの方が値レシーバの意図に合っていることが多い
func (p Point) Shifted(dx, dy int) Point {
	// 新しい Point を作成して返す
	return Point{
		X: p.X + dx,
		Y: p.Y + dy,
	}
}

func main() {
	pt := Point{X: 10, Y: 20}
	fmt.Printf("初期状態 pt: %+v\n", pt)

	// --- Display メソッド呼び出し ---
	fmt.Print("Display() 呼び出し: ")
	pt.Display() // pt のコピーが Display メソッドに渡される
	fmt.Println()
	fmt.Printf("Display() 後の pt: %+v (変更なし)\n", pt)

	// --- Shift メソッド呼び出し (期待通りに動作しない例) ---
	fmt.Println("\nShift(5, 5) を呼び出し...")
	pt.Shift(5, 5) // pt のコピーが Shift メソッドに渡される
	fmt.Printf("Shift() 後の pt: %+v (変更されていない！)\n", pt)

	// --- Shifted メソッド呼び出し ---
	fmt.Println("\nShifted(5, 5) を呼び出し...")
	shiftedPt := pt.Shifted(5, 5) // pt のコピーが Shifted に渡され、新しい Point が返る
	fmt.Printf("Shifted() が返した新しい Point: %+v\n", shiftedPt)
	fmt.Printf("Shifted() 後の元の pt: %+v (変更なし)\n", pt)
}

/* 実行結果:
初期状態 pt: {X:10 Y:20}
Display() 呼び出し: [10, 20]
Display() 後の pt: {X:10 Y:20} (変更なし)

Shift(5, 5) を呼び出し...
  (Shiftメソッド内: 変更前 p={X:10 Y:20})
  (Shiftメソッド内: 変更後 p={X:15 Y:25})
Shift() 後の pt: {X:10 Y:20} (変更されていない！)

Shifted(5, 5) を呼び出し...
Shifted() が返した新しい Point: {X:15 Y:25}
Shifted() 後の元の pt: {X:10 Y:20} (変更なし)
*/
```

**コード解説:**

*   `Display` メソッドは値レシーバ `p Point` を持ちます。メソッド内で `p` のフィールド値を読み取っていますが、変更はしていません。呼び出し元の `pt` には影響ありません。
*   `Shift` メソッドも値レシーバ `p Point` を持ちます。メソッド内で `p.X += dx` のようにフィールドを変更していますが、これは `pt` の**コピー**に対する変更なので、呼び出し元の `pt` の値は変わりません。
*   `Shifted` メソッドは値レシーバ `p Point` を持ち、計算結果として**新しい `Point`** を生成して返します。これは、レシーバの値を変更せずに計算結果を返すメソッドの良い例です。

## 値レシーバを使うべき場合

一般的に、以下のいずれかに該当する場合は値レシーバを使うことが推奨されます。

1.  **メソッドがレシーバの状態を変更する必要がない場合:**
    *   単にレシーバのフィールド値を読み取って何かを計算したり、表示したりするだけのメソッド（例: `Area`, `Display`, `Length` など）。
2.  **レシーバが小さなデータ構造である場合:**
    *   `int`, `float64`, `bool`, `string` のような基本型や、フィールド数が少なくコピーコストが無視できる小さな構造体。
3.  **レシーバの不変性を保証したい場合:**
    *   メソッド呼び出しによって元の値が変更されないことを明確にしたい場合。
4.  **`nil` レシーバを扱う必要がない場合:**
    *   値レシーバは `nil` になることがありません（値そのものが渡されるため）。

メソッドがレシーバの状態を変更する必要がある場合や、レシーバが大きい構造体でコピーコストを避けたい場合は、次のセクションで説明する**ポインタレシーバ**を使います。