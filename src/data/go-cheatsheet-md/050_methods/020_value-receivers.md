## タイトル
title: メソッド: 値レシーバ (Value Receiver)

## タグ
tags: ["methods", "レシーバ", "値レシーバ", "値渡し", "コピー", "不変"]

## コード
```go
package main

import "fmt"

type Point struct{ X, Y int }

// Display メソッド (値レシーバ)
func (p Point) Display() {
	fmt.Printf("[%d, %d]", p.X, p.Y)
	// p.X = 999 // ここで変更しても呼び出し元には影響しない
}

// Shift メソッド (値レシーバ) - 呼び出し元の値は変更できない
func (p Point) Shift(dx, dy int) {
	fmt.Printf("  (Shift内 変更前: %+v)\n", p)
	p.X += dx // コピーを変更
	p.Y += dy // コピーを変更
	fmt.Printf("  (Shift内 変更後: %+v)\n", p)
}

func main() {
	pt := Point{X: 10, Y: 20}
	fmt.Printf("初期状態: %+v\n", pt)

	fmt.Print("Display() 呼び出し: ")
	pt.Display() // pt のコピーが渡される
	fmt.Println()
	fmt.Printf("Display() 後: %+v (変更なし)\n", pt)

	fmt.Println("\nShift(5, 5) 呼び出し...")
	pt.Shift(5, 5) // pt のコピーが渡される
	fmt.Printf("Shift() 後: %+v (変更なし！)\n", pt)
}

```

## 解説
```text
メソッド定義でレシーバの型を値（非ポインタ `T`）で指定すると、
**値レシーバ (Value Receiver)** となります。
`func (変数名 型名) メソッド名(...) ...`

**動作:**
メソッドが呼び出されると、レシーバの値（呼び出し元の変数）の
**コピー**がメソッドに渡されます (関数への値渡しと同じ)。

**特徴:**
*   **元の値は変更されない:** メソッド内でレシーバ変数
    (のフィールド等) を変更しても、それはコピーに対する変更であり、
    呼び出し元の値には**影響しません**。
    コード例の `Shift` メソッド内で `p.X` を変更しても、
    `main` 関数の `pt.X` は変わりません。
*   **安全性:** 意図せず元の値を変更する心配がない。
*   **コピーコスト:** レシーバの型が大きい場合、コピーに
    コストがかかる可能性がある。

**値レシーバを使うべき場合:**
1.  **メソッドがレシーバの状態を変更する必要がない場合**
    (例: 値の読み取り、計算結果の返却 `Area()`, 表示 `Display()`)。
    値を変更せずに新しい値を返すメソッド (`Shifted`) もこれに該当。
2.  **レシーバが小さなデータ構造の場合**
    (基本型、小さなstructなどコピーコストが小さい)。
3.  **レシーバの不変性を保証したい場合**。
4.  **`nil` レシーバを扱う必要がない場合** (値は `nil` にならない)。

レシーバの状態を変更する必要がある場合や、コピーコストを
避けたい場合は**ポインタレシーバ (`*T`)** を使います。