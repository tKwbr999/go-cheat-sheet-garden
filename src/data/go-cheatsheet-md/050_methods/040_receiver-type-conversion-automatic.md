---
title: "メソッド: レシーバ型の自動変換"
tags: ["methods", "レシーバ", "値レシーバ", "ポインタレシーバ", "ポインタ", "アドレス", "デリファレンス"]
---

メソッドを呼び出す際、メソッドが定義されているレシーバの型（値 `T` かポインタ `*T` か）と、実際にメソッドを呼び出す変数の型（値 `T` かポインタ `*T` か）が一致していなくても、多くの場合 Go が自動的に型を合わせてくれます。これにより、メソッド呼び出しの記述が簡潔になります。

## 自動変換のパターン

`T` 型の値 `v` と、`*T` 型のポインタ `p` があるとします。

1.  **値レシーバメソッド `func (recv T) Method() {}` の呼び出し:**
    *   `v.Method()`: そのまま呼び出せます。`v` のコピーがメソッドに渡されます。
    *   `p.Method()`: **呼び出せます。** Go が自動的にポインタ `p` をデリファレンス (`*p`) し、その値のコピーをメソッドに渡します。

2.  **ポインタレシーバメソッド `func (recv *T) Method() {}` の呼び出し:**
    *   `p.Method()`: そのまま呼び出せます。ポインタ `p` がメソッドに渡されます。
    *   `v.Method()`: **呼び出せます（`v` がアドレス可能なら）。** Go が自動的に値 `v` のアドレス (`&v`) を取得し、そのポインタをメソッドに渡します。

**アドレス可能 (Addressable):** 変数のように、メモリ上のアドレスを取得できる値のことです。リテラル（例: `Point{1, 2}`）や関数の戻り値などは通常アドレス可能ではありません。

## コード例

```go title="レシーバ型の自動変換例"
package main

import "fmt"

type Counter struct {
	count int
}

// 値レシーバメソッド: 現在の値を取得 (レシーバを変更しない)
func (c Counter) Value() int {
	fmt.Println("  (Value() [値レシーバ] が呼ばれました)")
	return c.count
}

// ポインタレシーバメソッド: カウンタを増やす (レシーバを変更する)
func (c *Counter) Increment() {
	fmt.Println("  (Increment() [ポインタレシーバ] が呼ばれました)")
	if c == nil {
		return
	}
	c.count++ // ポインタ経由で元の値を変更
}

func main() {
	// --- 値変数でメソッド呼び出し ---
	var c1 Counter // 値 {count: 0}
	fmt.Println("--- 値変数 c1 で呼び出し ---")

	// 1. 値で値レシーバメソッド呼び出し (OK)
	fmt.Printf("c1.Value() -> %d\n", c1.Value())

	// 3. 値でポインタレシーバメソッド呼び出し (OK, 自動で &c1 が渡される)
	c1.Increment()
	fmt.Printf("Increment() 後の c1.count: %d\n", c1.count) // c1 の値が変更される

	// --- ポインタ変数でメソッド呼び出し ---
	c2 := &Counter{count: 10} // ポインタ *Counter
	fmt.Println("\n--- ポインタ変数 c2 で呼び出し ---")

	// 2. ポインタで値レシーバメソッド呼び出し (OK, 自動で *c2 が渡される)
	fmt.Printf("c2.Value() -> %d\n", c2.Value())

	// 4. ポインタでポインタレシーバメソッド呼び出し (OK)
	c2.Increment()
	fmt.Printf("Increment() 後の c2.count: %d\n", c2.count) // c2 が指す先の値が変更される

	// --- アドレス不可能な値での呼び出し ---
	fmt.Println("\n--- アドレス不可能な値 ---")
	// Counter{count: 100}.Value() // 値レシーバは OK (一時的な値のコピーで呼ばれる)
	// fmt.Printf("リテラルの Value(): %d\n", Counter{count: 100}.Value())

	// Counter{count: 100}.Increment() // ポインタレシーバは NG!
	// コンパイルエラー: cannot call pointer method Increment on Counter literal
	// cannot take the address of Counter literal
	// 理由: リテラルはメモリ上の固定アドレスを持たないため、Go が自動でアドレス (&) を取得できない。
}

/* 実行結果:
--- 値変数 c1 で呼び出し ---
  (Value() [値レシーバ] が呼ばれました)
c1.Value() -> 0
  (Increment() [ポインタレシーバ] が呼ばれました)
Increment() 後の c1.count: 1

--- ポインタ変数 c2 で呼び出し ---
  (Value() [値レシーバ] が呼ばれました)
c2.Value() -> 10
  (Increment() [ポインタレシーバ] が呼ばれました)
Increment() 後の c2.count: 11

--- アドレス不可能な値 ---
*/
```

**コード解説:**

*   `c1.Value()`: 値 `c1` で値レシーバメソッド `Value` を呼び出し。
*   `c1.Increment()`: 値 `c1` でポインタレシーバメソッド `Increment` を呼び出し。Goが自動的に `&c1` を渡します。
*   `c2.Value()`: ポインタ `c2` で値レシーバメソッド `Value` を呼び出し。Goが自動的に `*c2` を渡します。
*   `c2.Increment()`: ポインタ `c2` でポインタレシーバメソッド `Increment` を呼び出し。
*   `Counter{count: 100}.Increment()` はコンパイルエラーになります。`Increment` はポインタレシーバを要求しますが、構造体リテラル `Counter{count: 100}` は一時的な値であり、そのアドレスを取得できないため、Goは自動的にポインタを渡すことができません。

## まとめ

Goのこの自動変換機能により、メソッドを呼び出す側は、メソッドが値レシーバかポインタレシーバかを常に意識する必要がなくなり、コードがシンプルになります。ただし、ポインタレシーバメソッドはアドレス可能な値に対してのみ呼び出せるという制約は覚えておく必要があります。

メソッドを定義する際に値レシーバとポインタレシーバのどちらを選ぶかは、メソッドがレシーバを変更するかどうか、コピーコスト、一貫性などを考慮して決定します（一般的にはポインタレシーバが推奨されることが多いです）。