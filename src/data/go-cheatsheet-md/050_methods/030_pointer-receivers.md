## タイトル
title: ポインタレシーバ (Pointer Receiver)

## タグ
tags: ["methods", "レシーバ", "ポインタレシーバ", "ポインタ", "参照渡し", "変更"]

## コード
```go
package main

import "fmt"

type Point struct{ X, Y int }

// Shift メソッド (ポインタレシーバ *Point)
func (p *Point) Shift(dx, dy int) {
	if p == nil { // nil チェック推奨
		fmt.Println("nil レシーバです")
		return
	}
	fmt.Printf("  (Shift内 変更前: %+v)\n", *p)
	p.X += dx // ポインタ経由で元の値を変更
	p.Y += dy
	fmt.Printf("  (Shift内 変更後: %+v)\n", *p)
}

func main() {
	pt1 := Point{X: 10, Y: 20}
	fmt.Printf("初期状態 pt1: %+v\n", pt1)

	fmt.Println("\nShift(5, 5) 呼び出し...")
	// 値変数 pt1 でポインタレシーバメソッドを呼ぶ
	// Go が暗黙的にアドレス (&pt1) を渡す
	pt1.Shift(5, 5)
	fmt.Printf("Shift() 後の pt1: %+v (変更された！)\n", pt1)

	// var nilPtr *Point = nil
	// nilPtr.Shift(1, 1) // メソッド内で nil チェックがあれば panic しない
}

```

## 解説
```text
メソッド定義でレシーバ型を**ポインタ (`*型名`)** で指定すると、
**ポインタレシーバ (Pointer Receiver)** となります。

**構文:** `func (レシーバ名 *レシーバ型) メソッド名(...) ...`
例: `func (p *Point) Shift(...)`

**動作:**
メソッドが呼び出されると、レシーバの値の
**メモリアドレス（ポインタ）**がメソッドに渡されます
(参照渡しに近い)。

**特徴:**
*   **元の値を変更できる:** メソッド内でレシーバ変数 (ポインタ) を
    通じてフィールド等を変更すると、呼び出し元の**元の値に反映**される。
    コード例の `Shift` メソッド内で `p.X += dx` とすると、
    呼び出し元の `pt1.X` が変更されます。
*   **コピーコスト回避:** 大きな構造体でもポインタのコピーは軽量。
*   **`nil` レシーバの可能性:** ポインタは `nil` になりうるため、
    メソッド内で `nil` チェックが必要な場合がある。
    (例: `if p == nil { return }`)

**呼び出し時の自動変換:**
*   値変数 (`pt1`) でポインタレシーバメソッド (`Shift`) を
    呼び出すと、Goは自動的にアドレス (`&pt1`) を渡します。
*   ポインタ変数 (`ptPtr`) で値レシーバメソッド (`Display`) を
    呼び出すと、Goは自動的にデリファレンス (`*ptPtr`) して値を渡します。

**ポインタレシーバを使うべき場合:**
1.  **メソッドがレシーバの状態を変更する必要がある場合** (最重要)。
2.  **レシーバが大きな構造体でコピーコストを避けたい場合**。
3.  型のメソッドセットの一貫性のため。
4.  `nil` レシーバを特別扱いしたい場合。

Goでは、**構造体に対するメソッドではポインタレシーバを使うことが
一般的**です。特に理由がなければポインタレシーバを検討しましょう。