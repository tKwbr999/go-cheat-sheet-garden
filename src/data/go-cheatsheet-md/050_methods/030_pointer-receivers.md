---
title: "メソッド: ポインタレシーバ (Pointer Receiver)"
tags: ["methods", "レシーバ", "ポインタレシーバ", "ポインタ", "参照渡し", "変更"]
---

メソッドを定義する際、レシーバの型を**ポインタ**（例: `*T`) で指定すると、そのメソッドは**ポインタレシーバ (Pointer Receiver)** を持ちます。これは、メソッド内でレシーバが指す**元の値を変更**したい場合や、大きな構造体のコピーコストを避けたい場合に非常に重要です。

## ポインタレシーバとは？

メソッド定義でレシーバの型をポインタ (`*型名`) で指定します。

**構文:** `func (レシーバ変数名 *レシーバ型) メソッド名(...) ...` (例: `func (r *Rectangle) Scale(...) ...`)

ポインタレシーバを持つメソッドが呼び出されると、レシーバの値（メソッドを呼び出した変数）の**メモリアドレス（ポインタ）**がメソッドに渡されます。これは、関数にポインタを引数として渡す際の**参照渡し**に似た挙動です。

## ポインタレシーバの特徴

*   **元の値を変更できる:** メソッド内でレシーバ変数（ポインタ）を通じてフィールドなどを変更すると、その変更はメソッドの呼び出し元にある**元の値に反映**されます。
*   **コピーコストの回避:** レシーバの型（特に構造体）が大きい場合でも、メソッド呼び出し時にコピーされるのはポインタ（メモリアドレス）だけなので、値レシーバのような大きなコピーコストが発生しません。
*   **`nil` レシーバの扱い:** レシーバが `nil` である可能性をメソッド内で考慮する必要がある場合があります（メソッド内で `nil` チェックを行うなど）。

## コード例

前のセクションの `Point` 構造体の `Shift` メソッドをポインタレシーバを使って書き直してみましょう。

```go title="ポインタレシーバの挙動"
package main

import "fmt"

type Point struct {
	X, Y int
}

// --- ポインタレシーバを持つメソッド ---

// Shift メソッド: Point の座標をずらす
// レシーバ p は *Point 型 (ポインタ)
func (p *Point) Shift(dx, dy int) {
	// nil チェック (ポインタレシーバでは重要)
	if p == nil {
		fmt.Println("  (Shiftメソッド内: レシーバが nil です)")
		return
	}
	fmt.Printf("  (Shiftメソッド内: 変更前 p=%+v)\n", *p) // *p でポインタが指す値を取得
	// ポインタ p を通じて元の Point のフィールドを変更する
	// p.X += dx は (*p).X += dx と同じ意味 (Goが自動解釈)
	p.X += dx
	p.Y += dy
	fmt.Printf("  (Shiftメソッド内: 変更後 p=%+v)\n", *p)
}

// --- 比較のための値レシーバメソッド (再掲) ---
func (p Point) Display() {
	fmt.Printf("[%d, %d]", p.X, p.Y)
}

func main() {
	pt1 := Point{X: 10, Y: 20}
	fmt.Printf("初期状態 pt1: %+v\n", pt1)

	// --- Shift メソッド呼び出し (ポインタレシーバ) ---
	fmt.Println("\nShift(5, 5) を呼び出し...")
	// pt1 は値だが、ポインタレシーバメソッドを呼び出すと Go が暗黙的にアドレス (&pt1) を渡す
	pt1.Shift(5, 5)
	fmt.Printf("Shift() 後の pt1: %+v (変更されている！)\n", pt1)

	// --- ポインタ変数でメソッド呼び出し ---
	pt2 := &Point{X: 100, Y: 200} // pt2 は *Point 型
	fmt.Printf("\n初期状態 pt2: %+v\n", *pt2)

	fmt.Println("\npt2.Shift(-10, -10) を呼び出し...")
	pt2.Shift(-10, -10) // ポインタ変数でポインタレシーバメソッドを呼び出す
	fmt.Printf("Shift() 後の pt2: %+v\n", *pt2)

	// --- nil レシーバの扱い ---
	var nilPtr *Point = nil
	fmt.Println("\nnilPtr.Shift(1, 1) を呼び出し...")
	// nil ポインタでメソッドを呼び出しても panic はしない (メソッド内で nil チェックが必要)
	nilPtr.Shift(1, 1)
	fmt.Println("nilPtr.Shift() 完了")

	// 参考: 値レシーバメソッドもポインタで呼び出せる
	fmt.Print("\npt2.Display() 呼び出し: ")
	pt2.Display() // Go が暗黙的にデリファレンス (*pt2) して値を渡す
	fmt.Println()
}

/* 実行結果:
初期状態 pt1: {X:10 Y:20}

Shift(5, 5) を呼び出し...
  (Shiftメソッド内: 変更前 p={X:10 Y:20})
  (Shiftメソッド内: 変更後 p={X:15 Y:25})
Shift() 後の pt1: {X:15 Y:25} (変更されている！)

初期状態 pt2: {X:100 Y:200}

pt2.Shift(-10, -10) を呼び出し...
  (Shiftメソッド内: 変更前 p={X:100 Y:200})
  (Shiftメソッド内: 変更後 p={X:90 Y:190})
Shift() 後の pt2: {X:90 Y:190}

nilPtr.Shift(1, 1) を呼び出し...
  (Shiftメソッド内: レシーバが nil です)
nilPtr.Shift() 完了

pt2.Display() 呼び出し: [90, 190]
*/
```

**コード解説:**

*   `func (p *Point) Shift(dx, dy int)`: レシーバ `p` が `*Point` 型（ポインタ）になっています。
*   メソッド内で `p.X += dx` のようにフィールドを変更すると、`p` が指している**元の `Point` の値**が変更されます。
*   `pt1.Shift(5, 5)`: `pt1` は `Point` 型（値）ですが、ポインタレシーバメソッド `Shift` を呼び出すことができます。この場合、Goは自動的に `pt1` のアドレス (`&pt1`) をメソッドに渡します。そのため、`pt1` の値が変更されます。
*   `pt2.Shift(-10, -10)`: `pt2` は `*Point` 型（ポインタ）なので、そのまま `Shift` メソッド（ポインタレシーバ）を呼び出せます。
*   `nilPtr.Shift(1, 1)`: `nil` ポインタでメソッドを呼び出すことも可能です。メソッド内で `p == nil` のチェックを行っているため、パニックせずに安全に処理されます。
*   `pt2.Display()`: ポインタ変数 `pt2` で値レシーバメソッド `Display` を呼び出すことも可能です。Goが自動的にポインタをデリファレンス (`*pt2`) してメソッドに値を渡します。

## ポインタレシーバを使うべき場合

一般的に、以下のいずれかに該当する場合はポインタレシーバを使うことが推奨されます。

1.  **メソッドがレシーバの状態を変更する必要がある場合:**
    *   フィールドの値を変更したり、内部状態を更新したりするメソッド（例: `Set`, `Increment`, `Scale`, `Sort` など）。
2.  **レシーバが大きな構造体である場合:**
    *   メソッド呼び出しのたびに大きなデータのコピーが発生するのを避けるため。ポインタのコピーは非常に軽量です。
3.  **型のメソッドセットの一貫性:**
    *   同じ型に対して、一部のメソッドが値を変更する必要がある場合、他のメソッドも（たとえ値を変更しなくても）一貫性のためにポインタレシーバにすることが多いです。
4.  **`nil` レシーバを特別扱いしたい場合:**
    *   メソッド内でレシーバが `nil` かどうかをチェックして、`nil` の場合に特別な処理を行いたい場合（ただし、`nil` チェックは常に推奨されます）。

Goでは、**構造体に対するメソッドではポインタレシーバを使うことが一般的**です。特に理由がない限り、ポインタレシーバを第一候補として検討するのが良いでしょう。