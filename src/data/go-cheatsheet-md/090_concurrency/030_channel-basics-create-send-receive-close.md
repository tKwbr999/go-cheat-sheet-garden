---
title: "並行処理: チャネル (Channel) の基本"
tags: ["concurrency", "channel", "goroutine", "make", "<-", "close", "同期", "通信", "バッファ"]
---

Goroutine は並行処理を実行するためのものですが、多くの場合、Goroutine 同士で情報を交換したり、処理のタイミングを合わせたり（同期）する必要があります。そのための主要なメカニズムが**チャネル (Channel)** です。

## チャネルとは？

*   **型付きの通信路:** チャネルは、特定の型の値を Goroutine 間で安全に送受信するためのパイプのようなものです。`chan int` であれば `int` 型の値、`chan string` であれば `string` 型の値を送受信できます。
*   **同期メカニズム:** チャネルへの送信や受信操作は、デフォルトでは**ブロック**する可能性があります。これにより、Goroutine間の処理のタイミングを合わせる同期の役割も果たします。

## チャネルの作成: `make(chan 型, [容量])`

チャネルは組み込み関数の `make` を使って作成します。

*   **バッファなしチャネル (Unbuffered Channel):**
    `ch := make(chan T)`
    *   容量を指定しない場合、バッファなしチャネルが作成されます。
    *   送信操作 (`ch <- value`) は、別の Goroutine が同じチャネルから受信 (`<-ch`) の準備ができるまで**ブロック**します。
    *   受信操作 (`value := <-ch`) は、別の Goroutine が同じチャネルに送信 (`ch <- value`) するまで**ブロック**します。
    *   送信と受信が同時に行われることで、Goroutine間の**同期**が保証されます。

*   **バッファありチャネル (Buffered Channel):**
    `ch := make(chan T, capacity)`
    *   第二引数に `capacity` (正の整数) を指定すると、バッファありチャネルが作成されます。
    *   バッファは、指定された容量まで値を一時的に保持できるキューのようなものです。
    *   送信操作 (`ch <- value`) は、バッファが**満杯**になるまでブロックしません。バッファに空きがあれば、値をバッファに入れてすぐに次の処理に進みます。
    *   受信操作 (`value := <-ch`) は、バッファが**空**になるまでブロックしません。バッファに値があれば、それを取り出してすぐに次の処理に進みます。
    *   バッファがあることで、送受信のタイミングがある程度ずれていても、処理がブロックされにくくなります（非同期的な通信）。

## 送信と受信: `<-` 演算子

チャネルへの値の送信と受信には、矢印のような演算子 `<-` を使います。

*   **送信:** `チャネル変数 <- 値` (値がチャネルに「入る」イメージ)
*   **受信:** `変数 := <-チャネル変数` (値がチャネルから「出る」イメージ)
    *   受信操作は式としても使えます: `fmt.Println(<-ch)`
    *   受信した値を使わない場合は無視できます: `<-ch`

## チャネルのクローズ: `close()`

チャネルへの値の送信がすべて完了したことを示すために、組み込み関数の `close()` を使ってチャネルを**クローズ**します。

**構文:** `close(チャネル変数)`

*   **送信側がクローズする:** チャネルは、通常、**値を送信する側**が「もうこれ以上送信しない」ことを示すためにクローズします。受信側がクローズすべきではありません。
*   **クローズ後の送信はパニック:** クローズされたチャネルに対して値を**送信**しようとすると**パニック**が発生します。
*   **クローズ後の受信:** クローズされたチャネルから**受信**しようとすると、チャネル内のバッファにまだ値が残っていれば、その値が順番に返されます。バッファが空になった後は、そのチャネルの型の**ゼロ値**が即座に返されます。
*   **クローズ状態の確認:** 受信操作をカンマOKイディオム `value, ok := <-ch` で行うと、2番目の `bool` 値 `ok` でチャネルがクローズされているか（かつバッファが空か）を確認できます。
    *   チャネルが開いていて値を受信した場合: `value` は受信した値, `ok` は `true`。
    *   チャネルが**クローズ**されていてバッファが空の場合: `value` はゼロ値, `ok` は **`false`**。

## コード例

```go title="チャネルの基本操作"
package main

import (
	"fmt"
	"time"
)

func main() {
	// --- バッファなしチャネル ---
	fmt.Println("--- バッファなしチャネル ---")
	ch1 := make(chan string) // string 型のバッファなしチャネル

	go func() {
		fmt.Println("Goroutine 1: 'Hello' を送信します...")
		ch1 <- "Hello" // 送信 (受信側が準備できるまでブロックする可能性)
		fmt.Println("Goroutine 1: 送信完了")
		time.Sleep(50 * time.Millisecond) // 少し待機
		fmt.Println("Goroutine 1: 'World' を送信します...")
		ch1 <- "World"
		fmt.Println("Goroutine 1: 送信完了、チャネルをクローズします。")
		close(ch1) // ★ 送信側がクローズ
	}()

	fmt.Println("main: ch1 から受信します...")
	msg1 := <-ch1 // 受信 (送信されるまでブロックする可能性)
	fmt.Printf("main: 受信1: %s\n", msg1)
	msg2 := <-ch1 // 再度受信
	fmt.Printf("main: 受信2: %s\n", msg2)

	// クローズされたチャネルから受信を試みる
	msg3, ok := <-ch1
	if !ok {
		fmt.Printf("main: 受信3: チャネルはクローズされています。(値: %q, ok: %t)\n", msg3, ok)
	}
	// close(ch1) // クローズ済みのチャネルを再度クローズすると panic
	// ch1 <- "Bye" // クローズ済みのチャネルに送信すると panic

	// --- バッファありチャネル ---
	fmt.Println("\n--- バッファありチャネル ---")
	ch2 := make(chan int, 2) // 容量 2 の int 型チャネル

	// バッファに空きがあるのでブロックしない
	ch2 <- 1
	fmt.Println("main: ch2 に 1 を送信しました。")
	ch2 <- 2
	fmt.Println("main: ch2 に 2 を送信しました。")
	// ch2 <- 3 // バッファが満杯なので、ここで送信しようとするとブロックする (デッドロックの可能性)

	// バッファに値があるのでブロックしない
	val1 := <-ch2
	fmt.Printf("main: ch2 から受信1: %d\n", val1)
	val2 := <-ch2
	fmt.Printf("main: ch2 から受信2: %d\n", val2)
	// val3 := <-ch2 // バッファが空なので、ここで受信しようとするとブロックする (デッドロックの可能性)

	close(ch2) // 使い終わったらクローズ
}

/* 実行結果の例 (Goroutine のタイミングで多少前後する可能性あり):
--- バッファなしチャネル ---
main: ch1 から受信します...
Goroutine 1: 'Hello' を送信します...
Goroutine 1: 送信完了
main: 受信1: Hello
Goroutine 1: 'World' を送信します...
Goroutine 1: 送信完了、チャネルをクローズします。
main: 受信2: World
main: 受信3: チャネルはクローズされています。(値: "", ok: false)

--- バッファありチャネル ---
main: ch2 に 1 を送信しました。
main: ch2 に 2 を送信しました。
main: ch2 から受信1: 1
main: ch2 から受信2: 2
*/
```

チャネルは、Goroutine間の安全なデータ通信と同期を実現するためのGoの強力な機能です。バッファなしとバッファありの特性、そしてクローズの扱いを理解することが重要です。