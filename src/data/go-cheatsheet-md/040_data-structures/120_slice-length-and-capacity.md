---
title: "データ構造: スライス (Slice) の長さ (Length) と容量 (Capacity)"
tags: ["data-structures", "スライス", "slice", "長さ", "len", "容量", "cap", "内部配列", "append"]
---

スライスを理解する上で非常に重要な概念が**長さ (Length)** と**容量 (Capacity)** です。これらはスライスのサイズと、その背後にある内部配列との関係を示します。

## 長さ (Length) とは？

*   スライスに**現在含まれている要素の数**を表します。
*   組み込み関数の **`len(スライス)`** で取得できます。
*   スライスのインデックスアクセス (`s[i]`) は、`0` から `len(s) - 1` までの範囲で有効です。

## 容量 (Capacity) とは？

*   スライスが参照している**内部配列 (Underlying Array)** の中で、スライスの**開始位置から数えて利用可能な要素の総数**を表します。
*   組み込み関数の **`cap(スライス)`** で取得できます。
*   容量は、スライスに `append` で要素を追加する際に、内部配列を再確保（より大きな配列へのコピー）する必要があるかどうかを判断するために使われます。現在の長さが容量未満であれば、`append` は既存の内部配列を拡張して利用できます（効率が良い）。長さが容量に達している状態で `append` すると、通常はより大きな新しい内部配列が確保され、要素がコピーされます（コストがかかる）。

**イメージ:**

```
      +---+---+---+---+---+---+---+---+---+---+
内部配列: | A | B | C | D | E | F | G | H | I | J |  (容量 10)
      +---+---+---+---+---+---+---+---+---+---+
        ^           ^
        |           |
スライス s = array[1:4] |           |
        +-----------+           |
        | ポインタ  |           |
        +-----------+           |
        | 長さ = 3  |-----------+  (B, C, D の 3要素)
        +-----------+
        | 容量 = 9  |-----------------------------------+ (B から J までの 9要素分)
        +-----------+
```

*   このスライス `s` の長さ (`len(s)`) は 3 です（要素 B, C, D）。
*   容量 (`cap(s)`) は 9 です（内部配列の要素 B から J まで）。
*   `s[0]` は B、`s[1]` は C、`s[2]` は D にアクセスできます。`s[3]` にアクセスしようとするとパニックになります（長さが 3 なので）。
*   `s` に `append` で要素を追加する場合、容量が 9 あるため、内部配列の要素 E, F, G... の領域が使われます（新しい配列確保はすぐには起こらない）。

## コード例: 長さと容量の変化

スライス操作や `append` によって長さと容量がどのように変化するかを見てみましょう。

```go title="長さと容量の変化"
package main

import "fmt"

func printSliceInfo(name string, s []int) {
	fmt.Printf("%s: %v (len=%d, cap=%d)\n", name, s, len(s), cap(s))
}

func main() {
	// 元となるスライスを作成 (長さ 5, 容量 5)
	s0 := []int{0, 1, 2, 3, 4}
	printSliceInfo("s0", s0)

	fmt.Println("\n--- スライス操作 ---")
	// s1: s0 のインデックス 1 から 3 まで (要素 1, 2)
	s1 := s0[1:3]
	printSliceInfo("s1 = s0[1:3]", s1) // len=2, cap=4 (元のインデックス1から最後まで)

	// s2: s0 のインデックス 2 から最後まで (要素 2, 3, 4)
	s2 := s0[2:]
	printSliceInfo("s2 = s0[2:]", s2) // len=3, cap=3 (元のインデックス2から最後まで)

	// s3: s1 のインデックス 0 から 1 まで (要素 1)
	s3 := s1[:1]
	printSliceInfo("s3 = s1[:1]", s3) // len=1, cap=4 (s1 と同じ内部配列、同じ開始位置なので cap も同じ)

	fmt.Println("\n--- append による変化 ---")
	// s3 (len=1, cap=4) に要素を追加
	s3 = append(s3, 99)
	printSliceInfo("s3 (append 99)", s3) // len=2, cap=4 (容量内なので内部配列は同じはず)
	// 元の s0 や s1 も影響を受ける可能性がある！
	printSliceInfo("s0 (影響確認)", s0) // s0[2] が 99 に変わっている！
	printSliceInfo("s1 (影響確認)", s1) // s1[1] が 99 に変わっている！

	// さらに s3 に要素を追加 (容量を超えるまで)
	s3 = append(s3, 88, 77)
	printSliceInfo("s3 (append 88, 77)", s3) // len=4, cap=4
	printSliceInfo("s0 (影響確認)", s0)      // s0[3] も 77 に変わっている！

	// さらに s3 に要素を追加 (容量を超える)
	s3 = append(s3, 66)
	printSliceInfo("s3 (append 66)", s3) // len=5, cap=8 (新しい内部配列が確保された可能性が高い)
	printSliceInfo("s0 (影響確認)", s0)  // s0 はもう影響を受けない (s3 は別の配列を参照)

	// s2 (len=3, cap=3) に要素を追加 (容量を超える)
	s2 = append(s2, 55)
	printSliceInfo("s2 (append 55)", s2) // len=4, cap=6 (新しい内部配列)
	printSliceInfo("s0 (影響確認)", s0)  // s0 は影響を受けない
}

/* 実行結果 (容量の増加は環境/バージョンにより異なる可能性あり):
s0: [0 1 2 3 4] (len=5, cap=5)

--- スライス操作 ---
s1 = s0[1:3]: [1 2] (len=2, cap=4)
s2 = s0[2:]: [2 3 4] (len=3, cap=3)
s3 = s1[:1]: [1] (len=1, cap=4)

--- append による変化 ---
s3 (append 99): [1 99] (len=2, cap=4)
s0 (影響確認): [0 1 99 3 4]
s1 (影響確認): [1 99]
s3 (append 88, 77): [1 99 88 77] (len=4, cap=4)
s0 (影響確認): [0 1 99 77 4]
s3 (append 66): [1 99 88 77 66] (len=5, cap=8)
s0 (影響確認): [0 1 99 77 4]
s2 (append 55): [2 3 4 55] (len=4, cap=6)
s0 (影響確認): [0 1 99 77 4]
*/
```

**コード解説:**

*   スライス操作 `s0[1:3]` で `s1` を作ると、`s1` の長さは `3-1=2` ですが、容量は元の配列のインデックス 1 から最後までなので `5-1=4` となります。
*   `s3 = s1[:1]` で `s3` を作ると、長さは 1 ですが、容量は `s1` と同じ 4 です。
*   `s3 = append(s3, 99)`: `s3` の容量 (4) は長さ (1) より大きいので、内部配列の `s3` の次の要素の位置（元の `s0` のインデックス 2 に相当）に 99 が書き込まれます。この内部配列は `s0` や `s1` も共有しているため、`s0[2]` と `s1[1]` の値も 99 に変わります。
*   `s3 = append(s3, 66)`: `s3` の長さが容量 (4) に達した状態で `append` すると、通常はより大きな容量を持つ新しい内部配列が確保され、要素がコピーされます。そのため、この `append` 以降、`s3` は `s0` とは別の内部配列を参照するようになり、`s0` は影響を受けなくなります。
*   `s2 = append(s2, 55)`: `s2` は作成時点で長さと容量が同じ (3) だったため、`append` するとすぐに新しい内部配列が確保されます。

長さと容量の概念、そして `append` 時の挙動（特に内部配列の再確保）を理解することは、スライスを効率的かつ安全に使うために非常に重要です。