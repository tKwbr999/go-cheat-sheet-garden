---
title: "データ構造: 多次元配列 (Multi-dimensional Array)"
tags: ["data-structures", "配列", "array", "多次元配列", "2次元配列", "行列"]
---

Go言語では、配列の要素としてさらに配列を持つ、**多次元配列 (Multi-dimensional Array)** を作成することができます。最も一般的なのは、表や行列のようにデータを格子状に格納する**2次元配列**です。

## 2次元配列の宣言と初期化

2次元配列は「配列の配列」として考えます。

**宣言構文:** `var 変数名 [サイズ1][サイズ2]要素の型`

*   `[サイズ1]`: 外側の配列のサイズ（行数など）。
*   `[サイズ2]`: 内側の配列のサイズ（列数など）。
*   `要素の型`: 格納する要素の型。

**リテラルによる初期化構文:**
```go
変数名 := [サイズ1][サイズ2]要素の型{
	{値1_1, 値1_2, ...}, // 1行目の要素 (内側の配列リテラル)
	{値2_1, 値2_2, ...}, // 2行目の要素
	...
}
```

*   外側の中括弧 `{}` の中に、内側の配列（各行）を表す配列リテラルをカンマ `,` で区切って記述します。
*   内側の配列リテラルの要素数は `サイズ2` と一致させる必要があります。
*   外側の配列リテラルの要素数（行数）は `サイズ1` と一致させる必要があります。
*   サイズ指定に `...` を使うこともできますが、通常は明示的にサイズを指定します。

```go title="2次元配列の宣言と初期化"
package main

import "fmt"

func main() {
	// --- 宣言のみ (ゼロ値で初期化) ---
	// 2行3列の int 型 2次元配列 (すべての要素が 0 になる)
	var matrixA [2][3]int
	fmt.Println("matrixA (ゼロ値):", matrixA)

	// --- リテラルによる初期化 ---
	// 2行3列の int 型 2次元配列を初期化
	matrixB := [2][3]int{
		{1, 2, 3}, // 1行目 (インデックス 0)
		{4, 5, 6}, // 2行目 (インデックス 1)
	}
	fmt.Println("matrixB (初期化):", matrixB)

	// [...] を使うことも可能だが、多次元ではあまり使われない
	// matrixC := [...][3]int{ {1, 1, 1}, {2, 2, 2} } // サイズは [2][3]int と推論される

	// インデックス指定による初期化も可能
	matrixD := [3][2]string{
		1: {"A", "B"}, // インデックス 1 の行を初期化
		0: {"C", "D"}, // インデックス 0 の行を初期化
		// インデックス 2 の行はゼロ値 ["", ""] になる
	}
	fmt.Println("matrixD (インデックス指定):", matrixD)
}

/* 実行結果:
matrixA (ゼロ値): [[0 0 0] [0 0 0]]
matrixB (初期化): [[1 2 3] [4 5 6]]
matrixD (インデックス指定): [[C D] [A B] [ ]]
*/
```

## 要素へのアクセス

2次元配列の要素にアクセスするには、2つのインデックスを使います。

**構文:** `変数名[行インデックス][列インデックス]`

*   `行インデックス`: 外側の配列のインデックス (0 から `サイズ1 - 1` まで)。
*   `列インデックス`: 内側の配列のインデックス (0 から `サイズ2 - 1` まで)。

```go title="2次元配列の要素アクセス"
package main

import "fmt"

func main() {
	matrix := [2][3]int{
		{10, 20, 30}, // 行インデックス 0
		{40, 50, 60}, // 行インデックス 1
	}
	// 列インデックス: 0,  1,  2

	// --- 要素の読み取り ---
	// 1行目 (インデックス 0), 2列目 (インデックス 1) の要素
	val1 := matrix[0][1] // 20
	fmt.Printf("matrix[0][1] = %d\n", val1)

	// 2行目 (インデックス 1), 3列目 (インデックス 2) の要素
	val2 := matrix[1][2] // 60
	fmt.Printf("matrix[1][2] = %d\n", val2)

	// --- 要素への書き込み (代入) ---
	fmt.Println("変更前:", matrix)
	matrix[0][0] = 11 // 1行目, 1列目を 11 に変更
	matrix[1][1] = 55 // 2行目, 2列目を 55 に変更
	fmt.Println("変更後:", matrix)

	// --- ネストしたループによる全要素アクセス ---
	fmt.Println("--- 全要素アクセス ---")
	// len(matrix) は行数 (2)
	for i := 0; i < len(matrix); i++ {
		// len(matrix[i]) は列数 (3)
		for j := 0; j < len(matrix[i]); j++ {
			fmt.Printf("matrix[%d][%d] = %d\n", i, j, matrix[i][j])
		}
	}

	// 範囲外アクセスは panic を引き起こす
	// fmt.Println(matrix[2][0]) // panic: runtime error: index out of range [2] with length 2
	// fmt.Println(matrix[0][3]) // panic: runtime error: index out of range [3] with length 3
}

/* 実行結果:
matrix[0][1] = 20
matrix[1][2] = 60
変更前: [[10 20 30] [40 50 60]]
変更後: [[11 20 30] [40 55 60]]
--- 全要素アクセス ---
matrix[0][0] = 11
matrix[0][1] = 20
matrix[0][2] = 30
matrix[1][0] = 40
matrix[1][1] = 55
matrix[1][2] = 60
*/
```

多次元配列は、表形式のデータやゲームの盤面などを表現するのに使えます。ただし、配列と同様にサイズが固定であるため、行数や列数が可変の場合は、多次元スライス（スライスのスライス）を使うことが一般的です。