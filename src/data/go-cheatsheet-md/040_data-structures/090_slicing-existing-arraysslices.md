---
title: "データ構造: スライス操作 (Slicing) - 配列やスライスから作る"
tags: ["data-structures", "スライス", "slice", "配列", "array", "スライス操作", "参照", "共有"]
---

スライスを作成するもう一つの重要な方法は、既存の**配列**や**他のスライス**の一部（または全部）を指す新しいスライスを作成することです。これを**スライス操作 (Slicing)** と呼びます。

## スライス操作の構文: `[low:high]`

配列 `a` またはスライス `s` に対して、`a[low:high]` や `s[low:high]` のように記述します。

*   `low`: スライスが始まる要素のインデックス（このインデックスの要素は**含まれる**）。省略すると `0` になります (`[:high]`)。
*   `high`: スライスが終わる要素のインデックス（このインデックスの要素は**含まれない**）。省略すると元の配列/スライスの最後までになります (`[low:]`)。

この操作によって生成される新しいスライスは、以下のようになります。

*   **参照:** 元の配列/スライスの `low` 番目の要素を指すポインタを持つ。
*   **長さ (Length):** `high - low`。
*   **容量 (Capacity):** 元の配列/スライスの `low` 番目の要素から数えて、元の配列/スライスの末尾までの要素数。

**重要なポイント:** スライス操作で作成された新しいスライスは、元の配列（または元のスライスの内部配列）の**メモリ領域を共有**します。そのため、新しいスライスを通じて要素を変更すると、**元の配列や、同じ内部配列を参照している他のスライスの要素も変更されます**。これは配列のコピーとは異なる挙動です。

```go title="配列やスライスからのスライス操作"
package main

import "fmt"

func main() {
	// --- 元となる配列 ---
	primes := [6]int{2, 3, 5, 7, 11, 13}
	fmt.Printf("元の配列 primes: %v\n", primes)

	// --- 配列からスライスを作成 ---
	// インデックス 1 から 4-1=3 まで (要素は 3, 5, 7)
	var s1 []int = primes[1:4]
	fmt.Printf("s1 = primes[1:4]: %v (len=%d, cap=%d)\n", s1, len(s1), cap(s1))
	// 長さ = 4 - 1 = 3
	// 容量 = 元の配列のインデックス 1 から最後まで = 6 - 1 = 5

	// インデックス 0 から 3-1=2 まで (要素は 2, 3, 5)
	s2 := primes[:3] // low を省略
	fmt.Printf("s2 = primes[:3]:  %v (len=%d, cap=%d)\n", s2, len(s2), cap(s2))
	// 長さ = 3 - 0 = 3
	// 容量 = 元の配列のインデックス 0 から最後まで = 6 - 0 = 6

	// インデックス 2 から最後まで (要素は 5, 7, 11, 13)
	s3 := primes[2:] // high を省略
	fmt.Printf("s3 = primes[2:]:  %v (len=%d, cap=%d)\n", s3, len(s3), cap(s3))
	// 長さ = 6 - 2 = 4
	// 容量 = 元の配列のインデックス 2 から最後まで = 6 - 2 = 4

	// --- スライスからさらにスライスを作成 ---
	fmt.Printf("\n元のスライス s1: %v\n", s1) // [3 5 7]
	// s1 のインデックス 0 から 2-1=1 まで (要素は 3, 5)
	s4 := s1[:2]
	fmt.Printf("s4 = s1[:2]: %v (len=%d, cap=%d)\n", s4, len(s4), cap(s4))
	// 長さ = 2 - 0 = 2
	// 容量 = s1 の内部配列の開始位置から最後まで = 5 (s1 の容量と同じ)

	// s1 のインデックス 1 から最後まで (要素は 5, 7)
	s5 := s1[1:]
	fmt.Printf("s5 = s1[1:]: %v (len=%d, cap=%d)\n", s5, len(s5), cap(s5))
	// 長さ = 3 - 1 = 2
	// 容量 = s1 の内部配列のインデックス 1 から最後まで = 5 - 1 = 4

	// --- 内部配列の共有と変更の影響 ---
	fmt.Println("\n--- 内部配列の共有 ---")
	fmt.Printf("変更前: s4=%v, s5=%v, primes=%v\n", s4, s5, primes)

	// s4 (s1[:2]) の要素を変更する
	s4[1] = 99 // s4[1] は元の配列 primes のインデックス 2 に対応

	fmt.Printf("s4変更後: s4=%v, s5=%v, primes=%v\n", s4, s5, primes)
	// s4[1] を変更した結果、s5[0] (同じ内部配列の同じ場所を指す) と
	// 元の配列 primes[2] の値も変わっている！

	// s5 を変更しても同様
	s5[1] = 111 // s5[1] は元の配列 primes のインデックス 3 に対応
	fmt.Printf("s5変更後: s4=%v, s5=%v, primes=%v\n", s4, s5, primes)
}

/* 実行結果:
元の配列 primes: [2 3 5 7 11 13]
s1 = primes[1:4]: [3 5 7] (len=3, cap=5)
s2 = primes[:3]:  [2 3 5] (len=3, cap=6)
s3 = primes[2:]:  [5 7 11 13] (len=4, cap=4)

元のスライス s1: [3 5 7]
s4 = s1[:2]: [3 5] (len=2, cap=5)
s5 = s1[1:]: [5 7] (len=2, cap=4)

--- 内部配列の共有 ---
変更前: s4=[3 5], s5=[5 7], primes=[2 3 5 7 11 13]
s4変更後: s4=[3 99], s5=[99 7], primes=[2 3 99 7 11 13]
s5変更後: s4=[3 99], s5=[99 111], primes=[2 3 99 111 111 13]
*/
```

**コード解説:**

*   `primes[1:4]` は、`primes` 配列のインデックス1, 2, 3 の要素 (`3, 5, 7`) を含む新しいスライス `s1` を作成します。`s1` の長さは 3 です。容量は、`primes` 配列のインデックス 1 から最後までなので 5 です。
*   `s1[:2]` は、スライス `s1` からさらにスライス `s4` を作成します。`s4` は `s1` の最初の 2 要素 (`3, 5`) を含みます。`s4` の長さは 2 です。容量は `s1` と同じ内部配列を参照しているため、`s1` の容量と同じ 5 になります。
*   `s4[1] = 99` で `s4` の要素を変更すると、`s4` が参照している内部配列（元は `primes` 配列）の該当箇所が変更されます。そのため、同じ内部配列の同じ部分を参照している `s5` や、元の `primes` 配列の値も影響を受けて変わります。

スライス操作は、配列や既存のスライスの一部を効率的に参照するための強力な機能ですが、内部配列を共有するという特性を理解しておくことが非常に重要です。意図しない副作用を防ぐためには、スライスがどの内部配列をどの範囲で参照しているかを意識する必要があります。