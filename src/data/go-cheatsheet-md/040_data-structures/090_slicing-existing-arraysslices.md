## タイトル
title: スライス操作 (Slicing) - 配列やスライスから作る

## タグ
tags: ["data-structures", "スライス", "slice", "配列", "array", "スライス操作", "参照", "共有"]

## コード
```go
package main

import "fmt"

func main() {
	primes := [6]int{2, 3, 5, 7, 11, 13}
	fmt.Printf("元の配列: %v\n", primes)

	// 配列からスライスを作成: primes[1:4]
	// インデックス 1 から 4-1=3 まで (要素 3, 5, 7)
	s1 := primes[1:4]
	fmt.Printf("s1 = primes[1:4]: %v (len=%d, cap=%d)\n", s1, len(s1), cap(s1))

	// s1 からさらにスライスを作成: s1[:2]
	// s1 のインデックス 0 から 2-1=1 まで (要素 3, 5)
	s4 := s1[:2]
	fmt.Printf("s4 = s1[:2]: %v (len=%d, cap=%d)\n", s4, len(s4), cap(s4))

	// 内部配列の共有と変更の影響
	fmt.Printf("変更前: s4=%v, primes=%v\n", s4, primes)
	s4[1] = 99 // s4[1] は primes[2] と同じ場所を指す
	fmt.Printf("変更後: s4=%v, primes=%v\n", s4, primes) // primes も変更される!
}

```

## 解説
```text
既存の**配列**や**他のスライス**の一部（または全部）を
指す新しいスライスを作成することを
**スライス操作 (Slicing)** と呼びます。

**構文: `[low:high]`**
配列 `a` やスライス `s` に対し `a[low:high]` や
`s[low:high]` と書きます。
*   `low`: 開始インデックス (含まれる)。省略可 (`[:high]`)。
*   `high`: 終了インデックス (含まれない)。省略可 (`[low:]`)。

**生成されるスライス:**
*   **参照:** 元の配列/スライスの `low` 番目の要素を指す。
*   **長さ:** `high - low`。
*   **容量:** 元の配列/スライスの `low` 番目から末尾までの要素数。

コード例 `s1 := primes[1:4]` では、`primes` のインデックス 1, 2, 3
(値 3, 5, 7) を含むスライス `s1` ができます。
長さは `4-1=3`、容量は `primes` のインデックス 1 から最後までなので
`6-1=5` となります。

**重要: 内部配列の共有**
スライス操作で作られた新しいスライスは、元の配列
（または元のスライスの内部配列）の**メモリ領域を共有**します。
そのため、新しいスライスを通じて要素を変更すると
(例: `s4[1] = 99`)、**元の配列や、同じ内部配列を
参照する他のスライスの要素も変更されます**。
これは配列のコピー (`copied := original`) とは異なる挙動です。

スライス操作は効率的ですが、内部配列共有による
意図しない副作用に注意が必要です。