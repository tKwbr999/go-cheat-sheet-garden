---
title: "データ構造: スライス (Slice) の宣言"
tags: ["data-structures", "スライス", "slice", "可変長", "参照型", "nil"]
---

Go言語で配列 (`array`) と並んで、あるいはそれ以上に頻繁に使われる重要なデータ構造が**スライス (Slice)** です。スライスは、配列と似ていますが、より柔軟で強力な機能を提供します。

## スライス (Slice) とは？

スライスは、**配列 (Array)** の一部または全体に対する**ビュー（参照のようなもの）**を提供します。スライス自体は配列の要素データを直接持っているわけではなく、内部的には以下の3つの情報を持っています。

1.  **ポインタ (Pointer):** 参照している内部配列（Underlying Array）の特定の要素へのポインタ。
2.  **長さ (Length):** スライスに含まれる要素の数。`len()` 関数で取得できます。
3.  **容量 (Capacity):** スライスが参照している内部配列の、ポインタが指す要素から数えて利用可能な要素の数。`cap()` 関数で取得できます。

```
      +---------+---------+---------+---------+---------+
配列: | 要素 0  | 要素 1  | 要素 2  | 要素 3  | 要素 4  |
      +---------+---------+---------+---------+---------+
        ^                   ^
        |                   |
スライス s (s = array[1:4]) |                   |
        +-------------------+                   |
        | ポインタ (要素1へ) |                   |
        +-------------------+                   |
        | 長さ = 3          |                   |
        +-------------------+                   |
        | 容量 = 4          |-------------------+
        +-------------------+
```

## 配列との主な違い

*   **可変長:** スライスは、後から要素を追加していくと、必要に応じて内部配列が自動的に拡張されるため、**可変長**のシーケンスとして扱うことができます（`append` 関数を使用）。配列は固定長です。
*   **参照型のような振る舞い:** スライスを別の変数に代入したり、関数に渡したりする際、配列のように全要素がコピーされるのではなく、内部配列へのポインタや長さ、容量の情報がコピーされます（参照渡しに近い）。そのため、コピー先のスライスを通じて元の内部配列の要素を変更すると、コピー元のスライスからもその変更が見えます。

これらの特性により、Goでは固定長の配列よりもスライスの方が一般的に使われます。

## スライスの宣言

スライスを宣言するには、`var` キーワードと以下の構文を使います。配列と似ていますが、**サイズを指定しません**。

**構文:** `var 変数名 []要素の型`

*   `変数名`: スライスを識別するための名前。
*   `[]`: サイズを指定しないことで、これが配列ではなくスライスであることを示します。
*   `要素の型`: スライスが参照する要素の型。

`var` で宣言しただけで初期値を指定しない場合、スライスの**ゼロ値**は **`nil`** になります。`nil` スライスは、長さ (length) も容量 (capacity) も `0` であり、内部配列も参照していません。

```go title="スライスの宣言とゼロ値 (nil)"
package main

import "fmt"

func main() {
	// --- スライスの宣言 ---
	// int 型の要素を持つスライスを宣言 (初期値なし)
	var numbers []int

	// string 型の要素を持つスライスを宣言
	var names []string

	// --- ゼロ値 (nil) の確認 ---
	fmt.Printf("numbers: %v (型: %T)\n", numbers, numbers)
	fmt.Printf("names:   %q (型: %T)\n", names, names) // %q で表示

	// nil スライスかどうかをチェック
	if numbers == nil {
		fmt.Println("numbers は nil スライスです。")
	}

	// nil スライスの長さと容量は 0
	fmt.Printf("numbers の長さ (len): %d\n", len(numbers))
	fmt.Printf("numbers の容量 (cap): %d\n", cap(numbers))

	// nil スライスに対して append は可能 (新しい内部配列が確保される)
	numbers = append(numbers, 10)
	fmt.Printf("append 後の numbers: %v (len=%d, cap=%d)\n", numbers, len(numbers), cap(numbers))
}

/* 実行結果:
numbers: [] (型: []int)
names:   [] (型: []string)
numbers は nil スライスです。
numbers の長さ (len): 0
numbers の容量 (cap): 0
append 後の numbers: [10] (len=1, cap=1)
*/
```

**コード解説:**

*   `var numbers []int`: サイズを指定せずに `[]int` と書くことで、`int` 型のスライス `numbers` を宣言しています。
*   初期値を指定していないため、`numbers` と `names` は `nil` で初期化されます。`fmt.Printf` で `%v` を使うと `[]` と表示されますが、`== nil` で比較すると `true` になります。
*   `len(numbers)` と `cap(numbers)` はどちらも `0` を返します。
*   `nil` スライスに対して `append` 関数を使うと、Goが自動的に新しい内部配列を確保し、要素を追加してくれます。

スライスは非常に強力で柔軟なデータ構造です。次のセクションでは、`make` 関数やリテラルを使ってスライスを初期化する方法を見ていきます。