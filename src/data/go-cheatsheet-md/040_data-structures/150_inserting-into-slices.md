## タイトル
title: スライス (Slice) への要素の挿入

## タグ
tags: ["data-structures", "スライス", "slice", "挿入", "append", "copy", "スライス操作"]

## コード
```go
package main

import "fmt"

func main() {
	s := []int{10, 20, 40, 50}
	fmt.Printf("元: %v (len=%d)\n", s, len(s))

	i := 2 // 挿入位置インデックス
	x := 30 // 挿入する要素

	// 方法1: append を2回使うイディオム
	// s[:i] に、 {x} と s[i:] を連結したものを append する
	s = append(s[:i], append([]int{x}, s[i:]...)...)

	fmt.Printf("挿入後: %v (len=%d)\n", s, len(s))
}

```

## 解説
```text
スライスの特定インデックス（途中）に要素を**挿入**する
専用の組み込み関数はありませんが、`append` や `copy` を
組み合わせて実現できます。

**方法1: `append` を2回使う (コード例)**
スライス `s` のインデックス `i` に要素 `x` を挿入する
一般的なイディオムです。
`s = append(s[:i], append([]T{x}, s[i:]...)...)`

1. `s[i:]`: 挿入位置 `i` 以降の部分スライス。
2. `[]T{x}`: 挿入する要素 `x` のみを持つスライス。
3. `append([]T{x}, s[i:]...)`: `x` の後に `i` 以降の要素が続く
   新しいスライスを作成。
4. `append(s[:i], ...)`: `i` より前の部分 (`s[:i]`) に、
   ステップ3で作ったスライスを展開 (`...`) して追加。

この方法は一行で書けますが、内部で複数回の `append` が
行われ、メモリ再確保が複数回発生する可能性があります。
結果は元のスライス変数 `s` に再代入します。

**方法2: `append` で拡張し `copy` でずらす**
より効率が良いとされる方法です。
1. `s = append(s, zeroValue)`: 末尾にダミー要素を追加し
   長さを1増やし、必要なら容量を拡張。
2. `copy(s[i+1:], s[i:])`: 挿入位置 `i` 以降の要素を
   一つ後ろにコピーしてずらす。
3. `s[i] = x`: 空いた位置 `i` に新しい要素 `x` を書き込む。

方法2はメモリ確保が最大1回で済む可能性がありますが、
コードは少し長くなります。

どちらの方法でも、挿入は末尾追加より複雑な操作が必要です。