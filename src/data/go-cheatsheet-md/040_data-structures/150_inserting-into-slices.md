---
title: "データ構造: スライス (Slice) への要素の挿入"
tags: ["data-structures", "スライス", "slice", "挿入", "append", "copy", "スライス操作"]
---

スライスの末尾に要素を追加するのは `append` で簡単に行えますが、**特定のインデックス**（途中）に要素を**挿入**するための専用の組み込み関数はGoにはありません。しかし、既存の `append` や `copy` 関数、スライス操作を組み合わせることで実現できます。

## 方法1: `append` を2回使う

スライス `s` のインデックス `i` の位置に要素 `x` を挿入する一般的な方法は以下の通りです。

`s = append(s[:i], append([]T{x}, s[i:]...)...)` (ここで `T` は要素の型)

これは少し複雑に見えますが、以下のステップで行われています。

1.  `s[i:]`: 挿入位置 `i` から元のスライスの最後までを取得します。
2.  `[]T{x}`: 挿入したい要素 `x` だけを持つ、長さ1の新しいスライスを作成します。
3.  `append([]T{x}, s[i:]...)`: ステップ2のスライスに、ステップ1のスライス（`i` 以降の要素）を展開 (`...`) して追加します。これにより、`x` の後に元の `i` 以降の要素が続く新しいスライスができます。
4.  `append(s[:i], ...)`: 元のスライスの `i` より前の部分 (`s[:i]`) に、ステップ3で作成したスライスを展開 (`...`) して追加します。

この方法は少し冗長に見えるかもしれませんが、一行で書けるという利点があります。ただし、内部的に複数回の `append` が行われ、場合によっては複数回のメモリ再確保が発生する可能性があります。

```go title="方法1: append を2回使って挿入"
package main

import "fmt"

func printSliceInfo(name string, s []int) {
	fmt.Printf("%s: %v (len=%d, cap=%d)\n", name, s, len(s), cap(s))
}

func main() {
	s := []int{10, 20, 40, 50} // [10, 20, 40, 50]
	printSliceInfo("元のスライス", s)

	i := 2 // 挿入したいインデックス (現在の "40" の前)
	x := 30 // 挿入したい要素

	fmt.Printf("\nインデックス %d に要素 %d を挿入します (方法1)...\n", i, x)

	// s[:i] は [10, 20]
	// s[i:] は [40, 50]
	// []int{x} は [30]
	// append([]int{x}, s[i:]...) は append([30], 40, 50) -> [30, 40, 50]
	// append(s[:i], [30, 40, 50]...) は append([10, 20], 30, 40, 50) -> [10, 20, 30, 40, 50]
	s = append(s[:i], append([]int{x}, s[i:]...)...)

	printSliceInfo("挿入後のスライス", s)
}

/* 実行結果 (容量は環境/バージョンにより異なる可能性あり):
元のスライス: [10 20 40 50] (len=4, cap=4)

インデックス 2 に要素 30 を挿入します (方法1)...
挿入後のスライス: [10 20 30 40 50] (len=5, cap=8)
*/
```

## 方法2: `append` で拡張し `copy` でずらす

より効率が良いとされる方法は、まず `append` でスライスの末尾にダミーの要素（通常はゼロ値）を追加してスライスの長さを1増やし（必要なら容量も拡張させ）、次に `copy` 関数を使って挿入位置以降の要素を一つ後ろにずらし、最後に目的の位置に新しい要素を書き込む方法です。

```go title="方法2: append + copy で挿入"
package main

import "fmt"

func printSliceInfo(name string, s []string) {
	fmt.Printf("%s: %q (len=%d, cap=%d)\n", name, s, len(s), cap(s))
}

func main() {
	s := []string{"Apple", "Cherry", "Date"} // ["Apple", "Cherry", "Date"]
	printSliceInfo("元のスライス", s)

	i := 1 // 挿入したいインデックス (現在の "Cherry" の前)
	x := "Banana" // 挿入したい要素

	fmt.Printf("\nインデックス %d に要素 \"%s\" を挿入します (方法2)...\n", i, x)

	// 1. 末尾にゼロ値を追加してスライスを拡張 (必要なら容量も増える)
	s = append(s, "") // string のゼロ値 "" を追加
	printSliceInfo("append 後", s) // 長さが 1 増える

	// 2. 挿入位置 i 以降の要素を、i+1 以降の位置にコピーしてずらす
	// copy(コピー先, コピー元)
	// コピー先: s[i+1:] (インデックス i+1 から最後まで)
	// コピー元: s[i:]   (インデックス i から最後まで、ただし長さは拡張前のもの)
	copy(s[i+1:], s[i:])
	printSliceInfo("copy 後", s) // ["Apple", "Cherry", "Cherry", "Date"] のようになる

	// 3. 挿入位置 i に新しい要素を書き込む
	s[i] = x
	printSliceInfo("挿入完了後", s)
}

/* 実行結果 (容量は環境/バージョンにより異なる可能性あり):
元のスライス: ["Apple" "Cherry" "Date"] (len=3, cap=3)

インデックス 1 に要素 "Banana" を挿入します (方法2)...
append 後: ["Apple" "Cherry" "Date" ""] (len=4, cap=6)
copy 後: ["Apple" "Cherry" "Cherry" "Date"] (len=4, cap=6)
挿入完了後: ["Apple" "Banana" "Cherry" "Date"] (len=4, cap=6)
*/
```

**コード解説 (方法2):**

1.  `s = append(s, "")`: スライスの末尾にダミーの要素（ここでは空文字列）を追加します。これにより、スライスの長さが1増え、挿入に必要なスペースが確保されます（必要であれば容量も拡張されます）。
2.  `copy(s[i+1:], s[i:])`: `s[i:]`（元のインデックス `i` から最後までの要素）を、`s[i+1:]`（インデックス `i+1` から始まる位置）にコピーします。これにより、`s[i]` にあった要素が `s[i+1]` に、`s[i+1]` にあった要素が `s[i+2]` に、というように一つずつ後ろにずれます。
3.  `s[i] = x`: 要素がずれて空いたインデックス `i` の位置に、挿入したい要素 `x` を代入します。

方法2は、メモリ確保が最大でも1回で済む可能性があるため、一般的に方法1よりも効率が良いとされています。ただし、コードは少し長くなります。

どちらの方法を使うにしても、スライスへの挿入は `append` による末尾追加よりも少し複雑な操作が必要になります。