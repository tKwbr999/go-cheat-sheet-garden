---
title: "データ構造: `make` 関数によるスライス (Slice) の作成"
tags: ["data-structures", "スライス", "slice", "make", "長さ", "容量", "ゼロ値"]
---

`var s []int` のように宣言されたスライスは `nil` であり、内部配列を持ちません。要素を格納するためには、内部配列を確保し、スライスを初期化する必要があります。そのための主要な方法の一つが、組み込み関数の **`make`** を使うことです。

`make` 関数は、スライス、マップ、チャネルの3つの型に対して、メモリを確保し、初期化された値を返すために使われます。

## `make` によるスライスの作成

`make` を使ってスライスを作成するには、主に2つの形式があります。

**1. 長さのみを指定:** `make([]要素の型, 長さ)`

*   指定された `長さ` を持つスライスを作成します。
*   同時に、その長さと同じだけの**容量 (Capacity)** を持つ内部配列が確保されます。
*   スライスの各要素は、**要素の型のゼロ値**で初期化されます。

**2. 長さと容量を指定:** `make([]要素の型, 長さ, 容量)`

*   指定された `長さ` と `容量` を持つスライスを作成します。
*   `容量` は `長さ` 以上の値でなければなりません。
*   指定された `容量` を持つ内部配列が確保されます。
*   スライスの最初の `長さ` 個の要素が、**要素の型のゼロ値**で初期化されます。残りの部分（容量 - 長さ）は確保されていますが、スライスからは直接アクセスできません（`append` などで利用されます）。

```go title="make を使ったスライスの作成"
package main

import "fmt"

func main() {
	// --- 長さのみを指定 ---
	// 長さ 5、容量 5 の int スライスを作成
	// 要素はすべてゼロ値 (0) で初期化される
	s1 := make([]int, 5)
	fmt.Printf("s1 = %v (len=%d, cap=%d)\n", s1, len(s1), cap(s1))
	// s1 は nil ではない
	if s1 == nil {
		fmt.Println("s1 は nil です")
	} else {
		fmt.Println("s1 は nil ではありません")
	}
	// 要素にアクセスしたり代入したりできる
	s1[0] = 10
	s1[4] = 50
	fmt.Printf("s1 (変更後) = %v\n", s1)

	fmt.Println() // 空行

	// --- 長さと容量を指定 ---
	// 長さ 3、容量 10 の string スライスを作成
	// 最初の 3 要素はゼロ値 ("") で初期化される
	// 内部配列としては 10 要素分のメモリが確保されている
	s2 := make([]string, 3, 10)
	fmt.Printf("s2 = %q (len=%d, cap=%d)\n", s2, len(s2), cap(s2))
	s2[0] = "Go"
	s2[1] = "is"
	s2[2] = "fun"
	// s2[3] = "!" // エラー: index out of range [3] with length 3 (長さは3なのでインデックス3にはアクセスできない)
	fmt.Printf("s2 (変更後) = %q\n", s2)

	// append で要素を追加すると、容量の範囲内であれば内部配列が再利用される
	s2 = append(s2, "!")
	fmt.Printf("s2 (append後) = %q (len=%d, cap=%d)\n", s2, len(s2), cap(s2)) // 長さが 4 に増えるが、容量は 10 のまま

	fmt.Println() // 空行

	// --- 長さ 0 のスライス ---
	// 長さ 0、容量 5 のスライス
	// 要素はないが、append で効率的に要素を追加できる準備ができている
	s3 := make([]int, 0, 5)
	fmt.Printf("s3 = %v (len=%d, cap=%d)\n", s3, len(s3), cap(s3))
	s3 = append(s3, 1, 2, 3)
	fmt.Printf("s3 (append後) = %v (len=%d, cap=%d)\n", s3, len(s3), cap(s3))
}

/* 実行結果:
s1 = [0 0 0 0 0] (len=5, cap=5)
s1 は nil ではありません
s1 (変更後) = [10 0 0 0 50]

s2 = ["" "" ""] (len=3, cap=10)
s2 (変更後) = ["Go" "is" "fun"]
s2 (append後) = ["Go" "is" "fun" "!"] (len=4, cap=10)

s3 = [] (len=0, cap=5)
s3 (append後) = [1 2 3] (len=3, cap=5)
*/
```

**コード解説:**

*   `s1 := make([]int, 5)`: 長さ5、容量5の `int` スライス `s1` を作成します。`s1` は `[0 0 0 0 0]` で初期化されます。
*   `s2 := make([]string, 3, 10)`: 長さ3、容量10の `string` スライス `s2` を作成します。`s2` は `["" "" ""]` で初期化されます。`len(s2)` は 3 ですが、`cap(s2)` は 10 です。
*   `s2[3] = "!"` はエラーになります。スライスのインデックスアクセスは**長さ (length)** に基づいて行われ、容量 (capacity) ではありません。
*   `s2 = append(s2, "!")`: `s2` に要素を追加します。`s2` にはまだ容量の空きがあるため、内部配列が再利用され、長さだけが 4 に増えます。
*   `s3 := make([]int, 0, 5)`: 長さ0、容量5のスライスを作成します。これは、後で要素を追加する予定がある場合に、初期のメモリ確保を効率化するためによく使われます。

`make` は、必要なサイズ（およびオプションで容量）を指定してスライスを初期化するための基本的な方法です。次のセクションでは、リテラルを使ってスライスを初期化する方法を見ていきます。