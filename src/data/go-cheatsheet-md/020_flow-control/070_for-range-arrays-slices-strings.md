---
title: "制御構文: `for range` ループ (配列, スライス, 文字列)"
tags: ["flow-control", "for", "for range", "ループ", "繰り返し", "配列", "スライス", "文字列", "rune"]
---

Goの `for` 文には、配列、スライス、文字列、マップ、チャネルといった**コレクション**の要素を順番に取り出して処理するための特別な形式、**`for range`** ループがあります。これは非常に便利で、Goで頻繁に使われるループの書き方です。

ここでは、配列、スライス、文字列に対する `for range` の使い方を見ていきます。

## `for range` の基本構文 (配列, スライス, 文字列)

配列、スライス、文字列に対して `for range` を使うと、各反復で**インデックス**とその位置にある**要素の値**のペアが返されます。

**構文:** `for インデックス変数, 値変数 := range コレクション { ... ループ本体 ... }`

*   `インデックス変数`: 各要素のインデックス（位置、0から始まる整数）が代入されます。
*   `値変数`: 各要素の値そのものが代入されます。
*   `コレクション`: 反復処理の対象となる配列、スライス、または文字列。

## 配列 (Array) と スライス (Slice) での `for range`

配列やスライスの場合、`for range` は 0 番目の要素から順番に、インデックスと要素の値を返します。

```go title="配列とスライスでの for range"
package main

import "fmt"

func main() {
	// 配列の例
	primes := [4]int{2, 3, 5, 7} // 固定長配列
	fmt.Println("--- 配列の for range ---")
	for index, value := range primes {
		fmt.Printf("インデックス %d: 値 %d\n", index, value)
	}

	// スライスの例
	fruits := []string{"apple", "banana", "cherry"} // スライス
	fmt.Println("\n--- スライスの for range ---")
	for i, fruit := range fruits {
		fmt.Printf("インデックス %d: 値 \"%s\"\n", i, fruit)
	}

	// 値だけが必要な場合 (インデックスを _ で無視)
	fmt.Println("\n--- 値だけを使う場合 ---")
	sum := 0
	nums := []int{10, 20, 30}
	for _, num := range nums { // インデックスは使わないので _ で受ける
		sum += num
	}
	fmt.Printf("合計: %d\n", sum)

	// インデックスだけが必要な場合 (値を _ で無視)
	fmt.Println("\n--- インデックスだけを使う場合 ---")
	for i := range fruits { // 値を受け取る変数を省略すると、インデックスのみが返される
		fmt.Printf("インデックス %d\n", i)
	}
}

/* 実行結果:
--- 配列の for range ---
インデックス 0: 値 2
インデックス 1: 値 3
インデックス 2: 値 5
インデックス 3: 値 7

--- スライスの for range ---
インデックス 0: 値 "apple"
インデックス 1: 値 "banana"
インデックス 2: 値 "cherry"

--- 値だけを使う場合 ---
合計: 60

--- インデックスだけを使う場合 ---
インデックス 0
インデックス 1
インデックス 2
*/
```

**ポイント:**

*   ループ変数の名前 (`index`, `value`, `i`, `fruit` など）は自由に付けられます。
*   インデックスまたは値のどちらか一方が不要な場合は、ブランク識別子 `_` を使って無視できます。
*   値を受け取る変数を完全に省略すると、インデックスのみが返されます (`for i := range fruits`)。

## 文字列 (String) での `for range`

文字列に対して `for range` を使うと、バイト単位ではなく**文字 (Rune) 単位**で反復処理が行われます。これは日本語などのマルチバイト文字を正しく扱う上で非常に重要です。

*   1番目のループ変数 (`i`) には、その文字 (Rune) が始まる**バイトインデックス**が入ります。
*   2番目のループ変数 (`r`) には、その文字の **Rune (Unicodeコードポイント、`int32`)** が入ります。

```go title="文字列での for range (Rune 単位)"
package main

import "fmt"

func main() {
	s := "Hi 世界" // "H", "i", " ", "世", "界" の5文字

	fmt.Printf("文字列: \"%s\"\n", s)
	fmt.Println("--- 文字列の for range ---")

	// i は Rune の開始バイトインデックス, r は Rune (int32)
	for i, r := range s {
		fmt.Printf("バイトインデックス %d: 文字 '%c' (Unicode: %U)\n", i, r, r)
	}
	// "世" はバイトインデックス 3 から始まる
	// "界" はバイトインデックス 6 から始まる
}

/* 実行結果:
文字列: "Hi 世界"
--- 文字列の for range ---
バイトインデックス 0: 文字 'H' (Unicode: U+0048)
バイトインデックス 1: 文字 'i' (Unicode: U+0069)
バイトインデックス 2: 文字 ' ' (Unicode: U+0020)
バイトインデックス 3: 文字 '世' (Unicode: U+4E16)
バイトインデックス 6: 文字 '界' (Unicode: U+754C)
*/
```

**ポイント:**

*   文字列に対する `for range` は、UTF-8エンコーディングを自動的に解釈し、文字単位でループを回してくれます。
*   インデックス `i` はバイト単位の位置を示すため、マルチバイト文字の部分では連続しない値になることに注意してください。

`for range` は、コレクションの要素を安全かつ簡単に処理するための強力なツールです。次のセクションでは、マップに対する `for range` の使い方を見ていきます。