---
title: "制御構文: `for range` ループ (マップ)"
tags: ["flow-control", "for", "for range", "ループ", "繰り返し", "マップ", "map"]
---

`for range` ループは、キーと値のペアで構成される**マップ (map)** の要素を反復処理するためにも使われます。

## マップでの `for range`

マップに対して `for range` を使うと、各反復で**キー**とそのキーに対応する**値**のペアが返されます。

**構文:** `for キー変数, 値変数 := range マップ { ... ループ本体 ... }`

*   `キー変数`: 各要素のキーが代入されます。
*   `値変数`: 各要素の値が代入されます。
*   `マップ`: 反復処理の対象となるマップ。

**重要な注意点:** マップの `for range` ループでは、要素が取り出される**順序は保証されません**。実行するたびに順序が変わる可能性があります。もし特定の順序で処理したい場合は、先にキーを取り出してソートするなどの工夫が必要です。

```go title="マップでの for range"
package main

import "fmt"

func main() {
	// マップを作成 (文字列 -> 整数)
	scores := map[string]int{
		"Alice": 85,
		"Bob":   92,
		"Carol": 78,
	}

	fmt.Println("--- マップのキーと値 ---")
	// キーと値の両方を取得
	for name, score := range scores {
		fmt.Printf("名前: %s, 点数: %d\n", name, score)
	}
	// 実行ごとに表示される順序が変わる可能性があることに注意！

	// キーだけが必要な場合 (値を _ で無視)
	fmt.Println("\n--- キーだけを使う場合 ---")
	for name := range scores { // 値を受け取る変数を省略すると、キーのみが返される
		fmt.Printf("名前: %s\n", name)
	}

	// 値だけが必要な場合 (キーを _ で無視)
	fmt.Println("\n--- 値だけを使う場合 ---")
	totalScore := 0
	for _, score := range scores { // キーは使わないので _ で受ける
		totalScore += score
	}
	fmt.Printf("合計点数: %d\n", totalScore)

	// マップが nil や空の場合、ループは実行されない
	fmt.Println("\n--- 空マップの場合 ---")
	var emptyMap map[string]int
	for k, v := range emptyMap {
		fmt.Printf("空マップから取得: %s=%d\n", k, v) // この行は実行されない
	}
	fmt.Println("空マップのループ完了")
}

/* 実行結果 (順序は不定):
--- マップのキーと値 ---
名前: Alice, 点数: 85
名前: Bob, 点数: 92
名前: Carol, 点数: 78

--- キーだけを使う場合 ---
名前: Alice
名前: Bob
名前: Carol

--- 値だけを使う場合 ---
合計点数: 255

--- 空マップの場合 ---
空マップのループ完了
*/
```

**ポイント:**

*   マップに対する `for range` は、キーと値のペアを返します。
*   反復処理の順序は**不定**です。
*   キーまたは値の一方だけが必要な場合は、ブランク識別子 `_` を使って不要な方を受け取るか、値の変数を省略（キーのみ取得）します。
*   `nil` または空のマップに対して `for range` を実行してもエラーにはならず、ループ本体が一度も実行されないだけです。

`for range` はマップのすべての要素を処理する際に非常に便利な方法ですが、順序が保証されない点には注意が必要です。